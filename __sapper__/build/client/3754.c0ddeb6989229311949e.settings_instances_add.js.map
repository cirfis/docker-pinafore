{"version":3,"sources":["webpack://pinafore/./src/routes/_api/oauth.js","webpack://pinafore/./src/routes/_static/blocks.js","webpack://pinafore/./src/routes/_actions/addInstance.js","webpack://pinafore/./src/routes/_pages/settings/instances/add.html","webpack://pinafore/./src/routes/settings/instances/add.html","webpack://pinafore/./src/routes/_actions/emoji.js","webpack://pinafore/./src/routes/_api/emoji.js","webpack://pinafore/./src/routes/_actions/instances.js","webpack://pinafore/./src/routes/_utils/asyncModules/importVirtualListStore.js","webpack://pinafore/./src/routes/_api/instance.js","webpack://pinafore/./src/routes/_api/user.js","webpack://pinafore/./src/routes/_utils/asyncModules/importDatabase.js","webpack://pinafore/./src/routes/_database/asyncDatabase.js","webpack://pinafore/./src/routes/_utils/sync.js"],"names":["SCOPES","DOMAIN_BLOCKS","createKnownError","message","err","Error","knownError","getRedirectUri","location","origin","async","redirectToOauth","instanceNameInSearch","loggedInInstances","store","replace","toLowerCase","Object","keys","includes","instanceHostname","URL","hostname","some","domain","RegExp","test","redirectUri","registrationPromise","instanceName","url","client_name","redirect_uris","scopes","website","timeout","registerApplication","instanceInfo","database","instanceData","currentRegisteredInstanceName","currentRegisteredInstance","oauthUrl","clientId","params","client_id","redirect_uri","response_type","scope","generateAuthLink","setTimeout","document","href","registerNewInstance","code","clientSecret","client_secret","grant_type","getAccessTokenFromAuthCode","loggedInInstancesInOrder","instanceThemes","push","currentInstance","enableGrayscale","event","preventDefault","stopPropagation","logInToInstanceLoading","logInToInstanceError","console","error","name","navigator","onLine","logInToInstanceErrorForText","logInToInstance","codeMatch","search","match","handleOauthCode","this","set","hasIndexedDB","hasLocalStorage","$logInToInstanceError","$logInToInstanceErrorForText","$instanceNameInSearch","onSubmitInstance","$isUserLoggedIn","pageLabel","$logInToInstanceLoading","pageComponent","titleName","syncEmojiForInstance","syncMethod","accessToken","access_token","getCustomEmoji","emoji","customEmoji","isEqual","updateCustomEmojiForInstance","setupCustomEmojiForInstance","insertEmoji","realm","emojiText","unicode","composeSelectionStart","idx","oldText","newText","substring","text","changeTheme","newTheme","switchToInstance","searchResults","queryInSearch","logOutOfInstance","formatIntl","instance","composeData","instanceInfos","instanceLists","verifyCredentials","splice","indexOf","newInstance","objectsToClear","obj","timelineInitialized","timelinePreinitialized","virtualListStore","clearRealmByPrefix","toast","updateVerifyCredentialsForInstance","catch","startsWith","logOutOnUnauthorized","thisVerifyCredentials","setStoreVerifyCredentials","updateInstanceInfo","info","getInstanceInfo","getVerifyCredentials","getAccount","accountId","asyncDatabase","Proxy","get","prop","args","apply","cacheFirstUpdateAfter","networkFetcher","dbFetcher","dbUpdater","stateSetter","networkPromise","dbResponse","fetchAndUpdatePromise","then","networkResponse","cacheFirstUpdateOnlyIfNotInCache"],"mappings":"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","file":"3754.c0ddeb6989229311949e.settings_instances_add.js","sourcesContent":["import { post, paramsString, WRITE_TIMEOUT } from '../_utils/ajax'\nimport { basename } from './utils'\n\nconst WEBSITE = 'https://pinafore.social'\nconst SCOPES = 'read write follow push'\nconst CLIENT_NAME = 'Pinafore'\n\nexport function registerApplication (instanceName, redirectUri) {\n  const url = `${basename(instanceName)}/api/v1/apps`\n  return post(url, {\n    client_name: CLIENT_NAME,\n    redirect_uris: redirectUri,\n    scopes: SCOPES,\n    website: WEBSITE\n  }, null, { timeout: WRITE_TIMEOUT })\n}\n\nexport function generateAuthLink (instanceName, clientId, redirectUri) {\n  const params = paramsString({\n    client_id: clientId,\n    redirect_uri: redirectUri,\n    response_type: 'code',\n    scope: SCOPES\n  })\n  return `${basename(instanceName)}/oauth/authorize?${params}`\n}\n\nexport function getAccessTokenFromAuthCode (instanceName, clientId, clientSecret, code, redirectUri) {\n  const url = `${basename(instanceName)}/oauth/token`\n  return post(url, {\n    client_id: clientId,\n    client_secret: clientSecret,\n    redirect_uri: redirectUri,\n    grant_type: 'authorization_code',\n    code: code\n  }, null, { timeout: WRITE_TIMEOUT })\n}\n","export const DOMAIN_BLOCKS = [\n  'gab.com',\n  'gab.ai'\n]\n","import { getAccessTokenFromAuthCode, registerApplication, generateAuthLink } from '../_api/oauth'\nimport { getInstanceInfo } from '../_api/instance'\nimport { goto } from '../../../__sapper__/client'\nimport { DEFAULT_THEME, switchToTheme } from '../_utils/themeEngine'\nimport { store } from '../_store/store'\nimport { updateVerifyCredentialsForInstance } from './instances'\nimport { updateCustomEmojiForInstance } from './emoji'\nimport { database } from '../_database/database'\nimport { DOMAIN_BLOCKS } from '../_static/blocks'\n\nconst GENERIC_ERROR = `\n  Is this a valid Mastodon instance? Is a browser extension\n  blocking the request? Are you in private browsing mode?\n  If you believe this is a problem with your instance, please send\n  <a href=\"https://github.com/nolanlawson/pinafore/blob/master/docs/Admin-Guide.md\"\n    target=\"_blank\" rel=\"noopener\">this link</a> to the administrator of your instance.`\n\nfunction createKnownError (message) {\n  const err = new Error(message)\n  err.knownError = true\n  return err\n}\n\nfunction getRedirectUri () {\n  return `${location.origin}/settings/instances/add`\n}\n\nasync function redirectToOauth () {\n  let { instanceNameInSearch, loggedInInstances } = store.get()\n  instanceNameInSearch = instanceNameInSearch.replace(/^https?:\\/\\//, '').replace(/\\/+$/, '').toLowerCase()\n  if (Object.keys(loggedInInstances).includes(instanceNameInSearch)) {\n    throw createKnownError(`You've already logged in to ${instanceNameInSearch}`)\n  }\n  const instanceHostname = new URL(`http://${instanceNameInSearch}`).hostname\n  if (DOMAIN_BLOCKS.some(domain => new RegExp(`(?:\\\\.|^)${domain}$`, 'i').test(instanceHostname))) {\n    throw createKnownError('This service is blocked')\n  }\n  const redirectUri = getRedirectUri()\n  const registrationPromise = registerApplication(instanceNameInSearch, redirectUri)\n  const instanceInfo = await getInstanceInfo(instanceNameInSearch)\n  await database.setInstanceInfo(instanceNameInSearch, instanceInfo) // cache for later\n  const instanceData = await registrationPromise\n  store.set({\n    currentRegisteredInstanceName: instanceNameInSearch,\n    currentRegisteredInstance: instanceData\n  })\n  store.save()\n  const oauthUrl = generateAuthLink(\n    instanceNameInSearch,\n    instanceData.client_id,\n    redirectUri\n  )\n  // setTimeout to allow the browser to *actually* save the localStorage data (fixes Safari bug apparently)\n  setTimeout(() => {\n    document.location.href = oauthUrl\n  }, 200)\n}\n\nexport async function logInToInstance () {\n  store.set({\n    logInToInstanceLoading: true,\n    logInToInstanceError: null\n  })\n  try {\n    await redirectToOauth()\n  } catch (err) {\n    console.error(err)\n    const error = `${err.message || err.name}. ` +\n      (err.knownError ? '' : (navigator.onLine ? GENERIC_ERROR : 'Are you offline?'))\n    const { instanceNameInSearch } = store.get()\n    store.set({\n      logInToInstanceError: error,\n      logInToInstanceErrorForText: instanceNameInSearch\n    })\n  } finally {\n    store.set({ logInToInstanceLoading: false })\n  }\n}\n\nasync function registerNewInstance (code) {\n  const { currentRegisteredInstanceName, currentRegisteredInstance } = store.get()\n  const redirectUri = getRedirectUri()\n  const instanceData = await getAccessTokenFromAuthCode(\n    currentRegisteredInstanceName,\n    currentRegisteredInstance.client_id,\n    currentRegisteredInstance.client_secret,\n    code,\n    redirectUri\n  )\n  const { loggedInInstances, loggedInInstancesInOrder, instanceThemes } = store.get()\n  instanceThemes[currentRegisteredInstanceName] = DEFAULT_THEME\n  loggedInInstances[currentRegisteredInstanceName] = instanceData\n  if (!loggedInInstancesInOrder.includes(currentRegisteredInstanceName)) {\n    loggedInInstancesInOrder.push(currentRegisteredInstanceName)\n  }\n  store.set({\n    instanceNameInSearch: '',\n    currentRegisteredInstanceName: null,\n    currentRegisteredInstance: null,\n    loggedInInstances: loggedInInstances,\n    currentInstance: currentRegisteredInstanceName,\n    loggedInInstancesInOrder: loggedInInstancesInOrder,\n    instanceThemes: instanceThemes\n  })\n  store.save()\n  const { enableGrayscale } = store.get()\n  switchToTheme(DEFAULT_THEME, enableGrayscale)\n  // fire off these requests so they're cached\n  /* no await */ updateVerifyCredentialsForInstance(currentRegisteredInstanceName)\n  /* no await */ updateCustomEmojiForInstance(currentRegisteredInstanceName)\n  goto('/')\n}\n\nexport async function handleOauthCode (code) {\n  try {\n    store.set({ logInToInstanceLoading: true })\n    await registerNewInstance(code)\n  } catch (err) {\n    store.set({ logInToInstanceError: `${err.message || err.name}. Failed to connect to instance.` })\n  } finally {\n    store.set({ logInToInstanceLoading: false })\n  }\n}\n","<SettingsLayout page='settings/instances/add' label={pageLabel}>\n  <h1 id=\"add-an-instance-h1\">{pageLabel}</h1>\n\n  <div class=\"add-new-instance\">\n    <form on:submit='onSubmitInstance(event)' aria-labelledby=\"add-an-instance-h1\">\n\n      {#if !hasIndexedDB || !hasLocalStorage}\n        <div class=\"form-error form-error-user-error\" role=\"alert\">\n          It seems Pinafore cannot store data locally. Is your browser in private mode or blocking cookies? Pinafore stores all data locally, and requires LocalStorage and IndexedDB to work correctly.\n        </div>\n      {/if}\n\n      {#if $logInToInstanceError && $logInToInstanceErrorForText === $instanceNameInSearch}\n        <div class=\"form-error form-error-user-error\" role=\"alert\">\n          Error: {@html $logInToInstanceError}\n        </div>\n      {/if}\n\n      <noscript>\n        <div class=\"form-error\" role=\"alert\">\n          You must enable JavaScript to log in.\n        </div>\n      </noscript>\n\n      <label for=\"instanceInput\">Instance:</label>\n      <input type=\"text\" inputmode=\"url\" autocapitalize=\"none\" spellcheck=\"false\" id=\"instanceInput\"\n             bind:value='$instanceNameInSearch' placeholder=\"Enter instance name\" required\n      >\n      <button class=\"primary\" type=\"submit\" id=\"submitButton\"\n              disabled={!$instanceNameInSearch || $logInToInstanceLoading}>\n        Log in\n      </button>\n    </form>\n  </div>\n\n  {#if !$isUserLoggedIn}\n    <p>\n      Don't have an\n      <Tooltip\n        text=\"instance\"\n        tooltipText=\"An instance is your Mastodon home server, such as mastodon.social or cybre.space.\"\n      />\n      ?\n      <a rel=\"noopener\" target=\"_blank\" href=\"https://joinmastodon.org\">Join Mastodon!</a>\n    </p>\n  {/if}\n</SettingsLayout>\n<style>\n  .add-new-instance {\n    background: var(--form-bg);\n    padding: 5px 10px 15px;\n    margin: 20px auto;\n    border: 1px solid var(--form-border);\n    border-radius: 4px;\n  }\n\n  .form-error {\n    border: 2px solid var(--warn-color);\n    border-radius: 2px;\n    padding: 10px;\n    font-size: 1.3em;\n    margin: 5px;\n    background-color: var(--main-bg);\n  }\n  input {\n    min-width: 70%;\n    max-width: 100%;\n    background-color: var(--input-bg);\n  }\n\n  label, input, button, :global(.add-new-instance-aside) {\n    display: block;\n    margin: 20px 5px;\n  }\n\n  @media (max-width: 767px) {\n    input {\n      min-width: 95%;\n    }\n  }\n\n</style>\n<script>\n  import SettingsLayout from '../../../_components/settings/SettingsLayout.html'\n  import { store } from '../../../_store/store'\n  import { logInToInstance, handleOauthCode } from '../../../_actions/addInstance'\n  import { testHasIndexedDB, testHasLocalStorage } from '../../../_utils/testStorage'\n  import Tooltip from '../../../_components/Tooltip.html'\n\n  export default {\n    async oncreate () {\n      const codeMatch = location.search.match(/code=([^&]+)/)\n      if (codeMatch) {\n        return handleOauthCode(codeMatch[1])\n      }\n      this.set({\n        hasIndexedDB: await testHasIndexedDB(),\n        hasLocalStorage: testHasLocalStorage()\n      })\n    },\n    components: {\n      SettingsLayout,\n      Tooltip\n    },\n    store: () => store,\n    data: () => ({\n      hasIndexedDB: true,\n      hasLocalStorage: true\n    }),\n    computed: {\n      pageLabel: ({ $isUserLoggedIn }) => $isUserLoggedIn ? \"Add instance\" : \"Log in\"\n    },\n    methods: {\n      onSubmitInstance (event) {\n        event.preventDefault()\n        event.stopPropagation()\n        logInToInstance()\n      }\n    }\n  }\n</script>\n","<Title name={titleName} settingsPage={true} />\n\n  <LazyPage {pageComponent} {params} />\n\n<script>\n  import Title from '../../_components/Title.html'\n  import LazyPage from '../../_components/LazyPage.html'\n  import pageComponent from '../../_pages/settings/instances/add.html'\n\n  export default {\n    components: {\n\n      Title,\n      LazyPage\n    },\n    data: () => ({\n      pageComponent\n    }),\n    computed: {\n      titleName: ({ $isUserLoggedIn }) => $isUserLoggedIn ? \"Add instance\" : \"Log in\"\n    }\n  }\n</script>\n","import {\n  cacheFirstUpdateAfter,\n  cacheFirstUpdateOnlyIfNotInCache\n} from '../_utils/sync'\nimport { database } from '../_database/database'\nimport { getCustomEmoji } from '../_api/emoji'\nimport { store } from '../_store/store'\nimport isEqual from 'lodash-es/isEqual'\n\nasync function syncEmojiForInstance (instanceName, syncMethod) {\n  await syncMethod(\n    () => {\n      const { loggedInInstances } = store.get()\n      const accessToken = loggedInInstances[instanceName].access_token\n      return getCustomEmoji(instanceName, accessToken)\n    },\n    () => database.getCustomEmoji(instanceName),\n    emoji => database.setCustomEmoji(instanceName, emoji),\n    emoji => {\n      const { customEmoji } = store.get()\n      if (!isEqual(customEmoji[instanceName], emoji)) { // avoid triggering updates if nothing's changed\n        customEmoji[instanceName] = emoji\n        store.set({ customEmoji })\n      }\n    }\n  )\n}\n\nexport async function updateCustomEmojiForInstance (instanceName) {\n  await syncEmojiForInstance(instanceName, cacheFirstUpdateAfter)\n}\n\nexport async function setupCustomEmojiForInstance (instanceName) {\n  await syncEmojiForInstance(instanceName, cacheFirstUpdateOnlyIfNotInCache)\n}\n\nexport function insertEmoji (realm, emoji) {\n  const emojiText = emoji.unicode || `:${emoji.name}:`\n  const { composeSelectionStart } = store.get()\n  const idx = composeSelectionStart || 0\n  const oldText = store.getComposeData(realm, 'text') || ''\n  const pre = oldText.substring(0, idx)\n  const post = oldText.substring(idx)\n  const newText = `${pre}${emojiText} ${post}`\n  store.setComposeData(realm, { text: newText })\n}\n","import { auth, basename } from './utils'\nimport { DEFAULT_TIMEOUT, get } from '../_utils/ajax'\n\nexport function getCustomEmoji (instanceName, accessToken) {\n  const url = `${basename(instanceName)}/api/v1/custom_emojis`\n  return get(url, auth(accessToken), { timeout: DEFAULT_TIMEOUT })\n}\n","import { getVerifyCredentials } from '../_api/user'\nimport { store } from '../_store/store'\nimport { switchToTheme } from '../_utils/themeEngine'\nimport { toast } from '../_components/toast/toast'\nimport { goto } from '../../../__sapper__/client'\nimport { cacheFirstUpdateAfter } from '../_utils/sync'\nimport { getInstanceInfo } from '../_api/instance'\nimport { database } from '../_database/database'\nimport { importVirtualListStore } from '../_utils/asyncModules/importVirtualListStore.js'\nimport { formatIntl } from '../_utils/formatIntl'\n\nexport function changeTheme (instanceName, newTheme) {\n  const { instanceThemes } = store.get()\n  instanceThemes[instanceName] = newTheme\n  store.set({ instanceThemes: instanceThemes })\n  store.save()\n  const { currentInstance } = store.get()\n  if (instanceName === currentInstance) {\n    const { enableGrayscale } = store.get()\n    switchToTheme(newTheme, enableGrayscale)\n  }\n}\n\nexport function switchToInstance (instanceName) {\n  const { instanceThemes } = store.get()\n  store.set({\n    currentInstance: instanceName,\n    searchResults: null,\n    queryInSearch: ''\n  })\n  store.save()\n  const { enableGrayscale } = store.get()\n  switchToTheme(instanceThemes[instanceName], enableGrayscale)\n}\n\nexport async function logOutOfInstance (instanceName, message) {\n  message = message || formatIntl([\"Logged out of \",[\"instance\"]], { instance: instanceName })\n  const {\n    composeData,\n    currentInstance,\n    customEmoji,\n    instanceInfos,\n    instanceLists,\n    instanceThemes,\n    loggedInInstances,\n    loggedInInstancesInOrder,\n    verifyCredentials\n  } = store.get()\n  loggedInInstancesInOrder.splice(loggedInInstancesInOrder.indexOf(instanceName), 1)\n  const newInstance = instanceName === currentInstance ? loggedInInstancesInOrder[0] : currentInstance\n  const objectsToClear = [\n    composeData,\n    customEmoji,\n    instanceInfos,\n    instanceLists,\n    instanceThemes,\n    loggedInInstances,\n    verifyCredentials\n  ]\n  for (const obj of objectsToClear) {\n    delete obj[instanceName]\n  }\n  store.set({\n    composeData,\n    currentInstance: newInstance,\n    customEmoji,\n    instanceInfos,\n    instanceLists,\n    instanceThemes,\n    loggedInInstances,\n    loggedInInstancesInOrder,\n    queryInSearch: '',\n    searchResults: null,\n    timelineInitialized: false,\n    timelinePreinitialized: false,\n    verifyCredentials\n  })\n  store.clearTimelineDataForInstance(instanceName)\n  store.clearAutosuggestDataForInstance(instanceName)\n  store.save()\n  const { virtualListStore } = await importVirtualListStore()\n  virtualListStore.clearRealmByPrefix(currentInstance + '/') // TODO: this is a hacky way to clear the vlist cache\n  toast.say(message)\n  const { enableGrayscale } = store.get()\n  switchToTheme(instanceThemes[newInstance], enableGrayscale)\n  /* no await */ database.clearDatabaseForInstance(instanceName)\n  goto('/settings/instances')\n}\n\nfunction setStoreVerifyCredentials (instanceName, thisVerifyCredentials) {\n  const { verifyCredentials } = store.get()\n  verifyCredentials[instanceName] = thisVerifyCredentials\n  store.set({ verifyCredentials: verifyCredentials })\n}\n\nexport async function updateVerifyCredentialsForInstance (instanceName) {\n  const { loggedInInstances } = store.get()\n  const accessToken = loggedInInstances[instanceName].access_token\n  await cacheFirstUpdateAfter(\n    () => getVerifyCredentials(instanceName, accessToken).catch(logOutOnUnauthorized(instanceName)),\n    () => database.getInstanceVerifyCredentials(instanceName),\n    verifyCredentials => database.setInstanceVerifyCredentials(instanceName, verifyCredentials),\n    verifyCredentials => setStoreVerifyCredentials(instanceName, verifyCredentials)\n  )\n}\n\nexport async function updateVerifyCredentialsForCurrentInstance () {\n  const { currentInstance } = store.get()\n  await updateVerifyCredentialsForInstance(currentInstance)\n}\n\nexport async function updateInstanceInfo (instanceName) {\n  await cacheFirstUpdateAfter(\n    () => getInstanceInfo(instanceName),\n    () => database.getInstanceInfo(instanceName),\n    info => database.setInstanceInfo(instanceName, info),\n    info => {\n      const { instanceInfos } = store.get()\n      instanceInfos[instanceName] = info\n      store.set({ instanceInfos: instanceInfos })\n    }\n  )\n}\n\nexport function logOutOnUnauthorized (instanceName) {\n  return async error => {\n    if (error.message.startsWith('401:')) {\n      await logOutOfInstance(instanceName, formatIntl([\"The access token was revoked, logged out of \",[\"instance\"]], { instance: instanceName }))\n    }\n\n    throw error\n  }\n}\n","export const importVirtualListStore = () => import(\n  '../../_components/virtualList/virtualListStore.js'\n)\n","import { get, DEFAULT_TIMEOUT } from '../_utils/ajax'\nimport { basename } from './utils'\n\nexport function getInstanceInfo (instanceName) {\n  const url = `${basename(instanceName)}/api/v1/instance`\n  return get(url, null, { timeout: DEFAULT_TIMEOUT })\n}\n","import { get, DEFAULT_TIMEOUT } from '../_utils/ajax'\nimport { auth, basename } from './utils'\n\nexport function getVerifyCredentials (instanceName, accessToken) {\n  const url = `${basename(instanceName)}/api/v1/accounts/verify_credentials`\n  return get(url, auth(accessToken), { timeout: DEFAULT_TIMEOUT })\n}\n\nexport function getAccount (instanceName, accessToken, accountId) {\n  const url = `${basename(instanceName)}/api/v1/accounts/${accountId}`\n  return get(url, auth(accessToken), { timeout: DEFAULT_TIMEOUT })\n}\n","export const importDatabase = () => import(\n  '../../_database/databaseApis.js'\n)\n","// All database functions are asynchronous, so we can just proxy here and\n// put an async import of the database, to avoid including it in the main bundle\n// (which doesn't need to run when the user isn't logged in).\n\nimport { importDatabase } from '../_utils/asyncModules/importDatabase.js'\n\nconst handler = {\n  get: function (obj, prop) {\n    return async function (...args) {\n      if (!obj[prop]) {\n        const database = await importDatabase()\n        obj[prop] = database[prop]\n      }\n      return obj[prop].apply(null, args)\n    }\n  }\n}\n\nexport const asyncDatabase = new Proxy({}, handler)\n","// Hit both the cache and the network, setting state for the cached version first,\n// then the network version (as it's assumed to be fresher). Also update the db afterwards.\nexport async function cacheFirstUpdateAfter (networkFetcher, dbFetcher, dbUpdater, stateSetter) {\n  const networkPromise = networkFetcher() // kick off network request immediately\n  let dbResponse\n  try {\n    dbResponse = await dbFetcher()\n  } catch (err) {\n    console.error('ignored DB error', err)\n  } finally {\n    if (dbResponse) {\n      stateSetter(dbResponse)\n    }\n    const fetchAndUpdatePromise = networkPromise.then(networkResponse => {\n      /* no await */ dbUpdater(networkResponse)\n      stateSetter(networkResponse)\n    })\n    if (!dbResponse) { // no cached result available, await the network\n      await fetchAndUpdatePromise\n    }\n  }\n}\n\n// Try the cache first. If we get a hit, set the state and do nothing. If we don't get a cache hit,\n// then go to the network, update the cache, and set the state.\nexport async function cacheFirstUpdateOnlyIfNotInCache (networkFetcher, dbFetcher, dbUpdater, stateSetter) {\n  let dbResponse\n  try {\n    dbResponse = await dbFetcher()\n  } catch (err) {\n    console.error('ignored DB error', err)\n  }\n  if (dbResponse) {\n    stateSetter(dbResponse)\n  } else {\n    const networkResponse = await networkFetcher()\n    /* no await */ dbUpdater(networkResponse)\n    stateSetter(networkResponse)\n  }\n}\n"],"sourceRoot":""}