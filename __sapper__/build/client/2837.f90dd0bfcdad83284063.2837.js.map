{"version":3,"sources":["webpack://pinafore/./src/routes/_components/radio/RadioGroup.html","webpack://pinafore/./src/routes/_components/radio/RadioGroupButton.html","webpack://pinafore/./src/routes/_api/utils.js","webpack://pinafore/./src/routes/_utils/asyncModules/importDatabase.js","webpack://pinafore/./src/routes/_database/asyncDatabase.js","webpack://pinafore/./src/routes/_utils/ajax.js","webpack://pinafore/./src/routes/_utils/sync.js"],"names":["e","key","target","includes","classList","contains","buttons","Array","from","this","refs","radiogroup","getElementsByClassName","len","length","newIndex","Math","max","findIndex","button","getAttribute","focus","click","preventDefault","stopPropagation","className","onKeyDown","event","label","ariaOwns","id","index","join","checked","basename","instanceName","startsWith","targetIsLocalhost","auth","accessToken","Authorization","asyncDatabase","Proxy","get","obj","prop","async","args","database","apply","DEFAULT_TIMEOUT","MEDIA_WRITE_TIMEOUT","WRITE_TIMEOUT","makeFetchOptions","method","headers","options","res","Object","assign","Accept","signal","_fetch","url","fetchOptions","response","timeout","Promise","resolve","reject","fetch","then","setTimeout","Error","fetchWithTimeout","status","err","json","error","throwErrorIfInvalidResponse","_putOrPostOrPatch","body","FormData","JSON","stringify","put","post","getWithHeaders","del","paramsString","paramsObject","count","keys","forEach","value","isArray","item","encodeURIComponent","cacheFirstUpdateAfter","networkFetcher","dbFetcher","dbUpdater","stateSetter","networkPromise","dbResponse","console","fetchAndUpdatePromise","networkResponse","cacheFirstUpdateOnlyIfNotInCache"],"mappings":"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","file":"2837.f90dd0bfcdad83284063.2837.js","sourcesContent":["<!-- Modeled after https://www.w3.org/TR/2016/WD-wai-aria-practices-1.1-20160317/examples/radio/radio.html -->\n<div class=\"radio-group {className}\"\n     role=\"radiogroup\"\n     aria-label={label}\n     aria-owns={ariaOwns}\n     on:keydown=\"onKeyDown(event)\"\n     ref:radiogroup\n>\n  <slot></slot>\n</div>\n<script>\n  import { times } from '../../_utils/lodash-lite'\n\n  export default {\n    methods: {\n      onKeyDown (e) {\n        // ArrowUp and ArrowDown should change the focused/checked radio button per\n        // https://www.w3.org/TR/2016/WD-wai-aria-practices-1.1-20160317/examples/radio/radio.html\n        const { key, target } = e\n        if (!['ArrowUp', 'ArrowDown'].includes(key)) {\n          return\n        }\n        if (!target.classList.contains('radio-group-button')) {\n          return\n        }\n        const buttons = Array.from(this.refs.radiogroup.getElementsByClassName('radio-group-button'))\n        const len = buttons.length\n        const index = Math.max(0, buttons.findIndex(button => button.getAttribute('aria-checked') === 'true'))\n        const newIndex = (len + (index + (key === 'ArrowUp' ? -1 : 1))) % len // increment/decrement and wrap around\n        buttons[newIndex].focus()\n        buttons[newIndex].click()\n        e.preventDefault()\n        e.stopPropagation()\n      }\n    },\n    data: () => ({\n      className: ''\n    }),\n    computed: {\n      ariaOwns: ({ length, id }) => (\n        times(length, index => `radio-group-button-${id}-${index}`).join(' ')\n      )\n    }\n  }\n</script>\n","<button id=\"radio-group-button-{id}-{index}\"\n        class=\"radio-group-button {checked ? 'checked' : 'not-checked'} {className}\"\n        role=\"radio\"\n        aria-label={label}\n        title={label}\n        aria-checked={checked}\n        on:click\n>\n  <slot></slot>\n</button>\n<style>\n  .radio-group-button {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    border: 0;\n    background: none;\n  }\n  .radio-group-button:hover {\n    background: none;\n  }\n  .radio-group-button:active {\n    background: none;\n  }\n</style>\n<script>\n  export default {\n    data: () => ({\n      className: ''\n    })\n  }\n</script>\n","function targetIsLocalhost (instanceName) {\n  return instanceName.startsWith('localhost:') || instanceName.startsWith('127.0.0.1:')\n}\n\nexport function basename (instanceName) {\n  if (targetIsLocalhost(instanceName)) {\n    return `http://${instanceName}`\n  }\n  return `https://${instanceName}`\n}\n\nexport function auth (accessToken) {\n  return {\n    Authorization: `Bearer ${accessToken}`\n  }\n}\n","export const importDatabase = () => import(\n  '../../_database/databaseApis.js'\n)\n","// All database functions are asynchronous, so we can just proxy here and\n// put an async import of the database, to avoid including it in the main bundle\n// (which doesn't need to run when the user isn't logged in).\n\nimport { importDatabase } from '../_utils/asyncModules/importDatabase.js'\n\nconst handler = {\n  get: function (obj, prop) {\n    return async function (...args) {\n      if (!obj[prop]) {\n        const database = await importDatabase()\n        obj[prop] = database[prop]\n      }\n      return obj[prop].apply(null, args)\n    }\n  }\n}\n\nexport const asyncDatabase = new Proxy({}, handler)\n","export const DEFAULT_TIMEOUT = 20000\nexport const MEDIA_WRITE_TIMEOUT = 90000 // media uploads can take awhile\nexport const WRITE_TIMEOUT = 45000 // allow more time if the user did a write action\n\nfunction fetchWithTimeout (url, fetchOptions, timeout) {\n  return new Promise((resolve, reject) => {\n    fetch(url, fetchOptions).then(resolve, reject)\n    setTimeout(() => reject(new Error(`Timed out after ${timeout / 1000} seconds`)), timeout)\n  })\n}\n\nfunction makeFetchOptions (method, headers, options) {\n  const res = {\n    method,\n    headers: Object.assign(headers || {}, {\n      Accept: 'application/json'\n    })\n  }\n  if (options && options.signal) {\n    res.signal = options.signal\n  }\n  return res\n}\n\nasync function throwErrorIfInvalidResponse (response) {\n  if (response.status >= 300) {\n    const err = new Error('Request failed: ' + response.status)\n    err.status = response.status\n    throw err\n  }\n  const json = await response.json()\n  if (response.status >= 200 && response.status < 300) {\n    return { json, headers: response.headers }\n  }\n  if (json && json.error) {\n    throw new Error(response.status + ': ' + json.error)\n  }\n  throw new Error('Request failed: ' + response.status)\n}\n\nasync function _fetch (url, fetchOptions, options) {\n  let response\n  if (options && options.timeout) {\n    response = await fetchWithTimeout(url, fetchOptions, options.timeout)\n  } else {\n    response = await fetch(url, fetchOptions)\n  }\n  return throwErrorIfInvalidResponse(response)\n}\n\nasync function _putOrPostOrPatch (method, url, body, headers, options) {\n  const fetchOptions = makeFetchOptions(method, headers, options)\n  if (body) {\n    if (body instanceof FormData) {\n      fetchOptions.body = body\n    } else {\n      fetchOptions.body = JSON.stringify(body)\n      fetchOptions.headers['Content-Type'] = 'application/json'\n    }\n  }\n  return _fetch(url, fetchOptions, options)\n}\n\nexport async function put (url, body, headers, options) {\n  return (await _putOrPostOrPatch('PUT', url, body, headers, options)).json\n}\n\nexport async function post (url, body, headers, options) {\n  return (await _putOrPostOrPatch('POST', url, body, headers, options)).json\n}\n\nexport async function patch (url, body, headers, options) {\n  return (await _putOrPostOrPatch('PATCH', url, body, headers, options)).json\n}\n\nexport async function get (url, headers, options) {\n  return (await _fetch(url, makeFetchOptions('GET', headers, options), options)).json\n}\n\n/** @returns {json, headers} */\nexport async function getWithHeaders (url, headers, options) {\n  return _fetch(url, makeFetchOptions('GET', headers, options), options)\n}\n\nexport async function del (url, headers, options) {\n  return (await _fetch(url, makeFetchOptions('DELETE', headers, options), options)).json\n}\n\nexport function paramsString (paramsObject) {\n  let res = ''\n  let count = -1\n  Object.keys(paramsObject).forEach(key => {\n    const value = paramsObject[key]\n    if (Array.isArray(value)) { // rails convention for encoding multiple values\n      for (const item of value) {\n        res += (++count > 0 ? '&' : '') + encodeURIComponent(key) + '[]=' + encodeURIComponent(item)\n      }\n    } else {\n      res += (++count > 0 ? '&' : '') + encodeURIComponent(key) + '=' + encodeURIComponent(value)\n    }\n  })\n  return res\n}\n","// Hit both the cache and the network, setting state for the cached version first,\n// then the network version (as it's assumed to be fresher). Also update the db afterwards.\nexport async function cacheFirstUpdateAfter (networkFetcher, dbFetcher, dbUpdater, stateSetter) {\n  const networkPromise = networkFetcher() // kick off network request immediately\n  let dbResponse\n  try {\n    dbResponse = await dbFetcher()\n  } catch (err) {\n    console.error('ignored DB error', err)\n  } finally {\n    if (dbResponse) {\n      stateSetter(dbResponse)\n    }\n    const fetchAndUpdatePromise = networkPromise.then(networkResponse => {\n      /* no await */ dbUpdater(networkResponse)\n      stateSetter(networkResponse)\n    })\n    if (!dbResponse) { // no cached result available, await the network\n      await fetchAndUpdatePromise\n    }\n  }\n}\n\n// Try the cache first. If we get a hit, set the state and do nothing. If we don't get a cache hit,\n// then go to the network, update the cache, and set the state.\nexport async function cacheFirstUpdateOnlyIfNotInCache (networkFetcher, dbFetcher, dbUpdater, stateSetter) {\n  let dbResponse\n  try {\n    dbResponse = await dbFetcher()\n  } catch (err) {\n    console.error('ignored DB error', err)\n  }\n  if (dbResponse) {\n    stateSetter(dbResponse)\n  } else {\n    const networkResponse = await networkFetcher()\n    /* no await */ dbUpdater(networkResponse)\n    stateSetter(networkResponse)\n  }\n}\n"],"sourceRoot":""}