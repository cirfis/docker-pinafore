{"version":3,"sources":["webpack://pinafore/./src/routes/_components/list/ListItem.html","webpack://pinafore/./src/routes/_components/list/ListLazyItem.html","webpack://pinafore/./src/routes/_components/list/listStore.js","webpack://pinafore/./src/routes/_components/list/List.html","webpack://pinafore/./src/routes/_utils/RealmStore.js"],"names":["doubleRAF","this","set","shown","component","props","index","length","key","makeProps","get","fire","s","undefined","ListStore","RealmStore","state","super","listStore","computeForRealm","window","__listStore","observe","initializedCount","initialize","scrollToItem","element","document","getElementById","requestAnimationFrame","scrollTopOffset","getBoundingClientRect","height","scrollIntoView","scrollTop","realm","store","setCurrentRealm","i","item","itemInitialized","safeItems","items","init","maxSize","realms","_batches","currentRealm","obj","Object","assign","defaultValue","compute","realmData","subKey","value","realmBatches","batch","updatedKeys","keys","otherKey"],"mappings":"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","file":"4686.c523a1eba1b377e3c961.4686.js","sourcesContent":["<style>\n  .list-item {\n    opacity: 0;\n    pointer-events: none;\n    transition: opacity 0.2s linear;\n    contain: content; /* see https://www.w3.org/TR/2018/CR-css-contain-1-20181108/#valdef-contain-content */\n  }\n\n  .list-item.shown {\n    opacity: 1;\n    pointer-events: auto;\n  }\n</style>\n<div class=\"list-item {shown && 'shown'}\"\n     id={`list-item-${key}`} >\n  <svelte:component this={component}\n              virtualProps={props}\n              virtualIndex={index}\n              virtualLength={length}\n              virtualKey={key}\n  />\n</div>\n<script>\n  import { doubleRAF } from '../../_utils/doubleRAF'\n\n  export default {\n    oncreate () {\n      doubleRAF(() => {\n        this.set({ shown: true }) // ensure fade-in animation happens after rAF\n      })\n    },\n    data: () => ({\n      shown: false\n    })\n  }\n</script>\n","{#if props}\n  <ListItem\n    {component}\n    {props}\n    {key}\n    {index}\n    {length}\n    on:initialized\n  />\n{/if}\n<script>\n  import ListItem from './ListItem.html'\n  import { mark, stop } from '../../_utils/marks'\n\n  export default {\n    async oncreate () {\n      const { makeProps, key } = this.get()\n      if (makeProps) {\n        const props = await makeProps(key)\n        mark('ListLazyItem set props')\n        this.set({ props: props })\n        this.fire('initialized')\n        stop('ListLazyItem set props')\n      }\n    },\n    data: () => ({\n      props: undefined\n    }),\n    components: {\n      ListItem\n    }\n  }\n</script>\n","import { RealmStore } from '../../_utils/RealmStore'\nimport { PAGE_HISTORY_SIZE } from '../../_static/pages'\n\nclass ListStore extends RealmStore {\n  constructor (state) {\n    super(state, /* maxSize */ PAGE_HISTORY_SIZE)\n  }\n}\n\nconst listStore = new ListStore()\n\nlistStore.computeForRealm('intersectionStates', {})\n\nif (process.browser) {\n  window.__listStore = listStore // for debugging\n}\n\nexport { listStore }\n","<div class=\"the-list\" on:initialized>\n  {#each safeItems as item, i (item)}\n    <ListLazyItem\n      {component}\n      index={i}\n      {length}\n      {makeProps}\n      key={item}\n      on:initialized=\"itemInitialized()\"\n    />\n  {/each}\n</div>\n<style>\n  .the-list {\n    position: relative;\n  }\n</style>\n<script>\n  import ListLazyItem from './ListLazyItem.html'\n  import { listStore } from './listStore'\n  import { getScrollContainer } from '../../_utils/scrollContainer'\n  import { observe } from 'svelte-extras'\n  import { mark, stop } from '../../_utils/marks'\n\n  function getScrollTopOffset () {\n    return document.getElementById('main-nav').getBoundingClientRect().height\n  }\n\n  export default {\n    oncreate () {\n      const { realm } = this.get()\n      this.store.setCurrentRealm(realm)\n\n      if (process.env.NODE_ENV !== 'production') {\n        this.observe('safeItems', safeItems => {\n          if (new Set(safeItems).size !== safeItems.length) {\n            console.error('list of items is not unique:', safeItems)\n          }\n        })\n      }\n    },\n    ondestroy () {\n      this.store.setCurrentRealm(null)\n    },\n    methods: {\n      observe,\n      itemInitialized () {\n        let { initializedCount, length } = this.get()\n        initializedCount++\n        this.set({ initializedCount })\n        if (initializedCount === length) {\n          this.initialize()\n        }\n      },\n      initialize () {\n        const { scrollToItem } = this.get()\n        if (scrollToItem) {\n          const element = document.getElementById(`list-item-${scrollToItem}`)\n          requestAnimationFrame(() => {\n            console.log('scrolling element into view')\n            mark('scrollToElement')\n            const scrollTopOffset = getScrollTopOffset()\n            element.scrollIntoView(true)\n            console.log('scrollTopOffset', scrollTopOffset)\n            getScrollContainer().scrollTop -= scrollTopOffset\n            stop('scrollToElement')\n            this.fire('initialized')\n          })\n        } else {\n          this.fire('initialized')\n        }\n      }\n    },\n    data: () => ({\n      initializedCount: 0\n    }),\n    computed: {\n      safeItems: ({ items }) => items || [],\n      length: ({ safeItems }) => safeItems.length\n    },\n    components: {\n      ListLazyItem\n    },\n    store: () => listStore\n  }\n</script>\n","// A store where you can divide data into \"realms\" that are backed with an LRU cache.\n// Each realm has self-contained data that you can set with setForRealm() and compute\n// with computeForRealm(). The maxSize determines how many realms to keep in the LRU cache.\nimport { Store } from 'svelte/store.js'\nimport { QuickLRU } from '../_thirdparty/quick-lru/quick-lru'\nimport { mark, stop } from './marks'\nimport { requestPostAnimationFrame } from './requestPostAnimationFrame'\n\nexport class RealmStore extends Store {\n  constructor (init, maxSize) {\n    super(init)\n    this.set({ realms: new QuickLRU({ maxSize: maxSize }) })\n    this._batches = {}\n  }\n\n  setCurrentRealm (realm) {\n    this.set({ currentRealm: realm })\n  }\n\n  setForRealm (obj) {\n    const { currentRealm, realms } = this.get()\n    realms.set(currentRealm, Object.assign(realms.get(currentRealm) || {}, obj))\n    this.set({ realms: realms })\n  }\n\n  computeForRealm (key, defaultValue) {\n    this.compute(key,\n      ['realms', 'currentRealm'],\n      (realms, currentRealm) => {\n        const realmData = realms.get(currentRealm)\n        return (realmData && realmData[key]) || defaultValue\n      })\n  }\n\n  /*\n   * Update several values at once in a realm, assuming the key points\n   * to a plain old javascript object.\n   */\n  batchUpdateForRealm (key, subKey, value) {\n    const { currentRealm } = this.get()\n    let realmBatches = this._batches[currentRealm]\n    if (!realmBatches) {\n      realmBatches = this._batches[currentRealm] = {}\n    }\n    let batch = realmBatches[key]\n    if (!batch) {\n      batch = realmBatches[key] = {}\n    }\n    batch[subKey] = value\n\n    requestPostAnimationFrame(() => {\n      const batch = this._batches[currentRealm] && this._batches[currentRealm][key]\n      if (!batch) {\n        return\n      }\n      const updatedKeys = Object.keys(batch)\n      if (!updatedKeys.length) {\n        return\n      }\n      mark('batchUpdate')\n      const obj = this.get()[key]\n      for (const otherKey of updatedKeys) {\n        obj[otherKey] = batch[otherKey]\n      }\n      delete this._batches[currentRealm][key]\n      const { realms } = this.get()\n      realms.set(currentRealm, Object.assign(realms.get(currentRealm) || {}, { [key]: obj }))\n      this.set({ realms: realms })\n      stop('batchUpdate')\n    })\n  }\n}\n"],"sourceRoot":""}