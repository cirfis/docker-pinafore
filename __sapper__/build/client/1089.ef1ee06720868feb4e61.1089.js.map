{"version":3,"sources":["webpack://pinafore/./src/routes/_thirdparty/quick-lru/quick-lru.js","webpack://pinafore/./src/routes/_utils/requestPostAnimationFrame.js"],"names":["QuickLRU","EventEmitter","options","super","maxSize","TypeError","this","cache","Map","oldCache","_size","key","value","set","listenerCount","keys","has","emit","get","delete","_set","deleted","clear","Set","add","channel","MessageChannel","callbacks","runCallback","callback","e","console","error","postMessage","port2","undefined","port1","onmessage","length","requestPostAnimationFrame","push","requestAnimationFrame"],"mappings":"mIAKO,MAAMA,UAAiB,EAAAC,aAC5B,YAAaC,EAAU,IAErB,GADAC,UACMD,EAAQE,SAAWF,EAAQE,QAAU,GACzC,MAAM,IAAIC,UAAU,6CAGtBC,KAAKF,QAAUF,EAAQE,QACvBE,KAAKC,MAAQ,IAAIC,IACjBF,KAAKG,SAAW,IAAID,IACpBF,KAAKI,MAAQ,EAGf,KAAMC,EAAKC,GAIT,GAHAN,KAAKC,MAAMM,IAAIF,EAAKC,GACpBN,KAAKI,QAEDJ,KAAKI,OAASJ,KAAKF,QAAS,CAE9B,GADAE,KAAKI,MAAQ,EACTJ,KAAKQ,cAAc,SACrB,IAAK,MAAMH,KAAOL,KAAKG,SAASM,OACzBT,KAAKC,MAAMS,IAAIL,IAClBL,KAAKW,KAAK,QAASX,KAAKG,SAASS,IAAIP,GAAMA,GAIjDL,KAAKG,SAAWH,KAAKC,MACrBD,KAAKC,MAAQ,IAAIC,KAIrB,IAAKG,GACH,GAAIL,KAAKC,MAAMS,IAAIL,GACjB,OAAOL,KAAKC,MAAMW,IAAIP,GAGxB,GAAIL,KAAKG,SAASO,IAAIL,GAAM,CAC1B,MAAMC,EAAQN,KAAKG,SAASS,IAAIP,GAGhC,OAFAL,KAAKG,SAASU,OAAOR,GACrBL,KAAKc,KAAKT,EAAKC,GACRA,GAIX,IAAKD,EAAKC,GAOR,OANIN,KAAKC,MAAMS,IAAIL,GACjBL,KAAKC,MAAMM,IAAIF,EAAKC,GAEpBN,KAAKc,KAAKT,EAAKC,GAGVN,KAGT,IAAKK,GACH,OAAOL,KAAKC,MAAMS,IAAIL,IAAQL,KAAKG,SAASO,IAAIL,GAclD,OAAQA,GACN,MAAMU,EAAUf,KAAKC,MAAMY,OAAOR,GAKlC,OAJIU,GACFf,KAAKI,QAGAJ,KAAKG,SAASU,OAAOR,IAAQU,EAGtC,QACEf,KAAKC,MAAMe,QACXhB,KAAKG,SAASa,QACdhB,KAAKI,MAAQ,EAGf,aACE,MAAMG,EAAM,IAAIU,IAChB,IAAK,MAAMZ,KAAOL,KAAKC,MAAMQ,OAC3BF,EAAIW,IAAIb,GAEV,IAAK,MAAMA,KAAOL,KAAKG,SAASM,OAC9BF,EAAIW,IAAIb,GAEV,OAAOE,K,6CC/FX,MAAMY,EAA6B,IAAIC,eACjCC,EAAY,GAMlB,SAASC,EAAaC,GACpB,IACEA,IACA,MAAOC,GACPC,QAAQC,MAAMF,IAWlB,SAASG,IACPR,EAAQS,MAAMD,iBAAYE,GAnB1BV,EAAQW,MAAMC,UAWhB,WACE,IAAK,MAAMR,KAAYF,EACrBC,EAAYC,GAEdF,EAAUW,OAAS,GAOd,MAAMC,EAA4BV,IACN,IAA7BF,EAAUa,KAAKX,IACjBY,sBAAsBR","file":"1089.ef1ee06720868feb4e61.1089.js","sourcesContent":["// Forked from https://github.com/sindresorhus/quick-lru/blob/16d15d470a8eb87c2a7dd5b80892d9b74f1acd3c/index.js\n// Adds the ability to listen for 'evict' events using an EventEmitter, also removes some unused code\n\nimport { EventEmitter } from 'events-light'\n\nexport class QuickLRU extends EventEmitter {\n  constructor (options = {}) {\n    super()\n    if (!(options.maxSize && options.maxSize > 0)) {\n      throw new TypeError('`maxSize` must be a number greater than 0')\n    }\n\n    this.maxSize = options.maxSize\n    this.cache = new Map()\n    this.oldCache = new Map()\n    this._size = 0\n  }\n\n  _set (key, value) {\n    this.cache.set(key, value)\n    this._size++\n\n    if (this._size >= this.maxSize) {\n      this._size = 0\n      if (this.listenerCount('evict')) {\n        for (const key of this.oldCache.keys()) {\n          if (!this.cache.has(key)) {\n            this.emit('evict', this.oldCache.get(key), key)\n          }\n        }\n      }\n      this.oldCache = this.cache\n      this.cache = new Map()\n    }\n  }\n\n  get (key) {\n    if (this.cache.has(key)) {\n      return this.cache.get(key)\n    }\n\n    if (this.oldCache.has(key)) {\n      const value = this.oldCache.get(key)\n      this.oldCache.delete(key)\n      this._set(key, value)\n      return value\n    }\n  }\n\n  set (key, value) {\n    if (this.cache.has(key)) {\n      this.cache.set(key, value)\n    } else {\n      this._set(key, value)\n    }\n\n    return this\n  }\n\n  has (key) {\n    return this.cache.has(key) || this.oldCache.has(key)\n  }\n\n  // unused\n  // peek (key) {\n  //   if (this.cache.has(key)) {\n  //     return this.cache.get(key)\n  //   }\n  //\n  //   if (this.oldCache.has(key)) {\n  //     return this.oldCache.get(key)\n  //   }\n  // }\n\n  delete (key) {\n    const deleted = this.cache.delete(key)\n    if (deleted) {\n      this._size--\n    }\n\n    return this.oldCache.delete(key) || deleted\n  }\n\n  clear () {\n    this.cache.clear()\n    this.oldCache.clear()\n    this._size = 0\n  }\n\n  getAllKeys () {\n    const set = new Set()\n    for (const key of this.cache.keys()) {\n      set.add(key)\n    }\n    for (const key of this.oldCache.keys()) {\n      set.add(key)\n    }\n    return set\n  }\n\n  // unused\n  // * keys() {\n  //   for (const [key] of this) {\n  //     yield key;\n  //   }\n  // }\n  //\n  // * values() {\n  //   for (const [, value] of this) {\n  //     yield value;\n  //   }\n  // }\n  //\n  // * [Symbol.iterator]() {\n  //   for (const item of this.cache) {\n  //     yield item;\n  //   }\n  //\n  //   for (const item of this.oldCache) {\n  //     const [key] = item;\n  //     if (!this.cache.has(key)) {\n  //       yield item;\n  //     }\n  //   }\n  // }\n  //\n  // get size () {\n  //   let oldCacheSize = 0\n  //   for (const key of this.oldCache.keys()) {\n  //     if (!this.cache.has(key)) {\n  //       oldCacheSize++\n  //     }\n  //   }\n  //\n  //   return this._size + oldCacheSize\n  // }\n}\n","// modeled after https://github.com/andrewiggins/afterframe\n// see also https://github.com/WICG/requestPostAnimationFrame\nconst channel = process.browser && new MessageChannel()\nconst callbacks = []\n\nif (process.browser) {\n  channel.port1.onmessage = onMessage\n}\n\nfunction runCallback (callback) {\n  try {\n    callback()\n  } catch (e) {\n    console.error(e)\n  }\n}\n\nfunction onMessage () {\n  for (const callback of callbacks) {\n    runCallback(callback)\n  }\n  callbacks.length = 0\n}\n\nfunction postMessage () {\n  channel.port2.postMessage(undefined)\n}\n\nexport const requestPostAnimationFrame = callback => {\n  if (callbacks.push(callback) === 1) {\n    requestAnimationFrame(postMessage)\n  }\n}\n"],"sourceRoot":""}