{"version":3,"sources":["webpack://pinafore/./src/routes/_actions/deleteStatuses.js","webpack://pinafore/./src/routes/_actions/statuses.js","webpack://pinafore/./src/routes/_actions/followRequests.js","webpack://pinafore/./src/routes/_actions/instances.js","webpack://pinafore/./src/routes/_utils/asyncModules/importVirtualListStore.js","webpack://pinafore/./src/routes/_actions/lists.js","webpack://pinafore/./src/routes/_api/lists.js","webpack://pinafore/./src/routes/_api/followRequests.js","webpack://pinafore/./src/routes/_api/instance.js","webpack://pinafore/./src/routes/_api/search.js","webpack://pinafore/./src/routes/_api/timelines.js","webpack://pinafore/./src/routes/_api/user.js","webpack://pinafore/./src/routes/_api/utils.js","webpack://pinafore/./src/routes/_components/dialog/asyncDialogs/importShowComposeDialog.js","webpack://pinafore/./src/routes/_static/database.js","webpack://pinafore/./src/routes/_static/emojiPickerIntl.js","webpack://pinafore/./src/routes/_static/wordFilters.js","webpack://pinafore/./src/routes/_utils/getIdFromItemSummaries.js","webpack://pinafore/./src/routes/_store/computations/timelineComputations.js","webpack://pinafore/./src/routes/_store/computations/autosuggestComputations.js","webpack://pinafore/./src/routes/_store/computations/wordFilterComputations.js","webpack://pinafore/./src/routes/_utils/createRegexFromFilters.js","webpack://pinafore/./src/routes/_utils/createFilterFunction.js","webpack://pinafore/./src/routes/_store/computations/timelineFilterComputations.js","webpack://pinafore/./src/routes/_thirdparty/websocket/backoff.js","webpack://pinafore/./src/routes/_thirdparty/websocket/websocket.js","webpack://pinafore/./src/routes/_api/stream/TimelineStream.js","webpack://pinafore/./src/routes/_api/stream/getStreamUrl.js","webpack://pinafore/./src/routes/_actions/stream/processMessage.js","webpack://pinafore/./src/routes/_actions/stream/streaming.js","webpack://pinafore/./src/routes/_actions/stream/fillStreamingGap.js","webpack://pinafore/./src/routes/_store/observers/instanceObservers.js","webpack://pinafore/./src/routes/_store/observers/timelineObservers.js","webpack://pinafore/./src/routes/_store/observers/notificationObservers.js","webpack://pinafore/./src/routes/_utils/runMediumPriorityTask.js","webpack://pinafore/./src/routes/_utils/setFavicon.js","webpack://pinafore/./node_modules/is-emoji-supported/dist/esm/is-emoji-supported.js","webpack://pinafore/./src/routes/_utils/testEmojiSupported.js","webpack://pinafore/./src/routes/_actions/autosuggestEmojiSearch.js","webpack://pinafore/./src/routes/_static/autosuggest.js","webpack://pinafore/./src/routes/_utils/RequestThrottler.js","webpack://pinafore/./src/routes/_utils/PromiseThrottler.js","webpack://pinafore/./src/routes/_actions/autosuggestAccountSearch.js","webpack://pinafore/./src/routes/_actions/autosuggestHashtagSearch.js","webpack://pinafore/./src/routes/_store/observers/autosuggestObservers.js","webpack://pinafore/./src/routes/_store/observers/customScrollbarObservers.js","webpack://pinafore/./src/routes/_store/observers/cleanup.js","webpack://pinafore/./src/routes/_store/observers/showComposeDialogObservers.js","webpack://pinafore/./src/routes/_actions/showComposeDialog.js","webpack://pinafore/./src/routes/_utils/userAgent/isChromePre87.js","webpack://pinafore/./src/routes/_store/mixins/statusMixins.js","webpack://pinafore/./src/routes/_store/mixins/loggedInMixins.js","webpack://pinafore/./src/routes/_store/mixins/composeMixins.js","webpack://pinafore/./src/routes/_store/mixins/timelineMixins.js","webpack://pinafore/./src/routes/_store/mixins/autosuggestMixins.js","webpack://pinafore/./src/routes/_store/computations/loggedInComputations.js","webpack://pinafore/./src/routes/_store/computations/badgeComputations.js","webpack://pinafore/./src/routes/_store/observers/loggedInObservers.js","webpack://pinafore/./src/routes/_store/observers/wordFilterObservers.js","webpack://pinafore/./src/routes/_store/observers/notificationPermissionObservers.js","webpack://pinafore/./src/routes/_store/observers/customEmojiObservers.js","webpack://pinafore/./src/routes/_store/observers/badgeObservers.js","webpack://pinafore/./src/routes/_thirdparty/quick-lru/quick-lru.js","webpack://pinafore/./src/routes/_utils/ajax.js","webpack://pinafore/./src/routes/_utils/convertCustomEmojiToEmojiPickerFormat.js","webpack://pinafore/./src/routes/_utils/emojiDatabase.js","webpack://pinafore/./src/routes/_utils/userAgent/isMobile.js"],"names":["filterItemIdsFromTimelines","instanceName","timelineFilter","idFilter","summaryFilter","_","id","forEach","key","timelineData","store","Object","keys","timelineName","summaries","filteredSummaries","filter","isEqual","async","deleteStatusesAndNotifications","statusIdsToDelete","notificationIdsToDelete","idsToDelete","idsToDeleteSet","Set","has","deleteStatusIdsFromStore","deleteNotificationIdsFromStore","doDeleteStatus","statusId","rebloggedIds","getIdsThatRebloggedThisStatus","Array","from","concat","Boolean","statusIds","getNotificationIdsForStatuses","deleteStatus","scheduleIdleTask","updateFollowRequestCountIfLockedAccount","verifyCredentials","loggedInInstances","accessToken","access_token","length","followReqsCount","followRequestCounts","changeTheme","newTheme","instanceThemes","currentInstance","enableGrayscale","switchToInstance","searchResults","queryInSearch","logOutOfInstance","message","formatIntl","instance","composeData","customEmoji","instanceInfos","instanceLists","loggedInInstancesInOrder","splice","indexOf","newInstance","objectsToClear","obj","timelineInitialized","timelinePreinitialized","virtualListStore","clearRealmByPrefix","toast","database","updateVerifyCredentialsForInstance","catch","error","startsWith","logOutOnUnauthorized","thisVerifyCredentials","setStoreVerifyCredentials","updateInstanceInfo","info","syncLists","syncMethod","url","timeout","getLists","lists","updateListsForInstance","setupListsForInstance","getFollowRequests","getInstanceInfo","doSearch","version","query","resolve","limit","excludeUnreviewed","signal","q","exclude_unreviewed","search","doSearchV2","err","status","resp","hashtags","map","tag","name","toLowerCase","history","doSearchV1","getTimeline","timeline","maxId","since","timelineUrlName","Error","getTimelineUrlPath","split","params","since_id","max_id","local","endsWith","only_media","exclude_replies","exclude_types","json","items","headers","item","last_status","getVerifyCredentials","getAccount","accountId","basename","targetIsLocalhost","auth","Authorization","importShowComposeDialog","then","mod","default","CLEANUP_TIME_AGO","CLEANUP_DELAY","emojiPickerDataSource","emojiPickerI18n","emojiPickerLocale","WORD_FILTER_CONTEXT_HOME","WORD_FILTER_CONTEXT_NOTIFICATIONS","WORD_FILTER_CONTEXT_PUBLIC","WORD_FILTER_CONTEXT_THREAD","WORD_FILTER_CONTEXT_ACCOUNT","WORD_FILTER_CONTEXTS","WORD_FILTER_EXPIRY_OPTIONS","value","label","WORD_FILTER_EXPIRY_DEFAULT","getFirstIdFromItemSummaries","itemSummaries","computeForTimeline","defaultValue","compute","currentTimeline","root","REGEX","RegExp","computeForAutosuggest","currentComposeRealm","wordFilterComputations","unexpiredInstanceFilters","fromEntries","entries","filters","context","filtersForThisContext","includes","regex","expr","phrase","replace","whole_word","test","join","createRegexFromFilters","createFilterFunction","showReblogs","showReplies","showFollows","showFavs","showMentions","showPolls","wordFilterContext","filterContexts","type","reblogId","replyId","computeTimelineFilter","computationName","timelinesToSettingsKeys","instanceSettings","settingsKey","computeNotificationFilter","Backoff","onReady","this","attempts","delay","fibonacci","setTimeout","attempt","current","prev","index","next","Math","min","floor","random","WebSocketClient","protocols","options","reconnectEnabled","listeners","backoff","onBackoffReady","bind","connect","open","reconnect","isReconnect","binaryType","ws","WebSocket","onclose","onCloseCallback","onerror","onErrorCallback","onmessage","onMessageCallback","onopen","onOpenCallback","e","apply","arguments","code","onreconnect","readyState","reason","close","data","send","listener","reset","CONNECTING","OPEN","CLOSING","CLOSED","TimelineStream","EventEmitter","streamingApi","super","_streamingApi","_accessToken","_timeline","_onStateChange","_onOnline","_onOffline","_onForcedOnlineStateChange","_setupWebSocket","_setupEvents","_closed","_closeWebSocket","_teardownEvents","event","removeAllListeners","_ws","emit","stream","getStreamName","slice","list","getStreamUrl","_opened","safeParse","lifecycle","eventBus","window","addEventListener","removeEventListener","newState","_pause","oldState","_unpause","_tryToReconnect","online","KNOWN_EVENTS","createStream","api","firstStatusId","firstNotificationId","fillGap","timelineItemId","firstTimelineItemId","newTimelineItems","numRequests","fillStreamingGap","on","payload","JSON","parse","d","addStatusOrNotification","s","console","warn","processMessage","newFirstStatusId","newFirstNotificationId","currentInstanceStream","refreshInstanceDataAndStream","currentInstanceChanged","Promise","all","refreshInstanceData","currentInstanceInfo","get","urls","streaming_api","getFirstTimelineItemId","doRefreshInstanceDataAndStream","timelineObservers","currentTimelineStream","newCurrentInstance","newCurrentTimeline","currentTimelineIsUnchanged","currentFaviconHasNotifications","notificationObservers","hasNotifications","fn","href","faviconId","oldLink","document","getElementById","getAttribute","link","createElement","rel","head","removeChild","appendChild","setFavicon","pageVisibilityHidden","isMobile","requestAnimationFrame","cache","Map","isSupported","ctx","getContext","_a","CANVAS_WIDTH","textSize","CANVAS_HEIGHT","font","textBaseline","canvas","width","height","unicode","clearRect","fillStyle","fillText","a","getImageData","count","i","x","y","b","measureText","setCacheHandler","maxSize","testEmojiSupported","supported","set","doEmojiSearch","searchText","canceled","results","emojis","emojiDatabase","shortcode","substring","shortcodes","emoji","push","searchEmoji","autosuggestType","autosuggestSelected","autosuggestSearchResults","cancel","promiseThrottler","_timeout","_promise","res","RequestThrottler","fetcher","_canceled","_controller","AbortController","_fetcher","abort","byUsername","usernameA","acct","usernameB","byAccountId","doAccountSearch","localResults","remoteResults","requestThrottler","accounts","onNewResults","sort","topRemoteResults","uniqBy","mergeAndTruncateResults","onError","searchAccountsLocally","request","searchAccountsRemotely","getUses","historyItem","uses","byUsesThenName","aCount","bCount","autosuggestObservers","lastSearch","composeFocused","autosuggestSelecting","autosuggestSearchText","doHashtagSearch","theScrollbarStyle","doCleanup","now","Date","changeCount","instanceComposeData","values","realm","timelineComposeData","ts","doCleanupLazily","showComposeDialogObservers","observedOnce","currentPage","URLSearchParams","location","isUserLoggedIn","importShowComposeDialogPromise","title","text","file","composeText","showComposeDialog","isChromePre87","isChrome","cookieStore","setStatusModification","statusModifications","favorites","reblogs","pins","bookmarks","getStatusModifications","Store","prototype","setComposeData","instanceNameData","assign","getComposeData","clearComposeData","setForTimeline","valuesToSet","rootKey","getForTimeline","getAllTimelineData","setForCurrentTimeline","getThreads","instanceData","clearTimelineDataForInstance","changes","timelineMixins","setStatusFavorited","favorited","setStatusReblogged","reblogged","setStatusPinned","pinned","setStatusBookmarked","bookmarked","statusMixins","setForAutosuggest","setForCurrentAutosuggest","getForCurrentAutosuggest","clearAutosuggestDataForInstance","autosuggestMixins","len","timelineItemSummaries","timelineComputations","home","notifications","timelineFilterFunction","timelineItemSummariesToAdd","timelineNotificationItemSummaries","timelineNotificationFilterFunction","timelineFilterComputations","filteredTimelineNotificationItemSummaries","disableNotificationBadge","numberOfNotifications","numberOfFollowRequests","badgeComputations","currentComposeData","currentComposeText","composeSelectionStart","selectionStart","match","autosuggestNumSearchResults","autosuggestComputations","updateUnexpiredInstanceFiltersIfUnchanged","instanceFilters","expires_at","getTime","timelineData_timelineItemSummaries","timelineData_timelineItemSummariesToAdd","somethingChanged","unexpiredInstanceFilterRegexes","contextsToRegex","timelinesToSummaries","timelinesToSummariesToAdd","summariesToUpdate","flat","isNotification","summary","newFilterContexts","computeFilterContextsForStatusOrNotification","init","wordFilterObservers","navigator","permissions","permission","notificationPermission","state","onchange","target","disableCustomScrollbars","setAttribute","setEmoji","currentEmoji","autoplayGifs","customEmojiInEmojiPickerFormat","convertCustomEmojiToEmojiPickerFormat","currentCustomEmoji","customEmojiObservers","badgeNumber","setAppBadge","clearAppBadge","scheduleInterval","QuickLRU","TypeError","oldCache","_size","listenerCount","delete","_set","deleted","clear","add","DEFAULT_TIMEOUT","MEDIA_WRITE_TIMEOUT","WRITE_TIMEOUT","makeFetchOptions","method","Accept","_fetch","fetchOptions","response","reject","fetch","fetchWithTimeout","throwErrorIfInvalidResponse","_putOrPostOrPatch","body","FormData","stringify","put","post","getWithHeaders","del","paramsString","paramsObject","isArray","encodeURIComponent","visible_in_picker","static_url","category","applySkinToneToEmoji","skinTone","skins","tone","find","locale","dataSource","setCustomEmoji","findByUnicodeOrName","unicodeOrName","getEmojiByUnicodeOrName","getPreferredSkinTone","findBySearchQuery","getEmojiBySearchQuery","userAgent"],"mappings":"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","file":"4137.83ba56a14a3651074311.4137.js","sourcesContent":["import { getIdsThatRebloggedThisStatus, getNotificationIdsForStatuses } from './statuses'\nimport { store } from '../_store/store'\nimport isEqual from 'lodash-es/isEqual'\nimport { database } from '../_database/database'\nimport { scheduleIdleTask } from '../_utils/scheduleIdleTask'\n\nfunction filterItemIdsFromTimelines (instanceName, timelineFilter, idFilter) {\n  const keys = ['timelineItemSummaries', 'timelineItemSummariesToAdd']\n  const summaryFilter = _ => idFilter(_.id)\n\n  keys.forEach(key => {\n    const timelineData = store.getAllTimelineData(instanceName, key)\n    Object.keys(timelineData).forEach(timelineName => {\n      const summaries = timelineData[timelineName]\n      if (!timelineFilter(timelineName)) {\n        return\n      }\n      const filteredSummaries = summaries.filter(summaryFilter)\n      if (!isEqual(summaries, filteredSummaries)) {\n        console.log('deleting an item from timelineName', timelineName, 'for key', key)\n        store.setForTimeline(instanceName, timelineName, {\n          [key]: filteredSummaries\n        })\n      }\n    })\n  })\n}\n\nfunction deleteStatusIdsFromStore (instanceName, idsToDelete) {\n  const idsToDeleteSet = new Set(idsToDelete)\n  const idWasNotDeleted = id => !idsToDeleteSet.has(id)\n  const notNotificationTimeline = timelineName => timelineName !== 'notifications'\n\n  filterItemIdsFromTimelines(instanceName, notNotificationTimeline, idWasNotDeleted)\n}\n\nfunction deleteNotificationIdsFromStore (instanceName, idsToDelete) {\n  const idsToDeleteSet = new Set(idsToDelete)\n  const idWasNotDeleted = id => !idsToDeleteSet.has(id)\n  const isNotificationTimeline = timelineName => timelineName === 'notifications'\n\n  filterItemIdsFromTimelines(instanceName, isNotificationTimeline, idWasNotDeleted)\n}\n\nasync function deleteStatusesAndNotifications (instanceName, statusIdsToDelete, notificationIdsToDelete) {\n  deleteStatusIdsFromStore(instanceName, statusIdsToDelete)\n  deleteNotificationIdsFromStore(instanceName, notificationIdsToDelete)\n  await database.deleteStatusesAndNotifications(instanceName, statusIdsToDelete, notificationIdsToDelete)\n}\n\nasync function doDeleteStatus (instanceName, statusId) {\n  console.log('deleting statusId', statusId)\n  const rebloggedIds = await getIdsThatRebloggedThisStatus(instanceName, statusId)\n  const statusIdsToDelete = Array.from(new Set([statusId].concat(rebloggedIds).filter(Boolean)))\n  const notificationIdsToDelete = Array.from(new Set(await getNotificationIdsForStatuses(instanceName, statusIdsToDelete)))\n  await deleteStatusesAndNotifications(instanceName, statusIdsToDelete, notificationIdsToDelete)\n}\n\nexport function deleteStatus (instanceName, statusId) {\n  scheduleIdleTask(() => {\n    /* no await */ doDeleteStatus(instanceName, statusId)\n  })\n}\n","import { database } from '../_database/database'\n\nexport async function getIdThatThisStatusReblogged (instanceName, statusId) {\n  const status = await database.getStatus(instanceName, statusId)\n  return status.reblog && status.reblog.id\n}\n\nexport async function getIdsThatTheseStatusesReblogged (instanceName, statusIds) {\n  const reblogIds = await Promise.all(statusIds.map(async statusId => {\n    return getIdThatThisStatusReblogged(instanceName, statusId)\n  }))\n  return reblogIds.filter(Boolean)\n}\n\nexport async function getIdsThatRebloggedThisStatus (instanceName, statusId) {\n  return database.getReblogsForStatus(instanceName, statusId)\n}\n\nexport async function getNotificationIdsForStatuses (instanceName, statusIds) {\n  return database.getNotificationIdsForStatuses(instanceName, statusIds)\n}\n","import { store } from '../_store/store'\nimport { cacheFirstUpdateAfter } from '../_utils/sync'\nimport { database } from '../_database/database'\nimport { getFollowRequests } from '../_api/followRequests'\nimport { get } from '../_utils/lodash-lite'\n\nexport async function updateFollowRequestCountIfLockedAccount (instanceName) {\n  const { verifyCredentials, loggedInInstances } = store.get()\n\n  if (!get(verifyCredentials, [instanceName, 'locked'])) {\n    return\n  }\n\n  const accessToken = loggedInInstances[instanceName].access_token\n\n  await cacheFirstUpdateAfter(\n    async () => (await getFollowRequests(instanceName, accessToken)).length,\n    () => database.getFollowRequestCount(instanceName),\n    followReqsCount => database.setFollowRequestCount(instanceName, followReqsCount),\n    followReqsCount => {\n      const { followRequestCounts } = store.get()\n      followRequestCounts[instanceName] = followReqsCount\n      store.set({ followRequestCounts })\n    }\n  )\n}\n","import { getVerifyCredentials } from '../_api/user'\nimport { store } from '../_store/store'\nimport { switchToTheme } from '../_utils/themeEngine'\nimport { toast } from '../_components/toast/toast'\nimport { goto } from '../../../__sapper__/client'\nimport { cacheFirstUpdateAfter } from '../_utils/sync'\nimport { getInstanceInfo } from '../_api/instance'\nimport { database } from '../_database/database'\nimport { importVirtualListStore } from '../_utils/asyncModules/importVirtualListStore.js'\nimport { formatIntl } from '../_utils/formatIntl'\n\nexport function changeTheme (instanceName, newTheme) {\n  const { instanceThemes } = store.get()\n  instanceThemes[instanceName] = newTheme\n  store.set({ instanceThemes: instanceThemes })\n  store.save()\n  const { currentInstance } = store.get()\n  if (instanceName === currentInstance) {\n    const { enableGrayscale } = store.get()\n    switchToTheme(newTheme, enableGrayscale)\n  }\n}\n\nexport function switchToInstance (instanceName) {\n  const { instanceThemes } = store.get()\n  store.set({\n    currentInstance: instanceName,\n    searchResults: null,\n    queryInSearch: ''\n  })\n  store.save()\n  const { enableGrayscale } = store.get()\n  switchToTheme(instanceThemes[instanceName], enableGrayscale)\n}\n\nexport async function logOutOfInstance (instanceName, message) {\n  message = message || formatIntl([\"Logged out of \",[\"instance\"]], { instance: instanceName })\n  const {\n    composeData,\n    currentInstance,\n    customEmoji,\n    instanceInfos,\n    instanceLists,\n    instanceThemes,\n    loggedInInstances,\n    loggedInInstancesInOrder,\n    verifyCredentials\n  } = store.get()\n  loggedInInstancesInOrder.splice(loggedInInstancesInOrder.indexOf(instanceName), 1)\n  const newInstance = instanceName === currentInstance ? loggedInInstancesInOrder[0] : currentInstance\n  const objectsToClear = [\n    composeData,\n    customEmoji,\n    instanceInfos,\n    instanceLists,\n    instanceThemes,\n    loggedInInstances,\n    verifyCredentials\n  ]\n  for (const obj of objectsToClear) {\n    delete obj[instanceName]\n  }\n  store.set({\n    composeData,\n    currentInstance: newInstance,\n    customEmoji,\n    instanceInfos,\n    instanceLists,\n    instanceThemes,\n    loggedInInstances,\n    loggedInInstancesInOrder,\n    queryInSearch: '',\n    searchResults: null,\n    timelineInitialized: false,\n    timelinePreinitialized: false,\n    verifyCredentials\n  })\n  store.clearTimelineDataForInstance(instanceName)\n  store.clearAutosuggestDataForInstance(instanceName)\n  store.save()\n  const { virtualListStore } = await importVirtualListStore()\n  virtualListStore.clearRealmByPrefix(currentInstance + '/') // TODO: this is a hacky way to clear the vlist cache\n  toast.say(message)\n  const { enableGrayscale } = store.get()\n  switchToTheme(instanceThemes[newInstance], enableGrayscale)\n  /* no await */ database.clearDatabaseForInstance(instanceName)\n  goto('/settings/instances')\n}\n\nfunction setStoreVerifyCredentials (instanceName, thisVerifyCredentials) {\n  const { verifyCredentials } = store.get()\n  verifyCredentials[instanceName] = thisVerifyCredentials\n  store.set({ verifyCredentials: verifyCredentials })\n}\n\nexport async function updateVerifyCredentialsForInstance (instanceName) {\n  const { loggedInInstances } = store.get()\n  const accessToken = loggedInInstances[instanceName].access_token\n  await cacheFirstUpdateAfter(\n    () => getVerifyCredentials(instanceName, accessToken).catch(logOutOnUnauthorized(instanceName)),\n    () => database.getInstanceVerifyCredentials(instanceName),\n    verifyCredentials => database.setInstanceVerifyCredentials(instanceName, verifyCredentials),\n    verifyCredentials => setStoreVerifyCredentials(instanceName, verifyCredentials)\n  )\n}\n\nexport async function updateVerifyCredentialsForCurrentInstance () {\n  const { currentInstance } = store.get()\n  await updateVerifyCredentialsForInstance(currentInstance)\n}\n\nexport async function updateInstanceInfo (instanceName) {\n  await cacheFirstUpdateAfter(\n    () => getInstanceInfo(instanceName),\n    () => database.getInstanceInfo(instanceName),\n    info => database.setInstanceInfo(instanceName, info),\n    info => {\n      const { instanceInfos } = store.get()\n      instanceInfos[instanceName] = info\n      store.set({ instanceInfos: instanceInfos })\n    }\n  )\n}\n\nexport function logOutOnUnauthorized (instanceName) {\n  return async error => {\n    if (error.message.startsWith('401:')) {\n      await logOutOfInstance(instanceName, formatIntl([\"The access token was revoked, logged out of \",[\"instance\"]], { instance: instanceName }))\n    }\n\n    throw error\n  }\n}\n","export const importVirtualListStore = () => import(\n  '../../_components/virtualList/virtualListStore.js'\n)\n","import { store } from '../_store/store'\nimport { getLists } from '../_api/lists'\nimport { cacheFirstUpdateAfter, cacheFirstUpdateOnlyIfNotInCache } from '../_utils/sync'\nimport { database } from '../_database/database'\n\nasync function syncLists (instanceName, syncMethod) {\n  const { loggedInInstances } = store.get()\n  const accessToken = loggedInInstances[instanceName].access_token\n\n  await syncMethod(\n    () => getLists(instanceName, accessToken),\n    () => database.getLists(instanceName),\n    lists => database.setLists(instanceName, lists),\n    lists => {\n      const { instanceLists } = store.get()\n      instanceLists[instanceName] = lists\n      store.set({ instanceLists: instanceLists })\n    }\n  )\n}\n\nexport async function updateListsForInstance (instanceName) {\n  await syncLists(instanceName, cacheFirstUpdateAfter)\n}\n\nexport async function setupListsForInstance (instanceName) {\n  await syncLists(instanceName, cacheFirstUpdateOnlyIfNotInCache)\n}\n","import { get, DEFAULT_TIMEOUT, post, WRITE_TIMEOUT } from '../_utils/ajax'\nimport { auth, basename } from './utils'\n\nexport function getLists (instanceName, accessToken) {\n  const url = `${basename(instanceName)}/api/v1/lists`\n  return get(url, auth(accessToken), { timeout: DEFAULT_TIMEOUT })\n}\n\nexport function createList (instanceName, accessToken, title) {\n  const url = `${basename(instanceName)}/api/v1/lists`\n  return post(url, { title }, auth(accessToken), { timeout: WRITE_TIMEOUT })\n}\n","import { DEFAULT_TIMEOUT, get, post, WRITE_TIMEOUT } from '../_utils/ajax'\nimport { auth, basename } from './utils'\n\nexport async function getFollowRequests (instanceName, accessToken) {\n  const url = `${basename(instanceName)}/api/v1/follow_requests`\n  return get(url, auth(accessToken), { timeout: DEFAULT_TIMEOUT })\n}\n\nexport async function authorizeFollowRequest (instanceName, accessToken, id) {\n  const url = `${basename(instanceName)}/api/v1/follow_requests/${id}/authorize`\n  return post(url, null, auth(accessToken), { timeout: WRITE_TIMEOUT })\n}\n\nexport async function rejectFollowRequest (instanceName, accessToken, id) {\n  const url = `${basename(instanceName)}/api/v1/follow_requests/${id}/reject`\n  return post(url, null, auth(accessToken), { timeout: WRITE_TIMEOUT })\n}\n","import { get, DEFAULT_TIMEOUT } from '../_utils/ajax'\nimport { basename } from './utils'\n\nexport function getInstanceInfo (instanceName) {\n  const url = `${basename(instanceName)}/api/v1/instance`\n  return get(url, null, { timeout: DEFAULT_TIMEOUT })\n}\n","import { get, paramsString, DEFAULT_TIMEOUT } from '../_utils/ajax'\nimport { auth, basename } from './utils'\n\nfunction doSearch (version, instanceName, accessToken, query, resolve, limit, excludeUnreviewed, signal) {\n  const url = `${basename(instanceName)}/api/${version}/search?` + paramsString({\n    q: query,\n    resolve,\n    limit,\n    exclude_unreviewed: !!excludeUnreviewed\n  })\n  return get(url, auth(accessToken), {\n    timeout: DEFAULT_TIMEOUT,\n    signal\n  })\n}\n\nasync function doSearchV1 (instanceName, accessToken, query, resolve, limit, excludeUnreviewed, signal) {\n  const resp = await doSearch('v1', instanceName, accessToken, query, resolve, limit, excludeUnreviewed, signal)\n  resp.hashtags = resp.hashtags && resp.hashtags.map(tag => ({\n    name: tag,\n    url: `${basename(instanceName)}/tags/${tag.toLowerCase()}`,\n    history: []\n  }))\n  return resp\n}\n\nasync function doSearchV2 (instanceName, accessToken, query, resolve, limit, excludeUnreviewed, signal) {\n  return doSearch('v2', instanceName, accessToken, query, resolve, limit, excludeUnreviewed, signal)\n}\n\nexport async function search (instanceName, accessToken, query, resolve = true, limit = 5,\n  excludeUnreviewed = false, signal = null) {\n  try {\n    return (await doSearchV2(instanceName, accessToken, query, resolve, limit, excludeUnreviewed, signal))\n  } catch (err) {\n    if (err && err.status === 404) { // fall back to old search API\n      return doSearchV1(instanceName, accessToken, query, resolve, limit, excludeUnreviewed, signal)\n    } else {\n      throw err\n    }\n  }\n}\n","import { getWithHeaders, paramsString, DEFAULT_TIMEOUT } from '../_utils/ajax'\nimport { auth, basename } from './utils'\n\nfunction getTimelineUrlPath (timeline) {\n  switch (timeline) {\n    case 'local':\n    case 'federated':\n      return 'timelines/public'\n    case 'home':\n      return 'timelines/home'\n    case 'notifications':\n    case 'notifications/mentions':\n      return 'notifications'\n    case 'favorites':\n      return 'favourites'\n    case 'direct':\n      return 'conversations'\n    case 'bookmarks':\n      return 'bookmarks'\n  }\n  if (timeline.startsWith('tag/')) {\n    return 'timelines/tag'\n  } else if (timeline.startsWith('account/')) {\n    return 'accounts'\n  } else if (timeline.startsWith('list/')) {\n    return 'timelines/list'\n  }\n  throw new Error(`Invalid timeline type: ${timeline}`)\n}\n\nexport async function getTimeline (instanceName, accessToken, timeline, maxId, since, limit) {\n  const timelineUrlName = getTimelineUrlPath(timeline)\n  let url = `${basename(instanceName)}/api/v1/${timelineUrlName}`\n\n  if (timeline.startsWith('tag/')) {\n    url += '/' + timeline.split('/')[1]\n  } else if (timeline.startsWith('account/')) {\n    url += '/' + timeline.split('/')[1] + '/statuses'\n  } else if (timeline.startsWith('list/')) {\n    url += '/' + timeline.split('/')[1]\n  }\n\n  const params = {}\n  if (since) {\n    params.since_id = since\n  }\n\n  if (maxId) {\n    params.max_id = maxId\n  }\n\n  if (limit) {\n    params.limit = limit\n  }\n\n  if (timeline === 'local') {\n    params.local = true\n  }\n\n  if (timeline.startsWith('account/')) {\n    if (timeline.endsWith('media')) {\n      params.only_media = true\n    } else {\n      params.exclude_replies = !timeline.endsWith('/with_replies')\n    }\n  }\n\n  if (timeline === 'notifications/mentions') {\n    params.exclude_types = ['follow', 'favourite', 'reblog', 'poll']\n  }\n\n  url += '?' + paramsString(params)\n\n  console.log('fetching url', url)\n  let { json: items, headers } = await getWithHeaders(url, auth(accessToken), { timeout: DEFAULT_TIMEOUT })\n\n  if (timeline === 'direct') {\n    items = items.map(item => item.last_status)\n  }\n  return { items, headers }\n}\n","import { get, DEFAULT_TIMEOUT } from '../_utils/ajax'\nimport { auth, basename } from './utils'\n\nexport function getVerifyCredentials (instanceName, accessToken) {\n  const url = `${basename(instanceName)}/api/v1/accounts/verify_credentials`\n  return get(url, auth(accessToken), { timeout: DEFAULT_TIMEOUT })\n}\n\nexport function getAccount (instanceName, accessToken, accountId) {\n  const url = `${basename(instanceName)}/api/v1/accounts/${accountId}`\n  return get(url, auth(accessToken), { timeout: DEFAULT_TIMEOUT })\n}\n","function targetIsLocalhost (instanceName) {\n  return instanceName.startsWith('localhost:') || instanceName.startsWith('127.0.0.1:')\n}\n\nexport function basename (instanceName) {\n  if (targetIsLocalhost(instanceName)) {\n    return `http://${instanceName}`\n  }\n  return `https://${instanceName}`\n}\n\nexport function auth (accessToken) {\n  return {\n    Authorization: `Bearer ${accessToken}`\n  }\n}\n","export const importShowComposeDialog = () => import(\n  '../creators/showComposeDialog'\n).then(mod => mod.default)\n","export const CLEANUP_TIME_AGO = 5 * 24 * 60 * 60 * 1000 // five days ago\nexport const CLEANUP_DELAY = 5 * 60 * 1000 // five minutes\n","import { LOCALE } from './intl'\n\nexport const emojiPickerDataSource = `/emoji-${LOCALE}.json`\n\n// this should be undefined for English; it's already bundled with emoji-picker-element\nexport const emojiPickerI18n = process.env.EMOJI_PICKER_I18N\n\n// To avoid creating a new IDB database named emoji-picker-en-US, just\n// reuse the existing default \"en\" one (otherwise people will end up with\n// a stale database taking up useless space)\nexport const emojiPickerLocale = LOCALE === 'en-US' ? 'en' : LOCALE\n","export const WORD_FILTER_CONTEXT_HOME = 'home'\nexport const WORD_FILTER_CONTEXT_NOTIFICATIONS = 'notifications'\nexport const WORD_FILTER_CONTEXT_PUBLIC = 'public'\nexport const WORD_FILTER_CONTEXT_THREAD = 'thread'\nexport const WORD_FILTER_CONTEXT_ACCOUNT = 'account'\n\nexport const WORD_FILTER_CONTEXTS = [\n  WORD_FILTER_CONTEXT_HOME,\n  WORD_FILTER_CONTEXT_NOTIFICATIONS,\n  WORD_FILTER_CONTEXT_PUBLIC,\n  WORD_FILTER_CONTEXT_THREAD,\n  WORD_FILTER_CONTEXT_ACCOUNT\n]\n\n// Someday we can maybe replace this with Intl.DurationFormat\n// https://github.com/tc39/proposal-intl-duration-format\nexport const WORD_FILTER_EXPIRY_OPTIONS = [\n  {\n    value: 0,\n    label: \"Never\"\n  },\n  {\n    value: 1800,\n    label: \"30 minutes\"\n  },\n  {\n    value: 3600,\n    label: \"1 hour\"\n  },\n  {\n    value: 21600,\n    label: \"6 hours\"\n  },\n  {\n    value: 43200,\n    label: \"12 hours\"\n  },\n  {\n    value: 86400,\n    label: \"1 day\"\n  },\n  {\n    value: 604800,\n    label: \"7 days\"\n  }\n]\n\nexport const WORD_FILTER_EXPIRY_DEFAULT = 0\n","export function getFirstIdFromItemSummaries (itemSummaries) {\n  return itemSummaries &&\n    itemSummaries[0] &&\n    itemSummaries[0].id\n}\n\nexport function getLastIdFromItemSummaries (itemSummaries) {\n  return itemSummaries &&\n    itemSummaries[itemSummaries.length - 1] &&\n    itemSummaries[itemSummaries.length - 1].id\n}\n","import { get } from '../../_utils/lodash-lite'\nimport { getFirstIdFromItemSummaries, getLastIdFromItemSummaries } from '../../_utils/getIdFromItemSummaries'\nimport { mark, stop } from '../../_utils/marks'\n\nfunction computeForTimeline (store, key, defaultValue) {\n  store.compute(key,\n    ['currentInstance', 'currentTimeline', `timelineData_${key}`],\n    (currentInstance, currentTimeline, root) => (\n      get(root, [currentInstance, currentTimeline], defaultValue)\n    )\n  )\n}\n\nexport function timelineComputations (store) {\n  mark('timelineComputations')\n  computeForTimeline(store, 'timelineItemSummaries', null)\n  computeForTimeline(store, 'timelineItemSummariesToAdd', null)\n  computeForTimeline(store, 'runningUpdate', false)\n  computeForTimeline(store, 'lastFocusedElementId', null)\n  computeForTimeline(store, 'ignoreBlurEvents', false)\n  computeForTimeline(store, 'showHeader', false)\n  computeForTimeline(store, 'shouldShowHeader', false)\n  computeForTimeline(store, 'timelineItemSummariesAreStale', false)\n  computeForTimeline(store, 'timelineNextPageId', null)\n\n  store.compute('currentTimelineType', ['currentTimeline'], currentTimeline => (\n    currentTimeline && currentTimeline.split('/')[0])\n  )\n  store.compute('currentTimelineValue', ['currentTimeline'], currentTimeline => {\n    if (!currentTimeline) {\n      return undefined\n    }\n    const split = currentTimeline.split('/')\n    const len = split.length\n    if (split[len - 1] === 'with_replies' || split[len - 1] === 'media') {\n      return split[len - 2]\n    }\n    return split[len - 1]\n  })\n  store.compute('firstTimelineItemId', ['timelineItemSummaries'], (timelineItemSummaries) => (\n    getFirstIdFromItemSummaries(timelineItemSummaries)\n  ))\n  store.compute('lastTimelineItemId', ['timelineItemSummaries'], (timelineItemSummaries) => (\n    getLastIdFromItemSummaries(timelineItemSummaries)\n  ))\n  stop('timelineComputations')\n}\n","import { get } from '../../_utils/lodash-lite'\nimport { mark, stop } from '../../_utils/marks'\n\nconst MIN_PREFIX_LENGTH = 2\n// Technically mastodon accounts allow dots, but it would be weird to do an autosuggest search if it ends with a dot.\n// Also this is rare. https://github.com/tootsuite/mastodon/pull/6844\n// However for emoji search we allow some extra things (e.g. :+1:, :white_heart:)\nconst VALID_CHARS = '[\\\\w\\\\+_\\\\-:]'\nconst PREFIXES = '(?:@|:|#)'\nconst REGEX = new RegExp(`(?:\\\\s|^)(${PREFIXES}${VALID_CHARS}{${MIN_PREFIX_LENGTH},})$`)\n\nfunction computeForAutosuggest (store, key, defaultValue) {\n  store.compute(key,\n    ['currentInstance', 'currentComposeRealm', `autosuggestData_${key}`],\n    (currentInstance, currentComposeRealm, root) => (\n      get(root, [currentInstance, currentComposeRealm], defaultValue)\n    )\n  )\n}\n\nexport function autosuggestComputations (store) {\n  mark('autosuggestComputations')\n  computeForAutosuggest(store, 'composeFocused', false)\n  computeForAutosuggest(store, 'composeSelectionStart', 0)\n  computeForAutosuggest(store, 'autosuggestSelected', 0)\n  computeForAutosuggest(store, 'autosuggestSearchResults', [])\n  computeForAutosuggest(store, 'autosuggestType', null)\n\n  store.compute(\n    'currentComposeText',\n    ['currentComposeData', 'currentComposeRealm'],\n    (currentComposeData, currentComposeRealm) => (\n      get(currentComposeData, [currentComposeRealm, 'text'], '')\n    )\n  )\n\n  store.compute(\n    'autosuggestSearchText',\n    ['currentComposeText', 'composeSelectionStart'],\n    (currentComposeText, composeSelectionStart) => {\n      const selectionStart = composeSelectionStart\n      if (!currentComposeText || selectionStart < MIN_PREFIX_LENGTH) {\n        return ''\n      }\n\n      const textUpToCursor = currentComposeText.substring(0, selectionStart)\n      const match = textUpToCursor.match(REGEX)\n      return (match && match[1]) || ''\n    }\n  )\n\n  store.compute(\n    'autosuggestNumSearchResults',\n    ['autosuggestSearchResults'],\n    (autosuggestSearchResults) => autosuggestSearchResults.length\n  )\n\n  store.compute(\n    'autosuggestShown',\n    ['composeFocused', 'autosuggestSearchText', 'autosuggestNumSearchResults'],\n    (composeFocused, autosuggestSearchText, autosuggestNumSearchResults) => (\n      !!(composeFocused && autosuggestSearchText && autosuggestNumSearchResults)\n    )\n  )\n  stop('autosuggestComputations')\n}\n","import { createRegexFromFilters } from '../../_utils/createRegexFromFilters'\nimport { WORD_FILTER_CONTEXTS } from '../../_static/wordFilters'\n\nexport function wordFilterComputations (store) {\n  // unexpiredInstanceFilters is calculated based on `now` and `instanceFilters`,\n  // but it's computed with observers rather than compute() to avoid excessive recalcs\n  store.compute(\n    'currentFilters',\n    ['unexpiredInstanceFilters', 'currentInstance'],\n    (unexpiredInstanceFilters, currentInstance) => unexpiredInstanceFilters[currentInstance] || []\n  )\n\n  store.compute('unexpiredInstanceFilterRegexes', ['unexpiredInstanceFilters'], unexpiredInstanceFilters => {\n    return Object.fromEntries(Object.entries(unexpiredInstanceFilters).map(([instanceName, filters]) => {\n      const contextsToRegex = Object.fromEntries(WORD_FILTER_CONTEXTS.map(context => {\n        const filtersForThisContext = filters.filter(_ => _.context.includes(context))\n        if (!filtersForThisContext.length) {\n          return undefined // don't bother even adding it to the map\n        }\n        const regex = createRegexFromFilters(filtersForThisContext)\n        return [context, regex]\n      }).filter(Boolean))\n      return [instanceName, contextsToRegex]\n    }))\n  })\n}\n","// copy-pasta'd from mastodon\n// https://github.com/tootsuite/mastodon/blob/2ff01f7/app/javascript/mastodon/selectors/index.js#L40-L63\nconst escapeRegExp = string =>\n  string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&') // $& means the whole matched string\n\nexport const createRegexFromFilters = filters => {\n  return new RegExp(filters.map(filter => {\n    let expr = escapeRegExp(filter.phrase)\n\n    if (filter.whole_word) {\n      if (/^[\\w]/.test(expr)) {\n        expr = `\\\\b${expr}`\n      }\n\n      if (/[\\w]$/.test(expr)) {\n        expr = `${expr}\\\\b`\n      }\n    }\n\n    return expr\n  }).join('|'), 'i')\n}\n","// create a function for filtering timeline item summaries\n\nexport const createFilterFunction = (\n  showReblogs, showReplies, showFollows, showFavs, showMentions, showPolls, wordFilterContext\n) => {\n  return item => {\n    if (item.filterContexts && item.filterContexts.includes(wordFilterContext)) {\n      return false\n    }\n\n    switch (item.type) {\n      case 'poll':\n        return showPolls\n      case 'favourite':\n        return showFavs\n      case 'reblog':\n        return showReblogs\n      case 'mention':\n        return showMentions\n      case 'follow':\n        return showFollows\n    }\n    if (item.reblogId) {\n      return showReblogs\n    } else if (item.replyId) {\n      return showReplies\n    } else {\n      return true\n    }\n  }\n}\n","import {\n  HOME_REBLOGS,\n  HOME_REPLIES,\n  NOTIFICATION_FAVORITES,\n  NOTIFICATION_FOLLOWS, NOTIFICATION_MENTIONS, NOTIFICATION_POLLS,\n  NOTIFICATION_REBLOGS\n} from '../../_static/instanceSettings'\nimport {\n  WORD_FILTER_CONTEXT_ACCOUNT,\n  WORD_FILTER_CONTEXT_HOME,\n  WORD_FILTER_CONTEXT_NOTIFICATIONS,\n  WORD_FILTER_CONTEXT_PUBLIC, WORD_FILTER_CONTEXT_THREAD\n} from '../../_static/wordFilters'\nimport { createFilterFunction } from '../../_utils/createFilterFunction'\nimport { get } from '../../_utils/lodash-lite'\n\n// Compute just the boolean, e.g. 'showPolls', so that we can use that boolean as\n// the input to the timelineFilterFunction computations. This should reduce the need to\n// re-compute the timelineFilterFunction over and over.\nfunction computeTimelineFilter (store, computationName, timelinesToSettingsKeys) {\n  store.compute(\n    computationName,\n    ['currentInstance', 'instanceSettings', 'currentTimeline'],\n    (currentInstance, instanceSettings, currentTimeline) => {\n      const settingsKey = timelinesToSettingsKeys[currentTimeline]\n      return settingsKey ? get(instanceSettings, [currentInstance, settingsKey], true) : true\n    }\n  )\n}\n\n// Ditto for notifications, which we always have to keep track of due to the notification count.\nfunction computeNotificationFilter (store, computationName, key) {\n  store.compute(\n    computationName,\n    ['currentInstance', 'instanceSettings'],\n    (currentInstance, instanceSettings) => {\n      return get(instanceSettings, [currentInstance, key], true)\n    }\n  )\n}\n\nexport function timelineFilterComputations (store) {\n  computeTimelineFilter(store, 'timelineShowReblogs', { home: HOME_REBLOGS, notifications: NOTIFICATION_REBLOGS })\n  computeTimelineFilter(store, 'timelineShowReplies', { home: HOME_REPLIES })\n  computeTimelineFilter(store, 'timelineShowFollows', { notifications: NOTIFICATION_FOLLOWS })\n  computeTimelineFilter(store, 'timelineShowFavs', { notifications: NOTIFICATION_FAVORITES })\n  computeTimelineFilter(store, 'timelineShowMentions', { notifications: NOTIFICATION_MENTIONS })\n  computeTimelineFilter(store, 'timelineShowPolls', { notifications: NOTIFICATION_POLLS })\n\n  computeNotificationFilter(store, 'timelineNotificationShowReblogs', NOTIFICATION_REBLOGS)\n  computeNotificationFilter(store, 'timelineNotificationShowFollows', NOTIFICATION_FOLLOWS)\n  computeNotificationFilter(store, 'timelineNotificationShowFavs', NOTIFICATION_FAVORITES)\n  computeNotificationFilter(store, 'timelineNotificationShowMentions', NOTIFICATION_MENTIONS)\n  computeNotificationFilter(store, 'timelineNotificationShowPolls', NOTIFICATION_POLLS)\n\n  store.compute(\n    'timelineWordFilterContext',\n    ['currentTimeline'],\n    (currentTimeline) => {\n      if (!currentTimeline) {\n        return\n      }\n      if (currentTimeline === 'home' || currentTimeline.startsWith('list/')) {\n        return WORD_FILTER_CONTEXT_HOME\n      }\n      if (currentTimeline === 'notifications' || currentTimeline.startsWith('notifications/')) {\n        return WORD_FILTER_CONTEXT_NOTIFICATIONS\n      }\n      if (currentTimeline === 'federated' || currentTimeline === 'local' || currentTimeline.startsWith('tag/')) {\n        return WORD_FILTER_CONTEXT_PUBLIC\n      }\n      if (currentTimeline.startsWith('account/')) {\n        return WORD_FILTER_CONTEXT_ACCOUNT\n      }\n      if (currentTimeline.startsWith('status/')) {\n        return WORD_FILTER_CONTEXT_THREAD\n      }\n      // return undefined otherwise\n    }\n  )\n\n  // This one is based on whatever the current timeline is\n  store.compute(\n    'timelineFilterFunction',\n    [\n      'timelineShowReblogs', 'timelineShowReplies', 'timelineShowFollows',\n      'timelineShowFavs', 'timelineShowMentions', 'timelineShowPolls',\n      'timelineWordFilterContext'\n    ],\n    (showReblogs, showReplies, showFollows, showFavs, showMentions, showPolls, wordFilterContext) => (\n      createFilterFunction(showReblogs, showReplies, showFollows, showFavs, showMentions, showPolls, wordFilterContext)\n    )\n  )\n\n  // The reason there is a completely separate flow just for notifications is that we need to\n  // know which notifications are filtered at all times so that the little number badge is correct.\n  store.compute(\n    'timelineNotificationFilterFunction',\n    [\n      'timelineNotificationShowReblogs', 'timelineNotificationShowFollows',\n      'timelineNotificationShowFavs', 'timelineNotificationShowMentions',\n      'timelineNotificationShowPolls'\n    ],\n    (showReblogs, showFollows, showFavs, showMentions, showPolls) => (\n      createFilterFunction(showReblogs, true, showFollows, showFavs, showMentions, showPolls, WORD_FILTER_CONTEXT_NOTIFICATIONS)\n    )\n  )\n\n  store.compute(\n    'filteredTimelineItemSummaries',\n    ['timelineItemSummaries', 'timelineFilterFunction'],\n    (timelineItemSummaries, timelineFilterFunction) => {\n      return timelineItemSummaries && timelineItemSummaries.filter(timelineFilterFunction)\n    }\n  )\n\n  store.compute(\n    'filteredTimelineItemSummariesToAdd',\n    ['timelineItemSummariesToAdd', 'timelineFilterFunction'],\n    (timelineItemSummariesToAdd, timelineFilterFunction) => {\n      return timelineItemSummariesToAdd && timelineItemSummariesToAdd.filter(timelineFilterFunction)\n    }\n  )\n\n  store.compute('timelineNotificationItemSummaries',\n    ['timelineData_timelineItemSummariesToAdd', 'timelineFilterFunction', 'currentInstance'],\n    (root, timelineFilterFunction, currentInstance) => (\n      get(root, [currentInstance, 'notifications'])\n    )\n  )\n\n  store.compute(\n    'filteredTimelineNotificationItemSummaries',\n    ['timelineNotificationItemSummaries', 'timelineNotificationFilterFunction'],\n    (timelineNotificationItemSummaries, timelineNotificationFilterFunction) => (\n      timelineNotificationItemSummaries && timelineNotificationItemSummaries.filter(timelineNotificationFilterFunction)\n    )\n  )\n}\n","const MAX_DELAY = 60000 // 60 seconds\nconst INITIAL_DELAY = 100\n\nexport class Backoff {\n  constructor (onReady) {\n    this.attempts = 0\n    this.onReady = onReady\n  }\n\n  backoff () {\n    const delay = this.fibonacci(++this.attempts)\n    console.log('websocket delay', delay)\n    setTimeout(this.onReady, delay)\n  }\n\n  fibonacci (attempt) {\n    let current = 1\n\n    if (attempt > current) {\n      let prev = 1\n      current = 2\n\n      for (let index = 2; index < attempt; index++) {\n        const next = prev + current\n        prev = current\n        current = next\n      }\n    }\n\n    return Math.min(MAX_DELAY, Math.floor(Math.random() * current * INITIAL_DELAY))\n  }\n\n  reset () {\n    this.attempts = 0\n  }\n}\n","// forked from https://github.com/gamestdio/websocket/blob/4111bfa/src/index.js\n\nimport { Backoff } from './backoff'\n\nexport class WebSocketClient {\n  /**\n   * @param url DOMString The URL to which to connect; this should be the URL to which the WebSocket server will respond.\n   * @param protocols DOMString|DOMString[] Either a single protocol string or an array of protocol strings. These strings are used to indicate sub-protocols, so that a single server can implement multiple WebSocket sub-protocols (for example, you might want one server to be able to handle different types of interactions depending on the specified protocol). If you don't specify a protocol string, an empty string is assumed.\n   * @param options options\n   */\n  constructor (url, protocols = null, options = {}) {\n    this.url = url\n    this.protocols = protocols\n\n    this.reconnectEnabled = true\n    this.listeners = {}\n\n    this.backoff = new Backoff(this.onBackoffReady.bind(this))\n\n    if (typeof (options.connect) === 'undefined' || options.connect) {\n      this.open()\n    }\n  }\n\n  open (reconnect = false) {\n    this.isReconnect = reconnect\n\n    // keep binaryType used on previous WebSocket connection\n    const binaryType = this.ws && this.ws.binaryType\n\n    this.ws = new WebSocket(this.url, this.protocols)\n    this.ws.onclose = this.onCloseCallback.bind(this)\n    this.ws.onerror = this.onErrorCallback.bind(this)\n    this.ws.onmessage = this.onMessageCallback.bind(this)\n    this.ws.onopen = this.onOpenCallback.bind(this)\n\n    if (binaryType) {\n      this.ws.binaryType = binaryType\n    }\n  }\n\n  /**\n   * @ignore\n   */\n  onBackoffReady () {\n    this.open(true)\n  }\n\n  /**\n   * @ignore\n   */\n  onCloseCallback (e) {\n    if (!this.isReconnect && this.listeners.onclose) {\n      this.listeners.onclose.apply(null, arguments)\n    }\n    if (this.reconnectEnabled && e.code < 3000) {\n      this.backoff.backoff()\n    }\n  }\n\n  /**\n   * @ignore\n   */\n  onErrorCallback () {\n    if (this.listeners.onerror) {\n      this.listeners.onerror.apply(null, arguments)\n    }\n  }\n\n  /**\n   * @ignore\n   */\n  onMessageCallback () {\n    if (this.listeners.onmessage) {\n      this.listeners.onmessage.apply(null, arguments)\n    }\n  }\n\n  /**\n   * @ignore\n   */\n  onOpenCallback () {\n    if (this.listeners.onopen) {\n      this.listeners.onopen.apply(null, arguments)\n    }\n\n    if (this.isReconnect && this.listeners.onreconnect) {\n      this.listeners.onreconnect.apply(null, arguments)\n    }\n\n    this.isReconnect = false\n  }\n\n  // Unused\n  // /**\n  //  * The number of bytes of data that have been queued using calls to send()\n  //  * but not yet transmitted to the network. This value does not reset to zero\n  //  * when the connection is closed; if you keep calling send(), this will\n  //  * continue to climb.\n  //  *\n  //  * @type unsigned long\n  //  * @readonly\n  //  */\n  // get bufferedAmount () { return this.ws.bufferedAmount }\n  //\n  /**\n   * The current state of the connection; this is one of the Ready state constants.\n   * @type unsigned short\n   * @readonly\n   */\n  get readyState () { return this.ws.readyState }\n\n  // Unused\n  //\n  // /**\n  //  * A string indicating the type of binary data being transmitted by the\n  //  * connection. This should be either \"blob\" if DOM Blob objects are being\n  //  * used or \"arraybuffer\" if ArrayBuffer objects are being used.\n  //  * @type DOMString\n  //  */\n  // get binaryType () { return this.ws.binaryType }\n  //\n  // set binaryType (binaryType) { this.ws.binaryType = binaryType }\n  //\n  // /**\n  //  * The extensions selected by the server. This is currently only the empty\n  //  * string or a list of extensions as negotiated by the connection.\n  //  * @type DOMString\n  //  */\n  // get extensions () { return this.ws.extensions }\n  //\n  // set extensions (extensions) { this.ws.extensions = extensions }\n  //\n  // /**\n  //  * A string indicating the name of the sub-protocol the server selected;\n  //  * this will be one of the strings specified in the protocols parameter when\n  //  * creating the WebSocket object.\n  //  * @type DOMString\n  //  */\n  // get protocol () { return this.ws.protocol }\n  //\n  // set protocol (protocol) { this.ws.protocol = protocol }\n\n  /**\n   * Closes the WebSocket connection or connection attempt, if any. If the\n   * connection is already CLOSED, this method does nothing.\n   *\n   * @param code A numeric value indicating the status code explaining why the connection is being closed. If this parameter is not specified, a default value of 1000 (indicating a normal \"transaction complete\" closure) is assumed. See the list of status codes on the CloseEvent page for permitted values.\n   * @param reason A human-readable string explaining why the connection is closing. This string must be no longer than 123 bytes of UTF-8 text (not characters).\n   *\n   * @return void\n   */\n  close (code, reason) {\n    if (typeof code === 'undefined') { code = 1000 }\n\n    this.reconnectEnabled = false\n\n    this.ws.close(code, reason)\n  }\n\n  /**\n   * Transmits data to the server over the WebSocket connection.\n   * @param data DOMString|ArrayBuffer|Blob\n   * @return void\n   */\n  send (data) { this.ws.send(data) }\n\n  /**\n   * An event listener to be called when the WebSocket connection's readyState changes to CLOSED. The listener receives a CloseEvent named \"close\".\n   * @param listener EventListener\n   */\n  set onclose (listener) { this.listeners.onclose = listener }\n\n  get onclose () { return this.listeners.onclose }\n\n  /**\n   * An event listener to be called when an error occurs. This is a simple event named \"error\".\n   * @param listener EventListener\n   */\n  set onerror (listener) { this.listeners.onerror = listener }\n\n  get onerror () { return this.listeners.onerror }\n\n  /**\n   * An event listener to be called when a message is received from the server. The listener receives a MessageEvent named \"message\".\n   * @param listener EventListener\n   */\n  set onmessage (listener) { this.listeners.onmessage = listener }\n\n  get onmessage () { return this.listeners.onmessage }\n\n  /**\n   * An event listener to be called when the WebSocket connection's readyState changes to OPEN; this indicates that the connection is ready to send and receive data. The event is a simple one with the name \"open\".\n   * @param listener EventListener\n   */\n  set onopen (listener) { this.listeners.onopen = listener }\n\n  get onopen () { return this.listeners.onopen }\n\n  /**\n   * @param listener EventListener\n   */\n  set onreconnect (listener) { this.listeners.onreconnect = listener }\n\n  get onreconnect () { return this.listeners.onreconnect }\n\n  /**\n   * Reset the backoff function back to initial state\n   */\n  reset () {\n    console.log('websocket reset')\n    this.backoff.reset()\n  }\n\n  /** Reconnect the websocket\n   *\n   */\n  reconnect () {\n    console.log('websocket reconnect')\n    this.onBackoffReady()\n  }\n}\n\n/**\n * The connection is not yet open.\n */\nWebSocketClient.CONNECTING = WebSocket.CONNECTING\n\n/**\n * The connection is open and ready to communicate.\n */\nWebSocketClient.OPEN = WebSocket.OPEN\n\n/**\n * The connection is in the process of closing.\n */\nWebSocketClient.CLOSING = WebSocket.CLOSING\n\n/**\n * The connection is closed or couldn't be opened.\n */\nWebSocketClient.CLOSED = WebSocket.CLOSED\n","import { WebSocketClient } from '../../_thirdparty/websocket/websocket'\nimport { lifecycle } from '../../_utils/lifecycle'\nimport { getStreamUrl } from './getStreamUrl'\nimport { EventEmitter } from 'events-light'\nimport { eventBus } from '../../_utils/eventBus'\nimport { safeParse } from '../../_utils/safeParse'\n\nexport class TimelineStream extends EventEmitter {\n  constructor (streamingApi, accessToken, timeline) {\n    super()\n    this._streamingApi = streamingApi\n    this._accessToken = accessToken\n    this._timeline = timeline\n    this._onStateChange = this._onStateChange.bind(this)\n    this._onOnline = this._onOnline.bind(this)\n    this._onOffline = this._onOffline.bind(this)\n    this._onForcedOnlineStateChange = this._onForcedOnlineStateChange.bind(this)\n    this._setupWebSocket()\n    this._setupEvents()\n  }\n\n  close () {\n    this._closed = true\n    this._closeWebSocket()\n    this._teardownEvents()\n    // events-light currently does not support removeAllListeners()\n    // https://github.com/patrick-steele-idem/events-light/issues/2\n    for (const event of ['open', 'close', 'reconnect', 'message']) {\n      this.removeAllListeners(event)\n    }\n  }\n\n  _closeWebSocket () {\n    if (this._ws) {\n      this.emit('close')\n      this._ws.onopen = null\n      this._ws.onmessage = null\n      this._ws.onclose = null\n      this._ws.close()\n      this._ws = null\n    }\n  }\n\n  _setupWebSocket () {\n    const url = getStreamUrl(this._streamingApi, this._accessToken, this._timeline)\n    const ws = new WebSocketClient(url)\n\n    ws.onopen = () => {\n      if (!this._opened) {\n        this.emit('open')\n        this._opened = true\n      } else {\n        // we may close or reopen websockets due to freeze/unfreeze events\n        // and we want to fire \"reconnect\" rather than \"open\" in that case\n        this.emit('reconnect')\n      }\n    }\n    ws.onmessage = (e) => this.emit('message', safeParse(e.data))\n    ws.onclose = () => this.emit('close')\n    // The ws \"onreconnect\" event seems unreliable. When the server goes down and comes back up,\n    // it doesn't fire (but \"open\" does). When we freeze and unfreeze, it fires along with the\n    // \"open\" event. The above is my attempt to normalize it.\n\n    this._ws = ws\n  }\n\n  _setupEvents () {\n    lifecycle.addEventListener('statechange', this._onStateChange)\n    eventBus.on('forcedOnline', this._onForcedOnlineStateChange) // only happens in tests\n    window.addEventListener('online', this._onOnline)\n    window.addEventListener('offline', this._onOffline)\n  }\n\n  _teardownEvents () {\n    lifecycle.removeEventListener('statechange', this._onStateChange)\n    eventBus.removeListener('forcedOnline', this._onForcedOnlineStateChange) // only happens in tests\n    window.removeEventListener('online', this._onOnline)\n    window.removeEventListener('offline', this._onOffline)\n  }\n\n  _pause () {\n    if (this._closed) {\n      return\n    }\n    this._closeWebSocket()\n  }\n\n  _unpause () {\n    if (this._closed) {\n      return\n    }\n    this._closeWebSocket()\n    this._setupWebSocket()\n  }\n\n  _onStateChange (event) {\n    // when the page enters or exits a frozen state, pause or resume websocket polling\n    if (event.newState === 'frozen') { // page is frozen\n      console.log('frozen')\n      this._pause()\n    } else if (event.oldState === 'frozen') { // page is unfrozen\n      console.log('unfrozen')\n      this._unpause()\n    }\n    if (event.newState === 'active') { // page is reopened from a background tab\n      console.log('active')\n      this._tryToReconnect()\n    }\n  }\n\n  _onOnline () {\n    console.log('online')\n    this._unpause() // if we're not paused, then this is a no-op\n    this._tryToReconnect() // to be safe, try to reset and reconnect\n  }\n\n  _onOffline () {\n    console.log('offline')\n    this._pause() // in testing, it seems to work better to stop polling when we get this event\n  }\n\n  _onForcedOnlineStateChange (online) {\n    if (online) {\n      console.log('online forced')\n      this._unpause()\n    } else {\n      console.log('offline forced')\n      this._pause()\n    }\n  }\n\n  _tryToReconnect () {\n    console.log('websocket readyState', this._ws && this._ws.readyState)\n    if (this._ws && this._ws.readyState !== WebSocketClient.OPEN) {\n      // if a websocket connection is not currently open, then reset the\n      // backoff counter to ensure that fresh notifications come in faster\n      this._ws.reset()\n      this._ws.reconnect()\n    }\n  }\n}\n","import { paramsString } from '../../_utils/ajax'\n\nfunction getStreamName (timeline) {\n  switch (timeline) {\n    case 'local':\n      return 'public:local'\n    case 'federated':\n      return 'public'\n    case 'home':\n      return 'user'\n    case 'notifications':\n      return 'user:notification'\n    case 'direct':\n      return 'direct'\n  }\n  if (timeline.startsWith('tag/')) {\n    return 'hashtag'\n  }\n  if (timeline.startsWith('list/')) {\n    return 'list'\n  }\n}\n\nexport function getStreamUrl (streamingApi, accessToken, timeline) {\n  const url = `${streamingApi}/api/v1/streaming`\n  const streamName = getStreamName(timeline)\n\n  const params = {\n    stream: streamName\n  }\n\n  if (timeline.startsWith('tag/')) {\n    params.tag = timeline.split('/').slice(-1)[0]\n  } else if (timeline.startsWith('list/')) {\n    params.list = timeline.split('/').slice(-1)[0]\n  }\n\n  if (accessToken) {\n    params.access_token = accessToken\n  }\n\n  return url + '?' + paramsString(params)\n}\n","import { mark, stop } from '../../_utils/marks'\nimport { deleteStatus } from '../deleteStatuses'\nimport { addStatusOrNotification } from '../addStatusOrNotification'\nimport { emit } from '../../_utils/eventBus'\n\nconst KNOWN_EVENTS = ['update', 'delete', 'notification', 'conversation', 'filters_changed']\n\nexport function processMessage (instanceName, timelineName, message) {\n  let { event, payload } = (message || {})\n  if (!KNOWN_EVENTS.includes(event)) {\n    console.warn('ignoring message from server', message)\n    return\n  }\n  mark('processMessage')\n  if (['update', 'notification', 'conversation'].includes(event)) {\n    payload = JSON.parse(payload) // only these payloads are JSON-encoded for some reason\n  }\n\n  switch (event) {\n    case 'delete':\n      deleteStatus(instanceName, payload)\n      break\n    case 'update':\n      addStatusOrNotification(instanceName, timelineName, payload)\n      break\n    case 'notification':\n      addStatusOrNotification(instanceName, 'notifications', payload)\n      if (payload.type === 'mention') {\n        addStatusOrNotification(instanceName, 'notifications/mentions', payload)\n      }\n      break\n    case 'conversation':\n      // This is a hack in order to mostly fit the conversation model into\n      // a timeline of statuses. To have a clean implementation we would need to\n      // reproduce what is done for statuses for the conversation.\n      //\n      // It will add new DMs as new conversations instead of updating existing threads\n      addStatusOrNotification(instanceName, timelineName, payload.last_status)\n      break\n    case 'filters_changed':\n      emit('wordFiltersChanged', instanceName)\n      break\n  }\n  stop('processMessage')\n}\n","import { TimelineStream } from '../../_api/stream/TimelineStream'\nimport { processMessage } from './processMessage'\nimport { fillStreamingGap } from './fillStreamingGap'\nimport { store } from '../../_store/store'\n\nexport function createStream (api, instanceName, accessToken, timelineName, firstStatusId, firstNotificationId) {\n  console.log(`streaming ${instanceName} ${timelineName}: createStream`, 'firstStatusId', firstStatusId,\n    'firstNotificationId', firstNotificationId)\n\n  const fillGap = (timelineName, timelineItemId) => {\n    if (timelineItemId) {\n      console.log(`streaming ${instanceName} ${timelineName}: fillGap since`, timelineItemId)\n      /* no await */ fillStreamingGap(instanceName, accessToken, timelineName, timelineItemId)\n    }\n  }\n\n  const onMessage = message => {\n    processMessage(instanceName, timelineName, message)\n  }\n\n  const onOpen = () => {\n    console.log(`streaming ${instanceName} ${timelineName}: opened`)\n    fillGap(timelineName, firstStatusId)\n    if (timelineName === 'home') {\n      // special case - home timeline stream also handles notifications\n      fillGap('notifications', firstNotificationId)\n    }\n  }\n\n  const onClose = () => {\n    console.log(`streaming ${instanceName} ${timelineName}: closed`)\n  }\n\n  const onReconnect = () => {\n    console.log(`streaming ${instanceName} ${timelineName}: reconnected`)\n    // When reconnecting, we recompute the firstStatusId and firstNotificationId because these may have\n    // changed since we first started streaming.\n    const newFirstStatusId = store.getFirstTimelineItemId(instanceName, timelineName)\n    fillGap(timelineName, newFirstStatusId)\n    if (timelineName === 'home') {\n      // special case - home timeline stream also handles notifications\n      const newFirstNotificationId = store.getFirstTimelineItemId(instanceName, 'notifications')\n      fillGap('notifications', newFirstNotificationId)\n    }\n  }\n\n  return new TimelineStream(api, accessToken, timelineName)\n    .on('message', onMessage)\n    .on('open', onOpen)\n    .on('close', onClose)\n    .on('reconnect', onReconnect)\n}\n","import { addStatusesOrNotifications } from '../addStatusOrNotification'\nimport { getTimeline } from '../../_api/timelines'\n\nconst TIMELINE_GAP_BATCH_SIZE = 20 // Mastodon timeline API maximum limit\nconst MAX_NUM_REQUESTS = 15 // to avoid getting caught in an infinite loop somehow\n\n// fill in the \"streaming gap\"  i.e. fetch the most recent items so that there isn't\n// a big gap in the timeline if you haven't looked at it in awhile\nexport async function fillStreamingGap (instanceName, accessToken, timelineName, firstTimelineItemId) {\n  let maxId = null\n  let numRequests = 0\n  let newTimelineItems\n\n  do {\n    numRequests++\n    newTimelineItems = (await getTimeline(instanceName, accessToken,\n      timelineName, maxId, firstTimelineItemId, TIMELINE_GAP_BATCH_SIZE)).items\n    if (newTimelineItems.length) {\n      addStatusesOrNotifications(instanceName, timelineName, newTimelineItems)\n      maxId = newTimelineItems[newTimelineItems.length - 1].id\n    }\n  } while (numRequests < MAX_NUM_REQUESTS && newTimelineItems.length === TIMELINE_GAP_BATCH_SIZE)\n}\n","import { updateInstanceInfo, updateVerifyCredentialsForInstance } from '../../_actions/instances'\nimport { setupListsForInstance } from '../../_actions/lists'\nimport { createStream } from '../../_actions/stream/streaming'\nimport { updatePushSubscriptionForInstance } from '../../_actions/pushSubscription'\nimport { setupCustomEmojiForInstance } from '../../_actions/emoji'\nimport { scheduleIdleTask } from '../../_utils/scheduleIdleTask'\nimport { mark, stop } from '../../_utils/marks'\nimport { store } from '../store'\nimport { updateFollowRequestCountIfLockedAccount } from '../../_actions/followRequests'\nimport { setupFiltersForInstance } from '../../_actions/filters'\n\n// stream to watch for home timeline updates and notifications\nlet currentInstanceStream\n\nasync function refreshInstanceDataAndStream (store, instanceName) {\n  mark(`refreshInstanceDataAndStream-${instanceName}`)\n  await doRefreshInstanceDataAndStream(store, instanceName)\n  stop(`refreshInstanceDataAndStream-${instanceName}`)\n}\n\nfunction currentInstanceChanged (store, instanceName) {\n  return store.get().currentInstance !== instanceName\n}\n\nasync function doRefreshInstanceDataAndStream (store, instanceName) {\n  if (currentInstanceChanged(store, instanceName)) {\n    return\n  }\n\n  await refreshInstanceData(instanceName)\n\n  if (currentInstanceChanged(store, instanceName)) {\n    return\n  }\n\n  const { currentInstanceInfo } = store.get()\n  if (!currentInstanceInfo) {\n    return\n  }\n\n  stream(store, instanceName, currentInstanceInfo)\n}\n\nasync function refreshInstanceData (instanceName) {\n  // these are all low-priority\n  scheduleIdleTask(() => setupCustomEmojiForInstance(instanceName))\n  scheduleIdleTask(() => setupListsForInstance(instanceName))\n  scheduleIdleTask(() => setupFiltersForInstance(instanceName))\n  scheduleIdleTask(() => updatePushSubscriptionForInstance(instanceName))\n\n  // these are the only critical ones\n  await Promise.all([\n    updateInstanceInfo(instanceName),\n    updateVerifyCredentialsForInstance(instanceName).then(() => {\n      // Once we have the verifyCredentials (so we know if the account is locked), lazily update the follow requests\n      scheduleIdleTask(() => updateFollowRequestCountIfLockedAccount(instanceName))\n    })\n  ])\n}\n\nfunction stream (store, instanceName, currentInstanceInfo) {\n  const { accessToken } = store.get()\n  const streamingApi = currentInstanceInfo.urls.streaming_api\n  const firstStatusId = store.getFirstTimelineItemId(instanceName, 'home')\n  const firstNotificationId = store.getFirstTimelineItemId(instanceName, 'notifications')\n\n  currentInstanceStream = createStream(streamingApi, instanceName, accessToken, 'home',\n    firstStatusId, firstNotificationId)\n\n  if (process.env.NODE_ENV !== 'production') {\n    window.currentInstanceStream = currentInstanceStream\n  }\n}\n\nexport function instanceObservers () {\n  store.observe('currentInstance', async (currentInstance) => {\n    if (!process.browser) {\n      return\n    }\n    if (currentInstanceStream) {\n      currentInstanceStream.close()\n      currentInstanceStream = null\n      if (process.env.NODE_ENV !== 'production') {\n        window.currentInstanceStream = null\n      }\n    }\n    if (!currentInstance) {\n      return\n    }\n\n    scheduleIdleTask(() => refreshInstanceDataAndStream(store, currentInstance))\n  })\n}\n","import { updateInstanceInfo } from '../../_actions/instances'\nimport { createStream } from '../../_actions/stream/streaming'\nimport { store } from '../store'\n\nexport function timelineObservers () {\n  // stream to watch for local/federated/etc. updates. home and notification\n  // updates are handled in timelineObservers.js\n  let currentTimelineStream\n\n  function shutdownPreviousStream () {\n    if (currentTimelineStream) {\n      currentTimelineStream.close()\n      currentTimelineStream = null\n      if (process.env.NODE_ENV !== 'production') {\n        window.currentTimelineStream = null\n      }\n    }\n  }\n\n  function shouldObserveTimeline (timeline) {\n    return timeline &&\n      !(\n        timeline !== 'local' &&\n        timeline !== 'federated' &&\n        timeline !== 'direct' &&\n        !timeline.startsWith('list/') &&\n        !timeline.startsWith('tag/')\n      )\n  }\n\n  store.observe('currentTimeline', async (currentTimeline) => {\n    if (!process.browser) {\n      return\n    }\n\n    shutdownPreviousStream()\n\n    if (!shouldObserveTimeline(currentTimeline)) {\n      return\n    }\n\n    const { currentInstance } = store.get()\n    const { accessToken } = store.get()\n    await updateInstanceInfo(currentInstance)\n\n    const currentTimelineIsUnchanged = () => {\n      const {\n        currentInstance: newCurrentInstance,\n        currentTimeline: newCurrentTimeline\n      } = store.get()\n      return newCurrentInstance === currentInstance &&\n        newCurrentTimeline === currentTimeline\n    }\n\n    if (!currentTimelineIsUnchanged()) {\n      return\n    }\n\n    const firstStatusId = store.getFirstTimelineItemId(currentInstance, currentTimeline)\n    const { currentInstanceInfo } = store.get()\n    const streamingApi = currentInstanceInfo.urls.streaming_api\n\n    currentTimelineStream = createStream(streamingApi, currentInstance, accessToken,\n      currentTimeline, firstStatusId)\n\n    if (process.env.NODE_ENV !== 'production') {\n      window.currentTimelineStream = currentTimelineStream\n    }\n  })\n}\n","import { setFavicon } from '../../_utils/setFavicon'\nimport { runMediumPriorityTask } from '../../_utils/runMediumPriorityTask'\nimport { store } from '../store'\n\nlet currentFaviconHasNotifications = false\n\nexport function notificationObservers () {\n  store.observe('hasNotifications', hasNotifications => {\n    if (!process.browser) {\n      return\n    }\n    runMediumPriorityTask(() => {\n      if (currentFaviconHasNotifications === hasNotifications) {\n        return\n      }\n      setFavicon(hasNotifications ? '/favicon-alert.png' : '/favicon.png')\n      currentFaviconHasNotifications = !currentFaviconHasNotifications\n    })\n  })\n}\n","import { scheduleIdleTask } from './scheduleIdleTask'\nimport { store } from '../_store/store'\nimport { isMobile } from './userAgent/isMobile'\n\n// Rough guess at whether this is a \"mobile\" device or not, for the purposes\n// of \"device class\" estimations\n\n// Run a task that doesn't need to be processed immediately, but should\n// probably be delayed if we're on a mobile device. Also run it sooner\n// if we're in a hidden tab, since browsers throttle or don't run setTimeout/rAF/etc.\nexport function runMediumPriorityTask (fn) {\n  if (store.get().pageVisibilityHidden) {\n    fn()\n  } else if (isMobile()) {\n    scheduleIdleTask(fn)\n  } else {\n    requestAnimationFrame(fn)\n  }\n}\n","// borrowed from https://github.com/HenrikJoreteg/favicon-setter\nexport function setFavicon (href) {\n  const faviconId = 'theFavicon'\n  const oldLink = document.getElementById(faviconId)\n\n  if (oldLink.getAttribute('href') === href) {\n    return\n  }\n\n  const link = document.createElement('link')\n  link.id = faviconId\n  link.rel = 'shortcut icon'\n  link.type = 'image/png'\n  link.href = href\n  document.head.removeChild(oldLink)\n  document.head.appendChild(link)\n}\n","/**\n * @var {Object} cache\n */\nvar cache = new Map();\n/**\n * Check if emoji is supported with cache\n *\n * @params {string} unicode\n * @returns {boolean}\n */\nfunction isEmojiSupported(unicode) {\n    if (cache.has(unicode)) {\n        return cache.get(unicode);\n    }\n    var supported = isSupported(unicode);\n    cache.set(unicode, supported);\n    return supported;\n}\n/**\n * Request to handle cache directly\n *\n * @params {Map} store\n */\nfunction setCacheHandler(store) {\n    cache = store;\n}\n/**\n * Check if the two pixels parts are perfectly the sames\n *\n * @params {string} unicode\n * @returns {boolean}\n */\nvar isSupported = (function () {\n    var ctx = null;\n    try {\n        ctx = document.createElement('canvas').getContext('2d');\n    }\n    catch (_a) { }\n    // Not in browser env\n    if (!ctx) {\n        return function () { return false; };\n    }\n    var CANVAS_HEIGHT = 25;\n    var CANVAS_WIDTH = 20;\n    var textSize = Math.floor(CANVAS_HEIGHT / 2);\n    // Initialize convas context\n    ctx.font = textSize + 'px Arial, Sans-Serif';\n    ctx.textBaseline = 'top';\n    ctx.canvas.width = CANVAS_WIDTH * 2;\n    ctx.canvas.height = CANVAS_HEIGHT;\n    return function (unicode) {\n        ctx.clearRect(0, 0, CANVAS_WIDTH * 2, CANVAS_HEIGHT);\n        // Draw in red on the left\n        ctx.fillStyle = '#FF0000';\n        ctx.fillText(unicode, 0, 22);\n        // Draw in blue on right\n        ctx.fillStyle = '#0000FF';\n        ctx.fillText(unicode, CANVAS_WIDTH, 22);\n        var a = ctx.getImageData(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT).data;\n        var count = a.length;\n        var i = 0;\n        // Search the first visible pixel\n        for (; i < count && !a[i + 3]; i += 4)\n            ;\n        // No visible pixel\n        if (i >= count) {\n            return false;\n        }\n        // Emoji has immutable color, so we check the color of the emoji in two different colors\n        // the result show be the same.\n        var x = CANVAS_WIDTH + ((i / 4) % CANVAS_WIDTH);\n        var y = Math.floor(i / 4 / CANVAS_WIDTH);\n        var b = ctx.getImageData(x, y, 1, 1).data;\n        if (a[i] !== b[0] || a[i + 2] !== b[2]) {\n            return false;\n        }\n        // Some emojis are a contraction of different ones, so if it's not\n        // supported, it will show multiple characters\n        if (ctx.measureText(unicode).width >= CANVAS_WIDTH) {\n            return false;\n        }\n        // Supported\n        return true;\n    };\n})();\n\nexport { isEmojiSupported, setCacheHandler };\n//# sourceMappingURL=is-emoji-supported.js.map\n","import { isEmojiSupported, setCacheHandler } from 'is-emoji-supported'\nimport { QuickLRU } from '../_thirdparty/quick-lru/quick-lru'\n\n// avoid recomputing emoji support over and over again\n// use our own LRU since the built-in one grows forever, which is a small memory leak, but still\nsetCacheHandler(new QuickLRU({ maxSize: 500 }))\n\nexport const testEmojiSupported = isEmojiSupported\n","import { store } from '../_store/store'\nimport { scheduleIdleTask } from '../_utils/scheduleIdleTask'\nimport * as emojiDatabase from '../_utils/emojiDatabase'\nimport { SEARCH_RESULTS_LIMIT } from '../_static/autosuggest'\nimport { testEmojiSupported } from '../_utils/testEmojiSupported'\nimport { mark, stop } from '../_utils/marks'\n\nasync function searchEmoji (searchText) {\n  let emojis = await emojiDatabase.findBySearchQuery(searchText)\n\n  const results = []\n\n  if (searchText.startsWith(':') && searchText.endsWith(':')) {\n    // exact shortcode search\n    const shortcode = searchText.substring(1, searchText.length - 1).toLowerCase()\n    emojis = emojis.filter(_ => _.shortcodes.includes(shortcode))\n  }\n\n  mark('testEmojiSupported')\n  for (const emoji of emojis) {\n    if (results.length === SEARCH_RESULTS_LIMIT) {\n      break\n    }\n    if (emoji.url || testEmojiSupported(emoji.unicode)) { // emoji.url is a custom emoji\n      results.push(emoji)\n    }\n  }\n  stop('testEmojiSupported')\n  return results\n}\n\nexport function doEmojiSearch (searchText) {\n  let canceled = false\n\n  scheduleIdleTask(async () => {\n    if (canceled) {\n      return\n    }\n    const results = await searchEmoji(searchText)\n    if (canceled) {\n      return\n    }\n    store.setForCurrentAutosuggest({\n      autosuggestType: 'emoji',\n      autosuggestSelected: 0,\n      autosuggestSearchResults: results\n    })\n  })\n\n  return {\n    cancel: () => {\n      canceled = true\n    }\n  }\n}\n","export const SEARCH_RESULTS_LIMIT = 4\n","// Throttle network requests to be a good citizen and not issue an HTTP request on every keystroke\nimport { PromiseThrottler } from './PromiseThrottler'\n\nconst promiseThrottler = new PromiseThrottler(200) // Mastodon FE also uses 200ms\n\nexport class RequestThrottler {\n  constructor (fetcher) {\n    this._canceled = false\n    this._controller = typeof AbortController === 'function' && new AbortController()\n    this._fetcher = fetcher\n  }\n\n  async request () {\n    if (this._canceled) {\n      throw new Error('canceled')\n    }\n    await promiseThrottler.next()\n    if (this._canceled) {\n      throw new Error('canceled')\n    }\n    const signal = this._controller && this._controller.signal\n    return this._fetcher(signal)\n  }\n\n  cancel () {\n    this._canceled = true\n    if (this._controller) {\n      this._controller.abort()\n      this._controller = null\n    }\n  }\n}\n","// Utility for throttling in the Lodash style (assuming leading: true and trailing: true) but\n// creates a promise.\nexport class PromiseThrottler {\n  constructor (timeout) {\n    this._timeout = timeout\n    this._promise = Promise.resolve()\n  }\n\n  next () {\n    const res = this._promise\n    // update afterwards, so we get a \"leading\" XHR\n    this._promise = this._promise.then(() => new Promise(resolve => setTimeout(resolve, this._timeout)))\n    return res\n  }\n}\n","import { database } from '../_database/database'\nimport { store } from '../_store/store'\nimport { search } from '../_api/search'\nimport { SEARCH_RESULTS_LIMIT } from '../_static/autosuggest'\nimport { concat } from '../_utils/arrays'\nimport uniqBy from 'lodash-es/uniqBy'\nimport { scheduleIdleTask } from '../_utils/scheduleIdleTask'\nimport { RequestThrottler } from '../_utils/RequestThrottler'\n\nconst DATABASE_SEARCH_RESULTS_LIMIT = 30\n\nfunction byUsername (a, b) {\n  const usernameA = a.acct.toLowerCase()\n  const usernameB = b.acct.toLowerCase()\n\n  return usernameA < usernameB ? -1 : usernameA === usernameB ? 0 : 1\n}\n\nfunction byAccountId (a) {\n  return a.id\n}\n\nexport function doAccountSearch (searchText) {\n  let canceled = false\n  let localResults\n  let remoteResults\n  const { currentInstance, accessToken } = store.get()\n  const requestThrottler = new RequestThrottler(doSearchAccountsRemotely)\n\n  async function searchAccountsLocally () {\n    localResults = await database.searchAccountsByUsername(\n      currentInstance, searchText.substring(1), DATABASE_SEARCH_RESULTS_LIMIT)\n  }\n\n  async function searchAccountsRemotely () {\n    remoteResults = await requestThrottler.request()\n  }\n\n  async function doSearchAccountsRemotely (signal) {\n    return (await search(\n      currentInstance, accessToken, searchText, false, SEARCH_RESULTS_LIMIT, false, signal\n    )).accounts\n  }\n\n  function mergeAndTruncateResults () {\n    // Always include local results; they are more likely to be relevant\n    // because the user has seen their content before. Otherwise, sort by username.\n    let results = (localResults || [])\n      .slice()\n      .sort(byUsername)\n      .slice(0, SEARCH_RESULTS_LIMIT)\n\n    if (results.length < SEARCH_RESULTS_LIMIT) {\n      const topRemoteResults = (remoteResults || [])\n        .sort(byUsername)\n        .slice(0, SEARCH_RESULTS_LIMIT - results.length)\n      results = concat(results, topRemoteResults)\n      results = uniqBy(results, byAccountId)\n    }\n\n    return results\n  }\n\n  function onNewResults () {\n    if (canceled) {\n      return\n    }\n    const results = mergeAndTruncateResults()\n    store.setForCurrentAutosuggest({\n      autosuggestType: 'account',\n      autosuggestSelected: 0,\n      autosuggestSearchResults: results\n    })\n  }\n\n  function onError (err) {\n    console.warn('ignored autosuggest error', err)\n  }\n\n  scheduleIdleTask(() => {\n    if (canceled) {\n      return\n    }\n    // run the two searches in parallel\n    searchAccountsLocally().then(onNewResults).catch(onError)\n    searchAccountsRemotely().then(onNewResults).catch(onError)\n  })\n\n  return {\n    cancel: () => {\n      canceled = true\n      requestThrottler.cancel()\n    }\n  }\n}\n","import { search } from '../_api/search'\nimport { store } from '../_store/store'\nimport { scheduleIdleTask } from '../_utils/scheduleIdleTask'\nimport { SEARCH_RESULTS_LIMIT } from '../_static/autosuggest'\nimport { RequestThrottler } from '../_utils/RequestThrottler'\nimport { sum } from '../_utils/lodash-lite'\n\nconst HASHTAG_SEARCH_LIMIT = 10\n\nfunction getUses (historyItem) {\n  return historyItem.uses\n}\n\n// Show the most common hashtags first, then sort by name\nfunction byUsesThenName (a, b) {\n  if (a.history && b.history && a.history.length && b.history.length) {\n    const aCount = sum(a.history.map(getUses))\n    const bCount = sum(b.history.map(getUses))\n    return aCount > bCount ? -1 : aCount < bCount ? 1 : 0\n  }\n  return a.name < b.name ? -1 : a.name > b.name ? 1 : 0\n}\n\nexport function doHashtagSearch (searchText) {\n  const { currentInstance, accessToken } = store.get()\n  const requestThrottler = new RequestThrottler(searchHashtags)\n\n  async function searchHashtags (signal) {\n    const results = await search(\n      currentInstance, accessToken, searchText, false, HASHTAG_SEARCH_LIMIT, true, signal\n    )\n    return results.hashtags.sort(byUsesThenName).slice(0, SEARCH_RESULTS_LIMIT)\n  }\n\n  scheduleIdleTask(async () => {\n    try {\n      const results = await requestThrottler.request()\n      store.setForCurrentAutosuggest({\n        autosuggestType: 'hashtag',\n        autosuggestSelected: 0,\n        autosuggestSearchResults: results\n      })\n    } catch (err) {\n      console.warn('ignored autosuggest error', err)\n    }\n  })\n\n  return {\n    cancel: () => {\n      requestThrottler.cancel()\n    }\n  }\n}\n","import { store } from '../store'\nimport { doEmojiSearch } from '../../_actions/autosuggestEmojiSearch'\nimport { doAccountSearch } from '../../_actions/autosuggestAccountSearch'\nimport { doHashtagSearch } from '../../_actions/autosuggestHashtagSearch'\n\nfunction resetAutosuggest () {\n  store.setForCurrentAutosuggest({\n    autosuggestSelected: 0,\n    autosuggestSearchResults: []\n  })\n}\n\nexport function autosuggestObservers () {\n  let lastSearch\n\n  store.observe('autosuggestSearchText', async autosuggestSearchText => {\n    // cancel any inflight XHRs or other operations\n    if (lastSearch) {\n      lastSearch.cancel()\n      lastSearch = null\n    }\n    // autosuggestSelecting indicates that the user has pressed Enter or clicked on an item\n    // and the results are being processed. Returning early avoids a flash of searched content.\n    const { composeFocused } = store.get()\n    const autosuggestSelecting = store.getForCurrentAutosuggest('autosuggestSelecting')\n    if (!composeFocused || !autosuggestSearchText || autosuggestSelecting) {\n      resetAutosuggest()\n      return\n    }\n\n    if (autosuggestSearchText.startsWith(':')) { // emoji\n      lastSearch = doEmojiSearch(autosuggestSearchText)\n    } else if (autosuggestSearchText.startsWith('#')) { // hashtag\n      lastSearch = doHashtagSearch(autosuggestSearchText)\n    } else { // account\n      lastSearch = doAccountSearch(autosuggestSearchText)\n    }\n  })\n}\n","import { store } from '../store'\n\nconst theScrollbarStyle = process.browser && document.getElementById('theScrollbarStyle')\n\nexport function customScrollbarObservers () {\n  store.observe('disableCustomScrollbars', disableCustomScrollbars => {\n    if (!process.browser) {\n      return\n    }\n\n    // disables or enables the style\n    theScrollbarStyle.setAttribute('media', disableCustomScrollbars ? 'only x' : 'all')\n  }, { init: false })\n}\n","import { store } from '../store'\nimport { scheduleIdleTask } from '../../_utils/scheduleIdleTask'\nimport { CLEANUP_DELAY, CLEANUP_TIME_AGO } from '../../_static/database'\nimport { scheduleInterval } from '../../_utils/scheduleInterval'\n\nfunction doCleanup () {\n  // Periodically clean up drafts in localStorage, so they don't grow without bound.\n  // Only do this for replies, so not for the home timeline or the compose modal.\n  const now = Date.now()\n  let changeCount = 0\n  const { composeData } = store.get()\n  for (const instanceComposeData of Object.values(composeData)) {\n    for (const [realm, timelineComposeData] of Object.entries(instanceComposeData)) {\n      if (realm === 'home' || realm === 'dialog') {\n        continue\n      }\n      const ts = timelineComposeData.ts || 0 // if no timestamp set, just assume it's very old (migration behavior)\n      if (now - ts > CLEANUP_TIME_AGO) {\n        delete instanceComposeData[realm]\n        changeCount++\n      }\n    }\n  }\n  console.log('deleted', changeCount, 'old drafts')\n  if (changeCount) {\n    store.set({ composeData })\n  }\n}\n\nfunction doCleanupLazily () {\n  scheduleIdleTask(doCleanup)\n}\n\nexport function cleanup () {\n  scheduleInterval(doCleanupLazily, CLEANUP_DELAY, /* runOnActive */ false)\n}\n","import { store } from '../store'\nimport { showComposeDialog } from '../../_actions/showComposeDialog'\n\n// If the user is logged in, and if the Service Worker handled a POST and set special data\n// in IndexedDB, then we want to handle it on the home page.\nexport function showComposeDialogObservers () {\n  let observedOnce = false\n  store.observe('currentVerifyCredentials', async verifyCredentials => {\n    if (verifyCredentials && !observedOnce) {\n      // when the verifyCredentials object is available, we can check to see\n      // if the user is trying to share something (or we got here from a shortcut), then share it\n      observedOnce = true\n      const { currentPage } = store.get()\n      if (currentPage === 'home' && new URLSearchParams(location.search).get('compose') === 'true') {\n        await showComposeDialog()\n      }\n    }\n  })\n}\n","import { store } from '../_store/store'\nimport { importShowComposeDialog } from '../_components/dialog/asyncDialogs/importShowComposeDialog'\nimport { database } from '../_database/database'\nimport { doMediaUpload } from './media'\n\n// show a compose dialog, typically invoked by the Web Share API or a PWA shortcut\nexport async function showComposeDialog () {\n  const { isUserLoggedIn } = store.get()\n  if (!isUserLoggedIn) {\n    return\n  }\n  const importShowComposeDialogPromise = importShowComposeDialog() // start promise early\n\n  const data = await database.getWebShareData()\n\n  if (data) {\n    await database.deleteWebShareData() // only need this data once; it came from Web Share (service worker)\n  }\n\n  console.log('share data', data)\n  const { title, text, url, file } = (data || {})\n\n  // url is currently ignored on Android, but one can dream\n  // https://web.dev/web-share-target/#verifying-shared-content\n  const composeText = [title, text, url].filter(Boolean).join('\\n\\n')\n\n  store.clearComposeData('dialog')\n  store.setComposeData('dialog', { text: composeText })\n  store.save()\n\n  const showComposeDialog = await importShowComposeDialogPromise\n  showComposeDialog()\n  if (file) { // start the upload once the dialog is in view so it shows the loading spinner and everything\n    /* no await */ doMediaUpload('dialog', file)\n  }\n}\n","import { isChrome } from './isChrome'\nimport { thunk } from '../thunk'\n\n// https://caniuse.com/cookie-store-api\nexport const isChromePre87 = thunk(() => (process.browser && isChrome() && typeof cookieStore === 'undefined'))\n","function getStatusModifications (store, instanceName) {\n  const { statusModifications } = store.get()\n  statusModifications[instanceName] = statusModifications[instanceName] || {\n    favorites: {},\n    reblogs: {},\n    pins: {},\n    bookmarks: {}\n  }\n  return statusModifications\n}\n\nfunction setStatusModification (store, instanceName, statusId, key, value) {\n  const statusModifications = getStatusModifications(store, instanceName)\n  statusModifications[instanceName][key][statusId] = value\n  store.set({ statusModifications })\n}\n\nexport function statusMixins (Store) {\n  Store.prototype.setStatusFavorited = function (instanceName, statusId, favorited) {\n    setStatusModification(this, instanceName, statusId, 'favorites', favorited)\n  }\n\n  Store.prototype.setStatusReblogged = function (instanceName, statusId, reblogged) {\n    setStatusModification(this, instanceName, statusId, 'reblogs', reblogged)\n  }\n\n  Store.prototype.setStatusPinned = function (instanceName, statusId, pinned) {\n    setStatusModification(this, instanceName, statusId, 'pins', pinned)\n  }\n\n  Store.prototype.setStatusBookmarked = function (instanceName, statusId, bookmarked) {\n    setStatusModification(this, instanceName, statusId, 'bookmarks', bookmarked)\n  }\n}\n","import { timelineMixins } from './timelineMixins'\nimport { statusMixins } from './statusMixins'\nimport { autosuggestMixins } from './autosuggestMixins'\nimport { composeMixins } from './composeMixins'\nimport { PinaforeStore as Store } from '../store'\n\nexport function loggedInMixins () {\n  composeMixins(Store)\n  timelineMixins(Store)\n  statusMixins(Store)\n  autosuggestMixins(Store)\n}\n","import { get } from '../../_utils/lodash-lite'\n\nexport function composeMixins (Store) {\n  Store.prototype.setComposeData = function (realm, obj) {\n    const { composeData, currentInstance } = this.get()\n    const instanceNameData = composeData[currentInstance] = composeData[currentInstance] || {}\n    instanceNameData[realm] = Object.assign(\n      instanceNameData[realm] || {},\n      { ts: Date.now() },\n      obj\n    )\n    this.set({ composeData })\n  }\n\n  Store.prototype.getComposeData = function (realm, key) {\n    const { composeData, currentInstance } = this.get()\n    return get(composeData, [currentInstance, realm, key])\n  }\n\n  Store.prototype.clearComposeData = function (realm) {\n    const { composeData, currentInstance } = this.get()\n    if (composeData && composeData[currentInstance]) {\n      delete composeData[currentInstance][realm]\n    }\n    this.set({ composeData })\n  }\n}\n","import { pickBy, get } from '../../_utils/lodash-lite'\nimport { getFirstIdFromItemSummaries } from '../../_utils/getIdFromItemSummaries'\n\nexport function timelineMixins (Store) {\n  Store.prototype.setForTimeline = function (instanceName, timelineName, obj) {\n    const valuesToSet = {}\n    for (const key of Object.keys(obj)) {\n      const rootKey = `timelineData_${key}`\n      const root = this.get()[rootKey] || {}\n      const instanceData = root[instanceName] = root[instanceName] || {}\n      instanceData[timelineName] = obj[key]\n      valuesToSet[rootKey] = root\n    }\n\n    this.set(valuesToSet)\n  }\n\n  Store.prototype.getForTimeline = function (instanceName, timelineName, key) {\n    const rootKey = `timelineData_${key}`\n    const root = this.get()[rootKey]\n    return get(root, [instanceName, timelineName])\n  }\n\n  Store.prototype.getAllTimelineData = function (instanceName, key) {\n    const root = this.get()[`timelineData_${key}`] || {}\n    return root[instanceName] || {}\n  }\n\n  Store.prototype.getFirstTimelineItemId = function (instanceName, timelineName) {\n    const summaries = this.getForTimeline(instanceName, timelineName, 'timelineItemSummaries')\n    return getFirstIdFromItemSummaries(summaries)\n  }\n\n  Store.prototype.setForCurrentTimeline = function (obj) {\n    const { currentInstance, currentTimeline } = this.get()\n    this.setForTimeline(currentInstance, currentTimeline, obj)\n  }\n\n  Store.prototype.getThreads = function (instanceName) {\n    const instanceData = this.getAllTimelineData(instanceName, 'timelineItemSummaries')\n\n    return pickBy(instanceData, (value, key) => {\n      return key.startsWith('status/')\n    })\n  }\n\n  Store.prototype.clearTimelineDataForInstance = function (instanceName) {\n    const changes = {}\n    Object.entries(this.get()).forEach(([key, value]) => {\n      if (key.startsWith('timelineData_') && value) {\n        delete value[instanceName]\n        changes[key] = value\n      }\n    })\n    this.set(changes)\n  }\n}\n","import { get } from '../../_utils/lodash-lite'\n\nexport function autosuggestMixins (Store) {\n  Store.prototype.setForAutosuggest = function (instanceName, realm, obj) {\n    const valuesToSet = {}\n    for (const key of Object.keys(obj)) {\n      const rootKey = `autosuggestData_${key}`\n      const root = this.get()[rootKey] || {}\n      const instanceData = root[instanceName] = root[instanceName] || {}\n      instanceData[realm] = obj[key]\n      valuesToSet[rootKey] = root\n    }\n\n    this.set(valuesToSet)\n  }\n\n  Store.prototype.setForCurrentAutosuggest = function (obj) {\n    const { currentInstance, currentComposeRealm } = this.get()\n    this.setForAutosuggest(currentInstance, currentComposeRealm, obj)\n  }\n\n  Store.prototype.getForCurrentAutosuggest = function (key) {\n    const { currentInstance, currentComposeRealm } = this.get()\n    return get(this.get()[`autosuggestData_${key}`], [currentInstance, currentComposeRealm])\n  }\n\n  Store.prototype.clearAutosuggestDataForInstance = function (instanceName) {\n    const changes = {}\n    Object.entries(this.get()).forEach(([key, value]) => {\n      if (key.startsWith('autosuggestData_') && value) {\n        delete value[instanceName]\n        changes[key] = value\n      }\n    })\n    this.set(changes)\n  }\n}\n","// like loggedInObservers.js, these can be lazy-loaded once the user is actually logged in\nimport { timelineComputations } from './timelineComputations'\nimport { autosuggestComputations } from './autosuggestComputations'\nimport { store } from '../store'\nimport { wordFilterComputations } from './wordFilterComputations'\nimport { badgeComputations } from './badgeComputations'\nimport { timelineFilterComputations } from './timelineFilterComputations'\nimport { mark, stop } from '../../_utils/marks'\n\nexport function loggedInComputations () {\n  mark('loggedInComputations')\n  wordFilterComputations(store)\n  timelineComputations(store)\n  timelineFilterComputations(store)\n  badgeComputations(store)\n  autosuggestComputations(store)\n  stop('loggedInComputations')\n}\n","import { get } from '../../_utils/lodash-lite'\n\nexport function badgeComputations (store) {\n  store.compute('numberOfNotifications',\n    ['filteredTimelineNotificationItemSummaries', 'disableNotificationBadge'],\n    (filteredTimelineNotificationItemSummaries, disableNotificationBadge) => (\n      (!disableNotificationBadge && filteredTimelineNotificationItemSummaries)\n        ? filteredTimelineNotificationItemSummaries.length\n        : 0\n    )\n  )\n  store.compute('hasNotifications',\n    ['numberOfNotifications', 'currentPage'],\n    (numberOfNotifications, currentPage) => (\n      currentPage !== 'notifications' && !!numberOfNotifications\n    )\n  )\n\n  store.compute('numberOfFollowRequests',\n    ['followRequestCounts', 'currentInstance'],\n    (followRequestCounts, currentInstance) => get(followRequestCounts, [currentInstance], 0)\n  )\n\n  store.compute('hasFollowRequests',\n    ['numberOfFollowRequests'],\n    (numberOfFollowRequests) => !!numberOfFollowRequests\n  )\n\n  store.compute('badgeNumber',\n    ['numberOfFollowRequests', 'numberOfNotifications'],\n    (numberOfFollowRequests, numberOfNotifications) => (numberOfFollowRequests + numberOfNotifications)\n  )\n}\n","import { instanceObservers } from './instanceObservers'\nimport { timelineObservers } from './timelineObservers'\nimport { notificationObservers } from './notificationObservers'\nimport { autosuggestObservers } from './autosuggestObservers'\nimport { notificationPermissionObservers } from './notificationPermissionObservers'\nimport { customScrollbarObservers } from './customScrollbarObservers'\nimport { customEmojiObservers } from './customEmojiObservers'\nimport { cleanup } from './cleanup'\nimport { wordFilterObservers } from './wordFilterObservers'\nimport { showComposeDialogObservers } from './showComposeDialogObservers'\nimport { badgeObservers } from './badgeObservers'\n\n// These observers can be lazy-loaded when the user is actually logged in.\n// Prevents circular dependencies and reduces the size of main.js\nexport function loggedInObservers () {\n  instanceObservers()\n  timelineObservers()\n  wordFilterObservers()\n  notificationObservers()\n  autosuggestObservers()\n  notificationPermissionObservers()\n  customScrollbarObservers()\n  customEmojiObservers()\n  showComposeDialogObservers()\n  badgeObservers()\n  cleanup()\n}\n","import { on } from '../../_utils/eventBus'\nimport { updateFiltersForInstance } from '../../_actions/filters'\nimport { store } from '../store'\nimport { isEqual } from 'lodash-es'\nimport { computeFilterContextsForStatusOrNotification } from '../../_utils/computeFilterContextsForStatusOrNotification'\nimport { database } from '../../_database/database'\nimport { mark, stop } from '../../_utils/marks'\n\nexport function wordFilterObservers () {\n  if (!process.browser) {\n    return\n  }\n  on('wordFiltersChanged', instanceName => {\n    /* no await */ updateFiltersForInstance(instanceName)\n  })\n\n  // compute `unexpiredInstanceFilters` based on `now` and `instanceFilters`. `now` updates every 10 seconds.\n  function updateUnexpiredInstanceFiltersIfUnchanged (now, instanceFilters) {\n    const unexpiredInstanceFilters = Object.fromEntries(Object.entries(instanceFilters).map(([instanceName, filters]) => {\n      const unexpiredFilters = filters.filter(filter => (\n        !filter.expires_at || new Date(filter.expires_at).getTime() >= now\n      ))\n      return [instanceName, unexpiredFilters]\n    }))\n\n    // don't force an update/recalc if nothing changed\n    if (!isEqual(store.get().unexpiredInstanceFilters, unexpiredInstanceFilters)) {\n      console.log('updated unexpiredInstanceFilters', unexpiredInstanceFilters)\n      store.set({ unexpiredInstanceFilters })\n    }\n  }\n\n  store.observe('now', now => {\n    const { instanceFilters } = store.get()\n    updateUnexpiredInstanceFiltersIfUnchanged(now, instanceFilters)\n  })\n\n  store.observe('instanceFilters', instanceFilters => {\n    const { now } = store.get()\n    updateUnexpiredInstanceFiltersIfUnchanged(now, instanceFilters)\n  })\n\n  store.observe('unexpiredInstanceFilterRegexes', async unexpiredInstanceFilterRegexes => {\n    console.log('unexpiredInstanceFilterRegexes changed, recomputing filterContexts')\n    mark('update timeline item summary filter contexts')\n    // Whenever the filters change, we need to re-compute the filterContexts on the TimelineSummaries.\n    // This is a bit of an odd design, but we do it for perf. See timelineItemToSummary.js for details.\n    let {\n      timelineData_timelineItemSummaries: timelineItemSummaries,\n      timelineData_timelineItemSummariesToAdd: timelineItemSummariesToAdd\n    } = store.get()\n\n    timelineItemSummaries = timelineItemSummaries || {}\n    timelineItemSummariesToAdd = timelineItemSummariesToAdd || {}\n\n    let somethingChanged = false\n\n    await Promise.all(Object.entries(unexpiredInstanceFilterRegexes).map(async ([instanceName, contextsToRegex]) => {\n      const timelinesToSummaries = timelineItemSummaries[instanceName] || {}\n      const timelinesToSummariesToAdd = timelineItemSummariesToAdd[instanceName] || {}\n      const summariesToUpdate = [\n        ...(Object.values(timelinesToSummaries).flat()),\n        ...(Object.values(timelinesToSummariesToAdd).flat())\n      ]\n      console.log(`Attempting to update filters for ${summariesToUpdate.length} item summaries`)\n      await Promise.all(summariesToUpdate.map(async summary => {\n        try {\n          const isNotification = summary.type\n          const item = await (isNotification\n            ? database.getNotification(instanceName, summary.id)\n            : database.getStatus(instanceName, summary.id)\n          )\n          const newFilterContexts = computeFilterContextsForStatusOrNotification(item, contextsToRegex)\n          if (!isEqual(summary.filterContexts, newFilterContexts)) {\n            somethingChanged = true\n            summary.filterContexts = newFilterContexts\n          }\n        } catch (err) {\n          console.error(err)\n          // not stored in the database anymore, just ignore\n        }\n      }))\n    }))\n\n    // The previous was an async operation, so the timelinesItemSummaries or timelineItemSummariesToAdd\n    // may have changed. But we need to make sure that the filterContexts are updated in the store\n    // So just force an update here.\n    if (somethingChanged) {\n      console.log('Word filters changed, forcing an update')\n      // eslint-disable-next-line camelcase\n      const { timelineData_timelineItemSummaries, timelineData_timelineItemSummariesToAdd } = store.get()\n      store.set({ timelineData_timelineItemSummaries, timelineData_timelineItemSummariesToAdd })\n    }\n    stop('update timeline item summary filter contexts')\n  }, { init: false })\n}\n","import { store } from '../store'\n\nexport function notificationPermissionObservers () {\n  if (!process.browser || !navigator.permissions || !navigator.permissions.query) {\n    return\n  }\n\n  navigator.permissions.query({ name: 'notifications' }).then(permission => {\n    store.set({ notificationPermission: permission.state })\n\n    permission.onchange = event => {\n      store.set({ notificationPermission: event.target.state })\n    }\n  })\n}\n","import { store } from '../store'\nimport * as emojiDatabase from '../../_utils/emojiDatabase'\nimport { convertCustomEmojiToEmojiPickerFormat } from '../../_utils/convertCustomEmojiToEmojiPickerFormat'\n\nexport function customEmojiObservers () {\n  if (!process.browser) {\n    return\n  }\n\n  function setEmoji (currentEmoji, autoplayGifs) {\n    const customEmojiInEmojiPickerFormat = convertCustomEmojiToEmojiPickerFormat(currentEmoji, autoplayGifs)\n    emojiDatabase.setCustomEmoji(customEmojiInEmojiPickerFormat)\n  }\n\n  store.observe('currentCustomEmoji', currentCustomEmoji => {\n    setEmoji(currentCustomEmoji, store.get().autoplayGifs)\n  }, { init: false })\n\n  store.observe('autoplayGifs', autoplayGifs => {\n    setEmoji(store.get().currentCustomEmoji, autoplayGifs)\n  }, { init: false })\n}\n","import { store } from '../store'\nimport { isChromePre87 } from '../../_utils/userAgent/isChromePre87'\n\nexport function badgeObservers () {\n  if (!process.browser) {\n    return\n  }\n  // Chrome 86 on Linux in Circle CI seems to hang just by checking for this... not worth supporting.\n  if (isChromePre87() || !('setAppBadge' in navigator)) {\n    return\n  }\n  store.observe('badgeNumber', badgeNumber => {\n    if (badgeNumber) {\n      navigator.setAppBadge(badgeNumber)\n    } else {\n      navigator.clearAppBadge()\n    }\n  })\n}\n","// Forked from https://github.com/sindresorhus/quick-lru/blob/16d15d470a8eb87c2a7dd5b80892d9b74f1acd3c/index.js\n// Adds the ability to listen for 'evict' events using an EventEmitter, also removes some unused code\n\nimport { EventEmitter } from 'events-light'\n\nexport class QuickLRU extends EventEmitter {\n  constructor (options = {}) {\n    super()\n    if (!(options.maxSize && options.maxSize > 0)) {\n      throw new TypeError('`maxSize` must be a number greater than 0')\n    }\n\n    this.maxSize = options.maxSize\n    this.cache = new Map()\n    this.oldCache = new Map()\n    this._size = 0\n  }\n\n  _set (key, value) {\n    this.cache.set(key, value)\n    this._size++\n\n    if (this._size >= this.maxSize) {\n      this._size = 0\n      if (this.listenerCount('evict')) {\n        for (const key of this.oldCache.keys()) {\n          if (!this.cache.has(key)) {\n            this.emit('evict', this.oldCache.get(key), key)\n          }\n        }\n      }\n      this.oldCache = this.cache\n      this.cache = new Map()\n    }\n  }\n\n  get (key) {\n    if (this.cache.has(key)) {\n      return this.cache.get(key)\n    }\n\n    if (this.oldCache.has(key)) {\n      const value = this.oldCache.get(key)\n      this.oldCache.delete(key)\n      this._set(key, value)\n      return value\n    }\n  }\n\n  set (key, value) {\n    if (this.cache.has(key)) {\n      this.cache.set(key, value)\n    } else {\n      this._set(key, value)\n    }\n\n    return this\n  }\n\n  has (key) {\n    return this.cache.has(key) || this.oldCache.has(key)\n  }\n\n  // unused\n  // peek (key) {\n  //   if (this.cache.has(key)) {\n  //     return this.cache.get(key)\n  //   }\n  //\n  //   if (this.oldCache.has(key)) {\n  //     return this.oldCache.get(key)\n  //   }\n  // }\n\n  delete (key) {\n    const deleted = this.cache.delete(key)\n    if (deleted) {\n      this._size--\n    }\n\n    return this.oldCache.delete(key) || deleted\n  }\n\n  clear () {\n    this.cache.clear()\n    this.oldCache.clear()\n    this._size = 0\n  }\n\n  getAllKeys () {\n    const set = new Set()\n    for (const key of this.cache.keys()) {\n      set.add(key)\n    }\n    for (const key of this.oldCache.keys()) {\n      set.add(key)\n    }\n    return set\n  }\n\n  // unused\n  // * keys() {\n  //   for (const [key] of this) {\n  //     yield key;\n  //   }\n  // }\n  //\n  // * values() {\n  //   for (const [, value] of this) {\n  //     yield value;\n  //   }\n  // }\n  //\n  // * [Symbol.iterator]() {\n  //   for (const item of this.cache) {\n  //     yield item;\n  //   }\n  //\n  //   for (const item of this.oldCache) {\n  //     const [key] = item;\n  //     if (!this.cache.has(key)) {\n  //       yield item;\n  //     }\n  //   }\n  // }\n  //\n  // get size () {\n  //   let oldCacheSize = 0\n  //   for (const key of this.oldCache.keys()) {\n  //     if (!this.cache.has(key)) {\n  //       oldCacheSize++\n  //     }\n  //   }\n  //\n  //   return this._size + oldCacheSize\n  // }\n}\n","export const DEFAULT_TIMEOUT = 20000\nexport const MEDIA_WRITE_TIMEOUT = 90000 // media uploads can take awhile\nexport const WRITE_TIMEOUT = 45000 // allow more time if the user did a write action\n\nfunction fetchWithTimeout (url, fetchOptions, timeout) {\n  return new Promise((resolve, reject) => {\n    fetch(url, fetchOptions).then(resolve, reject)\n    setTimeout(() => reject(new Error(`Timed out after ${timeout / 1000} seconds`)), timeout)\n  })\n}\n\nfunction makeFetchOptions (method, headers, options) {\n  const res = {\n    method,\n    headers: Object.assign(headers || {}, {\n      Accept: 'application/json'\n    })\n  }\n  if (options && options.signal) {\n    res.signal = options.signal\n  }\n  return res\n}\n\nasync function throwErrorIfInvalidResponse (response) {\n  if (response.status >= 300) {\n    const err = new Error('Request failed: ' + response.status)\n    err.status = response.status\n    throw err\n  }\n  const json = await response.json()\n  if (response.status >= 200 && response.status < 300) {\n    return { json, headers: response.headers }\n  }\n  if (json && json.error) {\n    throw new Error(response.status + ': ' + json.error)\n  }\n  throw new Error('Request failed: ' + response.status)\n}\n\nasync function _fetch (url, fetchOptions, options) {\n  let response\n  if (options && options.timeout) {\n    response = await fetchWithTimeout(url, fetchOptions, options.timeout)\n  } else {\n    response = await fetch(url, fetchOptions)\n  }\n  return throwErrorIfInvalidResponse(response)\n}\n\nasync function _putOrPostOrPatch (method, url, body, headers, options) {\n  const fetchOptions = makeFetchOptions(method, headers, options)\n  if (body) {\n    if (body instanceof FormData) {\n      fetchOptions.body = body\n    } else {\n      fetchOptions.body = JSON.stringify(body)\n      fetchOptions.headers['Content-Type'] = 'application/json'\n    }\n  }\n  return _fetch(url, fetchOptions, options)\n}\n\nexport async function put (url, body, headers, options) {\n  return (await _putOrPostOrPatch('PUT', url, body, headers, options)).json\n}\n\nexport async function post (url, body, headers, options) {\n  return (await _putOrPostOrPatch('POST', url, body, headers, options)).json\n}\n\nexport async function patch (url, body, headers, options) {\n  return (await _putOrPostOrPatch('PATCH', url, body, headers, options)).json\n}\n\nexport async function get (url, headers, options) {\n  return (await _fetch(url, makeFetchOptions('GET', headers, options), options)).json\n}\n\n/** @returns {json, headers} */\nexport async function getWithHeaders (url, headers, options) {\n  return _fetch(url, makeFetchOptions('GET', headers, options), options)\n}\n\nexport async function del (url, headers, options) {\n  return (await _fetch(url, makeFetchOptions('DELETE', headers, options), options)).json\n}\n\nexport function paramsString (paramsObject) {\n  let res = ''\n  let count = -1\n  Object.keys(paramsObject).forEach(key => {\n    const value = paramsObject[key]\n    if (Array.isArray(value)) { // rails convention for encoding multiple values\n      for (const item of value) {\n        res += (++count > 0 ? '&' : '') + encodeURIComponent(key) + '[]=' + encodeURIComponent(item)\n      }\n    } else {\n      res += (++count > 0 ? '&' : '') + encodeURIComponent(key) + '=' + encodeURIComponent(value)\n    }\n  })\n  return res\n}\n","export function convertCustomEmojiToEmojiPickerFormat (customEmoji, autoplayGifs) {\n  if (!customEmoji) {\n    return []\n  }\n  return customEmoji.filter(emoji => emoji.visible_in_picker).map(emoji => ({\n    name: emoji.shortcode,\n    shortcodes: [emoji.shortcode],\n    url: autoplayGifs ? emoji.url : emoji.static_url,\n    category: emoji.category\n  }))\n}\n","import Database from 'emoji-picker-element/database'\nimport { lifecycle } from './lifecycle'\nimport { emojiPickerLocale, emojiPickerDataSource } from '../_static/emojiPickerIntl'\n\nlet database\n\nfunction applySkinToneToEmoji (emoji, skinTone) {\n  if (!emoji || emoji.url) { // nonexistent or custom emoji\n    return emoji\n  }\n  const res = {\n    unicode: emoji.unicode,\n    shortcodes: emoji.shortcodes\n  }\n  if (skinTone > 0 && emoji.skins) { // non-default skin tone\n    const tone = emoji.skins.find(_ => _.tone === skinTone)\n    if (tone) {\n      res.unicode = tone.unicode\n    }\n  }\n  return res\n}\n\nexport function init () {\n  if (!database) {\n    database = new Database({\n      locale: emojiPickerLocale,\n      dataSource: emojiPickerDataSource\n    })\n  }\n}\n\nexport function setCustomEmoji (customEmoji) {\n  init()\n  database.customEmoji = customEmoji\n}\n\nexport async function findByUnicodeOrName (unicodeOrName) {\n  init()\n  const [emoji, skinTone] = await Promise.all([\n    database.getEmojiByUnicodeOrName(unicodeOrName),\n    database.getPreferredSkinTone()\n  ])\n  return applySkinToneToEmoji(emoji, skinTone)\n}\n\nexport async function findBySearchQuery (query) {\n  init()\n  const [emojis, skinTone] = await Promise.all([\n    database.getEmojiBySearchQuery(query),\n    database.getPreferredSkinTone()\n  ])\n  return emojis.map(emoji => applySkinToneToEmoji(emoji, skinTone))\n}\n\nif (process.browser) {\n  lifecycle.addEventListener('statechange', event => {\n    if (event.newState === 'frozen' && database) { // page is frozen, close IDB connections\n      console.log('closed emoji DB')\n      database.close()\n    }\n  })\n}\n","import { thunk } from '../thunk'\n\nexport const isMobile = thunk(() => process.browser && navigator.userAgent.match(/(?:iPhone|iPod|iPad|Android|KAIOS)/))\n"],"sourceRoot":""}