{"version":3,"sources":["webpack://pinafore/./node_modules/lodash-es/times.js","webpack://pinafore/./node_modules/pointer-tracker/dist/PointerTracker.mjs","webpack://pinafore/./node_modules/pinch-zoom-element/dist/pinch-zoom.es.js"],"names":["n","iteratee","index","result","Array","Pointer","nativePointer","this","id","pageX","pageY","clientX","clientY","self","Touch","identifier","isPointerEvent","pointerId","getCoalescedEvents","map","p","event","PointerEvent","noop","_element","start","move","end","rawUpdates","startPointers","currentPointers","_pointerStart","button","_triggerPointerStart","target","setPointerCapture","addEventListener","_rawUpdates","_move","_pointerEnd","window","_touchStart","touch","from","changedTouches","previousPointers","slice","changedPointers","t","trackedChangedPointers","pointer","findIndex","push","length","_moveCallback","_triggerPointerEnd","splice","cancelled","type","_endCallback","removeEventListener","_touchEnd","_startCallback","css","ref","insertAt","document","head","getElementsByTagName","style","createElement","firstChild","insertBefore","appendChild","styleSheet","cssText","createTextNode","styleInject","minScaleAttr","getDistance","a","b","Math","sqrt","getMidpoint","getAbsoluteValue","value","max","trimRight","endsWith","parseFloat","cachedSvg","getSVG","createElementNS","createMatrix","createSVGMatrix","createPoint","createSVGPoint","MIN_SCALE","PinchZoom","HTMLElement","super","_transform","MutationObserver","_stageElChange","observe","childList","pointerTracker","_positioningEl","preventDefault","_onPointerMove","_onWheel","name","oldValue","newValue","scale","minScale","setTransform","attrValue","getAttribute","Number","isFinite","setAttribute","String","e","f","opts","originX","originY","relativeTo","allowChangeEvent","relativeToEl","rect","getBoundingClientRect","width","height","x","y","currentRect","left","top","_applyChange","scaleDiff","_updateTransform","thisBounds","positioningElBounds","topLeft","bottomRight","matrix","translate","multiply","inverse","matrixTransform","d","setProperty","Event","bubbles","dispatchEvent","undefined","children","console","warn","deltaY","ctrlKey","deltaMode","prevMidpoint","newMidpoint","prevDistance","newDistance","panX","panY","customElements","define"],"mappings":"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","file":"9525.3fed73a63a3d119c7f6d.9525.js","sourcesContent":["/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\nexport default baseTimes;\n","class Pointer {\r\n    constructor(nativePointer) {\r\n        /** Unique ID for this pointer */\r\n        this.id = -1;\r\n        this.nativePointer = nativePointer;\r\n        this.pageX = nativePointer.pageX;\r\n        this.pageY = nativePointer.pageY;\r\n        this.clientX = nativePointer.clientX;\r\n        this.clientY = nativePointer.clientY;\r\n        if (self.Touch && nativePointer instanceof Touch) {\r\n            this.id = nativePointer.identifier;\r\n        }\r\n        else if (isPointerEvent(nativePointer)) {\r\n            // is PointerEvent\r\n            this.id = nativePointer.pointerId;\r\n        }\r\n    }\r\n    /**\r\n     * Returns an expanded set of Pointers for high-resolution inputs.\r\n     */\r\n    getCoalesced() {\r\n        if ('getCoalescedEvents' in this.nativePointer) {\r\n            return this.nativePointer.getCoalescedEvents().map((p) => new Pointer(p));\r\n        }\r\n        return [this];\r\n    }\r\n}\r\nconst isPointerEvent = (event) => self.PointerEvent && event instanceof PointerEvent;\r\nconst noop = () => { };\r\n/**\r\n * Track pointers across a particular element\r\n */\r\nclass PointerTracker {\r\n    /**\r\n     * Track pointers across a particular element\r\n     *\r\n     * @param element Element to monitor.\r\n     * @param options\r\n     */\r\n    constructor(_element, { start = () => true, move = noop, end = noop, rawUpdates = false, } = {}) {\r\n        this._element = _element;\r\n        /**\r\n         * State of the tracked pointers when they were pressed/touched.\r\n         */\r\n        this.startPointers = [];\r\n        /**\r\n         * Latest state of the tracked pointers. Contains the same number of pointers, and in the same\r\n         * order as this.startPointers.\r\n         */\r\n        this.currentPointers = [];\r\n        /**\r\n         * Listener for mouse/pointer starts.\r\n         *\r\n         * @param event This will only be a MouseEvent if the browser doesn't support pointer events.\r\n         */\r\n        this._pointerStart = (event) => {\r\n            if (event.button !== 0 /* Left */)\r\n                return;\r\n            if (!this._triggerPointerStart(new Pointer(event), event))\r\n                return;\r\n            // Add listeners for additional events.\r\n            // The listeners may already exist, but no harm in adding them again.\r\n            if (isPointerEvent(event)) {\r\n                const capturingElement = event.target && 'setPointerCapture' in event.target\r\n                    ? event.target\r\n                    : this._element;\r\n                capturingElement.setPointerCapture(event.pointerId);\r\n                this._element.addEventListener(this._rawUpdates ? 'pointerrawupdate' : 'pointermove', this._move);\r\n                this._element.addEventListener('pointerup', this._pointerEnd);\r\n                this._element.addEventListener('pointercancel', this._pointerEnd);\r\n            }\r\n            else {\r\n                // MouseEvent\r\n                window.addEventListener('mousemove', this._move);\r\n                window.addEventListener('mouseup', this._pointerEnd);\r\n            }\r\n        };\r\n        /**\r\n         * Listener for touchstart.\r\n         * Only used if the browser doesn't support pointer events.\r\n         */\r\n        this._touchStart = (event) => {\r\n            for (const touch of Array.from(event.changedTouches)) {\r\n                this._triggerPointerStart(new Pointer(touch), event);\r\n            }\r\n        };\r\n        /**\r\n         * Listener for pointer/mouse/touch move events.\r\n         */\r\n        this._move = (event) => {\r\n            const previousPointers = this.currentPointers.slice();\r\n            const changedPointers = 'changedTouches' in event // Shortcut for 'is touch event'.\r\n                ? Array.from(event.changedTouches).map((t) => new Pointer(t))\r\n                : [new Pointer(event)];\r\n            const trackedChangedPointers = [];\r\n            for (const pointer of changedPointers) {\r\n                const index = this.currentPointers.findIndex((p) => p.id === pointer.id);\r\n                if (index === -1)\r\n                    continue; // Not a pointer we're tracking\r\n                trackedChangedPointers.push(pointer);\r\n                this.currentPointers[index] = pointer;\r\n            }\r\n            if (trackedChangedPointers.length === 0)\r\n                return;\r\n            this._moveCallback(previousPointers, trackedChangedPointers, event);\r\n        };\r\n        /**\r\n         * Call the end callback for this pointer.\r\n         *\r\n         * @param pointer Pointer\r\n         * @param event Related event\r\n         */\r\n        this._triggerPointerEnd = (pointer, event) => {\r\n            const index = this.currentPointers.findIndex((p) => p.id === pointer.id);\r\n            // Not a pointer we're interested in?\r\n            if (index === -1)\r\n                return false;\r\n            this.currentPointers.splice(index, 1);\r\n            this.startPointers.splice(index, 1);\r\n            const cancelled = event.type === 'touchcancel' || event.type === 'pointercancel';\r\n            this._endCallback(pointer, event, cancelled);\r\n            return true;\r\n        };\r\n        /**\r\n         * Listener for mouse/pointer ends.\r\n         *\r\n         * @param event This will only be a MouseEvent if the browser doesn't support pointer events.\r\n         */\r\n        this._pointerEnd = (event) => {\r\n            if (!this._triggerPointerEnd(new Pointer(event), event))\r\n                return;\r\n            if (isPointerEvent(event)) {\r\n                if (this.currentPointers.length)\r\n                    return;\r\n                this._element.removeEventListener(this._rawUpdates ? 'pointerrawupdate' : 'pointermove', this._move);\r\n                this._element.removeEventListener('pointerup', this._pointerEnd);\r\n                this._element.removeEventListener('pointercancel', this._pointerEnd);\r\n            }\r\n            else {\r\n                // MouseEvent\r\n                window.removeEventListener('mousemove', this._move);\r\n                window.removeEventListener('mouseup', this._pointerEnd);\r\n            }\r\n        };\r\n        /**\r\n         * Listener for touchend.\r\n         * Only used if the browser doesn't support pointer events.\r\n         */\r\n        this._touchEnd = (event) => {\r\n            for (const touch of Array.from(event.changedTouches)) {\r\n                this._triggerPointerEnd(new Pointer(touch), event);\r\n            }\r\n        };\r\n        this._startCallback = start;\r\n        this._moveCallback = move;\r\n        this._endCallback = end;\r\n        this._rawUpdates = rawUpdates && 'onpointerrawupdate' in window;\r\n        // Add listeners\r\n        if (self.PointerEvent) {\r\n            this._element.addEventListener('pointerdown', this._pointerStart);\r\n        }\r\n        else {\r\n            this._element.addEventListener('mousedown', this._pointerStart);\r\n            this._element.addEventListener('touchstart', this._touchStart);\r\n            this._element.addEventListener('touchmove', this._move);\r\n            this._element.addEventListener('touchend', this._touchEnd);\r\n            this._element.addEventListener('touchcancel', this._touchEnd);\r\n        }\r\n    }\r\n    /**\r\n     * Remove all listeners.\r\n     */\r\n    stop() {\r\n        this._element.removeEventListener('pointerdown', this._pointerStart);\r\n        this._element.removeEventListener('mousedown', this._pointerStart);\r\n        this._element.removeEventListener('touchstart', this._touchStart);\r\n        this._element.removeEventListener('touchmove', this._move);\r\n        this._element.removeEventListener('touchend', this._touchEnd);\r\n        this._element.removeEventListener('touchcancel', this._touchEnd);\r\n        this._element.removeEventListener(this._rawUpdates ? 'pointerrawupdate' : 'pointermove', this._move);\r\n        this._element.removeEventListener('pointerup', this._pointerEnd);\r\n        this._element.removeEventListener('pointercancel', this._pointerEnd);\r\n        window.removeEventListener('mousemove', this._move);\r\n        window.removeEventListener('mouseup', this._pointerEnd);\r\n    }\r\n    /**\r\n     * Call the start callback for this pointer, and track it if the user wants.\r\n     *\r\n     * @param pointer Pointer\r\n     * @param event Related event\r\n     * @returns Whether the pointer is being tracked.\r\n     */\r\n    _triggerPointerStart(pointer, event) {\r\n        if (!this._startCallback(pointer, event))\r\n            return false;\r\n        this.currentPointers.push(pointer);\r\n        this.startPointers.push(pointer);\r\n        return true;\r\n    }\r\n}\n\nexport default PointerTracker;\n","import PointerTracker from 'pointer-tracker';\n\nfunction styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar css = \"pinch-zoom {\\n  display: block;\\n  overflow: hidden;\\n  touch-action: none;\\n  --scale: 1;\\n  --x: 0;\\n  --y: 0;\\n}\\n\\npinch-zoom > * {\\n  transform: translate(var(--x), var(--y)) scale(var(--scale));\\n  transform-origin: 0 0;\\n  will-change: transform;\\n}\\n\";\nstyleInject(css);\n\nconst minScaleAttr = 'min-scale';\r\nfunction getDistance(a, b) {\r\n    if (!b)\r\n        return 0;\r\n    return Math.sqrt((b.clientX - a.clientX) ** 2 + (b.clientY - a.clientY) ** 2);\r\n}\r\nfunction getMidpoint(a, b) {\r\n    if (!b)\r\n        return a;\r\n    return {\r\n        clientX: (a.clientX + b.clientX) / 2,\r\n        clientY: (a.clientY + b.clientY) / 2,\r\n    };\r\n}\r\nfunction getAbsoluteValue(value, max) {\r\n    if (typeof value === 'number')\r\n        return value;\r\n    if (value.trimRight().endsWith('%')) {\r\n        return max * parseFloat(value) / 100;\r\n    }\r\n    return parseFloat(value);\r\n}\r\n// I'd rather use DOMMatrix/DOMPoint here, but the browser support isn't good enough.\r\n// Given that, better to use something everything supports.\r\nlet cachedSvg;\r\nfunction getSVG() {\r\n    return cachedSvg || (cachedSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg'));\r\n}\r\nfunction createMatrix() {\r\n    return getSVG().createSVGMatrix();\r\n}\r\nfunction createPoint() {\r\n    return getSVG().createSVGPoint();\r\n}\r\nconst MIN_SCALE = 0.01;\r\nclass PinchZoom extends HTMLElement {\r\n    constructor() {\r\n        super();\r\n        // Current transform.\r\n        this._transform = createMatrix();\r\n        // Watch for children changes.\r\n        // Note this won't fire for initial contents,\r\n        // so _stageElChange is also called in connectedCallback.\r\n        new MutationObserver(() => this._stageElChange())\r\n            .observe(this, { childList: true });\r\n        // Watch for pointers\r\n        const pointerTracker = new PointerTracker(this, {\r\n            start: (pointer, event) => {\r\n                // We only want to track 2 pointers at most\r\n                if (pointerTracker.currentPointers.length === 2 || !this._positioningEl)\r\n                    return false;\r\n                event.preventDefault();\r\n                return true;\r\n            },\r\n            move: (previousPointers) => {\r\n                this._onPointerMove(previousPointers, pointerTracker.currentPointers);\r\n            },\r\n        });\r\n        this.addEventListener('wheel', event => this._onWheel(event));\r\n    }\r\n    static get observedAttributes() { return [minScaleAttr]; }\r\n    attributeChangedCallback(name, oldValue, newValue) {\r\n        if (name === minScaleAttr) {\r\n            if (this.scale < this.minScale) {\r\n                this.setTransform({ scale: this.minScale });\r\n            }\r\n        }\r\n    }\r\n    get minScale() {\r\n        const attrValue = this.getAttribute(minScaleAttr);\r\n        if (!attrValue)\r\n            return MIN_SCALE;\r\n        const value = parseFloat(attrValue);\r\n        if (Number.isFinite(value))\r\n            return Math.max(MIN_SCALE, value);\r\n        return MIN_SCALE;\r\n    }\r\n    set minScale(value) {\r\n        this.setAttribute(minScaleAttr, String(value));\r\n    }\r\n    connectedCallback() {\r\n        this._stageElChange();\r\n    }\r\n    get x() {\r\n        return this._transform.e;\r\n    }\r\n    get y() {\r\n        return this._transform.f;\r\n    }\r\n    get scale() {\r\n        return this._transform.a;\r\n    }\r\n    /**\r\n     * Change the scale, adjusting x/y by a given transform origin.\r\n     */\r\n    scaleTo(scale, opts = {}) {\r\n        let { originX = 0, originY = 0, } = opts;\r\n        const { relativeTo = 'content', allowChangeEvent = false, } = opts;\r\n        const relativeToEl = (relativeTo === 'content' ? this._positioningEl : this);\r\n        // No content element? Fall back to just setting scale\r\n        if (!relativeToEl || !this._positioningEl) {\r\n            this.setTransform({ scale, allowChangeEvent });\r\n            return;\r\n        }\r\n        const rect = relativeToEl.getBoundingClientRect();\r\n        originX = getAbsoluteValue(originX, rect.width);\r\n        originY = getAbsoluteValue(originY, rect.height);\r\n        if (relativeTo === 'content') {\r\n            originX += this.x;\r\n            originY += this.y;\r\n        }\r\n        else {\r\n            const currentRect = this._positioningEl.getBoundingClientRect();\r\n            originX -= currentRect.left;\r\n            originY -= currentRect.top;\r\n        }\r\n        this._applyChange({\r\n            allowChangeEvent,\r\n            originX,\r\n            originY,\r\n            scaleDiff: scale / this.scale,\r\n        });\r\n    }\r\n    /**\r\n     * Update the stage with a given scale/x/y.\r\n     */\r\n    setTransform(opts = {}) {\r\n        const { scale = this.scale, allowChangeEvent = false, } = opts;\r\n        let { x = this.x, y = this.y, } = opts;\r\n        // If we don't have an element to position, just set the value as given.\r\n        // We'll check bounds later.\r\n        if (!this._positioningEl) {\r\n            this._updateTransform(scale, x, y, allowChangeEvent);\r\n            return;\r\n        }\r\n        // Get current layout\r\n        const thisBounds = this.getBoundingClientRect();\r\n        const positioningElBounds = this._positioningEl.getBoundingClientRect();\r\n        // Not displayed. May be disconnected or display:none.\r\n        // Just take the values, and we'll check bounds later.\r\n        if (!thisBounds.width || !thisBounds.height) {\r\n            this._updateTransform(scale, x, y, allowChangeEvent);\r\n            return;\r\n        }\r\n        // Create points for _positioningEl.\r\n        let topLeft = createPoint();\r\n        topLeft.x = positioningElBounds.left - thisBounds.left;\r\n        topLeft.y = positioningElBounds.top - thisBounds.top;\r\n        let bottomRight = createPoint();\r\n        bottomRight.x = positioningElBounds.width + topLeft.x;\r\n        bottomRight.y = positioningElBounds.height + topLeft.y;\r\n        // Calculate the intended position of _positioningEl.\r\n        const matrix = createMatrix()\r\n            .translate(x, y)\r\n            .scale(scale)\r\n            // Undo current transform\r\n            .multiply(this._transform.inverse());\r\n        topLeft = topLeft.matrixTransform(matrix);\r\n        bottomRight = bottomRight.matrixTransform(matrix);\r\n        // Ensure _positioningEl can't move beyond out-of-bounds.\r\n        // Correct for x\r\n        if (topLeft.x > thisBounds.width) {\r\n            x += thisBounds.width - topLeft.x;\r\n        }\r\n        else if (bottomRight.x < 0) {\r\n            x += -bottomRight.x;\r\n        }\r\n        // Correct for y\r\n        if (topLeft.y > thisBounds.height) {\r\n            y += thisBounds.height - topLeft.y;\r\n        }\r\n        else if (bottomRight.y < 0) {\r\n            y += -bottomRight.y;\r\n        }\r\n        this._updateTransform(scale, x, y, allowChangeEvent);\r\n    }\r\n    /**\r\n     * Update transform values without checking bounds. This is only called in setTransform.\r\n     */\r\n    _updateTransform(scale, x, y, allowChangeEvent) {\r\n        // Avoid scaling to zero\r\n        if (scale < this.minScale)\r\n            return;\r\n        // Return if there's no change\r\n        if (scale === this.scale &&\r\n            x === this.x &&\r\n            y === this.y)\r\n            return;\r\n        this._transform.e = x;\r\n        this._transform.f = y;\r\n        this._transform.d = this._transform.a = scale;\r\n        this.style.setProperty('--x', this.x + 'px');\r\n        this.style.setProperty('--y', this.y + 'px');\r\n        this.style.setProperty('--scale', this.scale + '');\r\n        if (allowChangeEvent) {\r\n            const event = new Event('change', { bubbles: true });\r\n            this.dispatchEvent(event);\r\n        }\r\n    }\r\n    /**\r\n     * Called when the direct children of this element change.\r\n     * Until we have have shadow dom support across the board, we\r\n     * require a single element to be the child of <pinch-zoom>, and\r\n     * that's the element we pan/scale.\r\n     */\r\n    _stageElChange() {\r\n        this._positioningEl = undefined;\r\n        if (this.children.length === 0)\r\n            return;\r\n        this._positioningEl = this.children[0];\r\n        if (this.children.length > 1) {\r\n            console.warn('<pinch-zoom> must not have more than one child.');\r\n        }\r\n        // Do a bounds check\r\n        this.setTransform({ allowChangeEvent: true });\r\n    }\r\n    _onWheel(event) {\r\n        if (!this._positioningEl)\r\n            return;\r\n        event.preventDefault();\r\n        const currentRect = this._positioningEl.getBoundingClientRect();\r\n        let { deltaY } = event;\r\n        const { ctrlKey, deltaMode } = event;\r\n        if (deltaMode === 1) { // 1 is \"lines\", 0 is \"pixels\"\r\n            // Firefox uses \"lines\" for some types of mouse\r\n            deltaY *= 15;\r\n        }\r\n        // ctrlKey is true when pinch-zooming on a trackpad.\r\n        const divisor = ctrlKey ? 100 : 300;\r\n        const scaleDiff = 1 - deltaY / divisor;\r\n        this._applyChange({\r\n            scaleDiff,\r\n            originX: event.clientX - currentRect.left,\r\n            originY: event.clientY - currentRect.top,\r\n            allowChangeEvent: true,\r\n        });\r\n    }\r\n    _onPointerMove(previousPointers, currentPointers) {\r\n        if (!this._positioningEl)\r\n            return;\r\n        // Combine next points with previous points\r\n        const currentRect = this._positioningEl.getBoundingClientRect();\r\n        // For calculating panning movement\r\n        const prevMidpoint = getMidpoint(previousPointers[0], previousPointers[1]);\r\n        const newMidpoint = getMidpoint(currentPointers[0], currentPointers[1]);\r\n        // Midpoint within the element\r\n        const originX = prevMidpoint.clientX - currentRect.left;\r\n        const originY = prevMidpoint.clientY - currentRect.top;\r\n        // Calculate the desired change in scale\r\n        const prevDistance = getDistance(previousPointers[0], previousPointers[1]);\r\n        const newDistance = getDistance(currentPointers[0], currentPointers[1]);\r\n        const scaleDiff = prevDistance ? newDistance / prevDistance : 1;\r\n        this._applyChange({\r\n            originX, originY, scaleDiff,\r\n            panX: newMidpoint.clientX - prevMidpoint.clientX,\r\n            panY: newMidpoint.clientY - prevMidpoint.clientY,\r\n            allowChangeEvent: true,\r\n        });\r\n    }\r\n    /** Transform the view & fire a change event */\r\n    _applyChange(opts = {}) {\r\n        const { panX = 0, panY = 0, originX = 0, originY = 0, scaleDiff = 1, allowChangeEvent = false, } = opts;\r\n        const matrix = createMatrix()\r\n            // Translate according to panning.\r\n            .translate(panX, panY)\r\n            // Scale about the origin.\r\n            .translate(originX, originY)\r\n            // Apply current translate\r\n            .translate(this.x, this.y)\r\n            .scale(scaleDiff)\r\n            .translate(-originX, -originY)\r\n            // Apply current scale.\r\n            .scale(this.scale);\r\n        // Convert the transform into basic translate & scale.\r\n        this.setTransform({\r\n            allowChangeEvent,\r\n            scale: matrix.a,\r\n            x: matrix.e,\r\n            y: matrix.f,\r\n        });\r\n    }\r\n}\n\ncustomElements.define('pinch-zoom', PinchZoom);\n\nexport default PinchZoom;\n"],"sourceRoot":""}