{"version":3,"sources":["webpack://pinafore/./node_modules/emoji-picker-element/database.js"],"names":["assertNonEmptyString","str","Error","assertNumber","number","STORE_EMOJI","STORE_KEYVALUE","STORE_FAVORITES","INDEX_TOKENS","INDEX_COUNT","INDEX_GROUP_AND_ORDER","KEY_ETAG","KEY_URL","KEY_PREFERRED_SKINTONE","MODE_READONLY","MODE_READWRITE","INDEX_SKIN_UNICODE","uniqEmoji","emojis","arr","func","set","Set","res","item","key","has","add","push","uniqBy","_","unicode","openReqs","databaseCache","onCloseListeners","handleOpenOrDeleteReq","resolve","reject","req","onerror","error","onblocked","onsuccess","result","async","createDatabase","dbName","db","Promise","indexedDB","open","onupgradeneeded","e","oldVersion","createObjectStore","name","keyPath","indexes","store","indexName","multiEntry","Object","entries","createIndex","undefined","initialMigration","onclose","closeDatabase","dbPromise","storeName","readOnlyOrReadWrite","cb","tx","transaction","objectStore","map","oncomplete","close","listeners","listener","irregularEmoticons","extractTokens","split","word","match","toLowerCase","replace","filter","Boolean","normalizeTokens","length","callStore","method","target","getIDB","getAllIDB","findCommonMembers","arrays","uniqByFunc","shortestArray","array","minItem","i","minBy","results","some","findIndex","loadData","emojiData","url","eTag","transformedData","annotation","emoticon","group","order","shortcodes","skins","tags","emoji","version","tokens","flat","sort","skinTones","skinUnicodes","skinVersions","tone","transformEmojiData","emojiStore","metaStore","oldETag","oldUrl","oldKeys","todo","checkFetched","delete","data","put","onFetched","getEmojiBySearchQuery","query","intermediateResults","onDone","a","b","token","range","IDBKeyRange","bound","only","index","getEmojiByShortcode","shortcode","predicate","includes","lastKey","processNextBatch","getAll","lowerBound","doFullDatabaseScanForSingleResult","get","requiredKeys","customEmojiIndex","customEmojis","isArray","Array","firstItemIsFaulty","assertCustomEmojis","sortByName","all","searchTrie","itemToTokens","Map","currentMap","char","charAt","nextMap","valuesAtCoda","exact","queue","entriesSortedByKey","shift","value","trie","searchByExactMatch","searchByPrefix","shortcodeToEmoji","nameToEmoji","customEmoji","search","byShortcode","byName","cleanEmoji","len","warnETag","console","warn","arguments","requiredKeys$1","assertStatus","response","dataSource","Math","floor","status","getETagAndData","fetch","headers","json","assertEmojiData","jsonChecksum","object","inBuffer","binary","buf","ArrayBuffer","Uint8Array","charCodeAt","binaryStringToArrayBuffer","JSON","stringify","outBinString","buffer","bytes","byteLength","String","fromCharCode","arrayBufferToBinaryString","crypto","subtle","digest","btoa","checkForUpdates","getETag","eTagAndData","hasData","locale","this","_dbName","_db","_lazyUpdate","_custom","_clear","bind","_ready","_init","addOnCloseListener","isEmpty","loadDataForFirstTime","ready","getEmojiByGroup","custom","unicodeOrName","getEmojiByUnicode","skinTone","limit","favoritesStore","openCursor","cursor","addResult","continue","primaryKey","getTopFavoriteEmoji","err","_shutdown","deleteDatabase"],"mappings":"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","file":"398.ecadc9e31803e5519c2e.398.js","sourcesContent":["function assertNonEmptyString (str) {\n  if (typeof str !== 'string' || !str) {\n    throw new Error('expected a non-empty string, got: ' + str)\n  }\n}\n\nfunction assertNumber (number) {\n  if (typeof number !== 'number') {\n    throw new Error('expected a number, got: ' + number)\n  }\n}\n\nconst DB_VERSION_CURRENT = 1;\nconst DB_VERSION_INITIAL = 1;\nconst STORE_EMOJI = 'emoji';\nconst STORE_KEYVALUE = 'keyvalue';\nconst STORE_FAVORITES = 'favorites';\nconst FIELD_TOKENS = 'tokens';\nconst INDEX_TOKENS = 'tokens';\nconst FIELD_UNICODE = 'unicode';\nconst INDEX_COUNT = 'count';\nconst FIELD_GROUP = 'group';\nconst FIELD_ORDER = 'order';\nconst INDEX_GROUP_AND_ORDER = 'group-order';\nconst KEY_ETAG = 'eTag';\nconst KEY_URL = 'url';\nconst KEY_PREFERRED_SKINTONE = 'skinTone';\nconst MODE_READONLY = 'readonly';\nconst MODE_READWRITE = 'readwrite';\nconst INDEX_SKIN_UNICODE = 'skinUnicodes';\nconst FIELD_SKIN_UNICODE = 'skinUnicodes';\n\nconst DEFAULT_DATA_SOURCE = 'https://cdn.jsdelivr.net/npm/emoji-picker-element-data@^1/en/emojibase/data.json';\nconst DEFAULT_LOCALE = 'en';\n\n// like lodash's uniqBy but much smaller\nfunction uniqBy (arr, func) {\n  const set = new Set();\n  const res = [];\n  for (const item of arr) {\n    const key = func(item);\n    if (!set.has(key)) {\n      set.add(key);\n      res.push(item);\n    }\n  }\n  return res\n}\n\nfunction uniqEmoji (emojis) {\n  return uniqBy(emojis, _ => _.unicode)\n}\n\nfunction initialMigration (db) {\n  function createObjectStore (name, keyPath, indexes) {\n    const store = keyPath\n      ? db.createObjectStore(name, { keyPath })\n      : db.createObjectStore(name);\n    if (indexes) {\n      for (const [indexName, [keyPath, multiEntry]] of Object.entries(indexes)) {\n        store.createIndex(indexName, keyPath, { multiEntry });\n      }\n    }\n    return store\n  }\n\n  createObjectStore(STORE_KEYVALUE);\n  createObjectStore(STORE_EMOJI, /* keyPath */ FIELD_UNICODE, {\n    [INDEX_TOKENS]: [FIELD_TOKENS, /* multiEntry */ true],\n    [INDEX_GROUP_AND_ORDER]: [[FIELD_GROUP, FIELD_ORDER]],\n    [INDEX_SKIN_UNICODE]: [FIELD_SKIN_UNICODE, /* multiEntry */ true]\n  });\n  createObjectStore(STORE_FAVORITES, undefined, {\n    [INDEX_COUNT]: ['']\n  });\n}\n\nconst openReqs = {};\nconst databaseCache = {};\nconst onCloseListeners = {};\n\nfunction handleOpenOrDeleteReq (resolve, reject, req) {\n  // These things are almost impossible to test with fakeIndexedDB sadly\n  /* istanbul ignore next */\n  req.onerror = () => reject(req.error);\n  /* istanbul ignore next */\n  req.onblocked = () => reject(new Error('IDB blocked'));\n  req.onsuccess = () => resolve(req.result);\n}\n\nasync function createDatabase (dbName) {\n  const db = await new Promise((resolve, reject) => {\n    const req = indexedDB.open(dbName, DB_VERSION_CURRENT);\n    openReqs[dbName] = req;\n    req.onupgradeneeded = e => {\n      // Technically there is only one version, so we don't need this `if` check\n      // But if an old version of the JS is in another browser tab\n      // and it gets upgraded in the future and we have a new DB version, well...\n      // better safe than sorry.\n      /* istanbul ignore else */\n      if (e.oldVersion < DB_VERSION_INITIAL) {\n        initialMigration(req.result);\n      }\n    };\n    handleOpenOrDeleteReq(resolve, reject, req);\n  });\n  // Handle abnormal closes, e.g. \"delete database\" in chrome dev tools.\n  // No need for removeEventListener, because once the DB can no longer\n  // fire \"close\" events, it will auto-GC.\n  // Unfortunately cannot test in fakeIndexedDB: https://github.com/dumbmatter/fakeIndexedDB/issues/50\n  /* istanbul ignore next */\n  db.onclose = () => closeDatabase(dbName);\n  return db\n}\n\nfunction openDatabase (dbName) {\n  if (!databaseCache[dbName]) {\n    databaseCache[dbName] = createDatabase(dbName);\n  }\n  return databaseCache[dbName]\n}\n\nfunction dbPromise (db, storeName, readOnlyOrReadWrite, cb) {\n  return new Promise((resolve, reject) => {\n    const tx = db.transaction(storeName, readOnlyOrReadWrite);\n    const store = typeof storeName === 'string'\n      ? tx.objectStore(storeName)\n      : storeName.map(name => tx.objectStore(name));\n    let res;\n    cb(store, (result) => {\n      res = result;\n    });\n\n    tx.oncomplete = () => resolve(res);\n    /* istanbul ignore next */\n    tx.onerror = () => reject(tx.error);\n  })\n}\n\nfunction closeDatabase (dbName) {\n  // close any open requests\n  const req = openReqs[dbName];\n  const db = req && req.result;\n  if (db) {\n    db.close();\n    const listeners = onCloseListeners[dbName];\n    /* istanbul ignore else */\n    if (listeners) {\n      for (const listener of listeners) {\n        listener();\n      }\n    }\n  }\n  delete openReqs[dbName];\n  delete databaseCache[dbName];\n  delete onCloseListeners[dbName];\n}\n\nfunction deleteDatabase (dbName) {\n  return new Promise((resolve, reject) => {\n    // close any open requests\n    closeDatabase(dbName);\n    const req = indexedDB.deleteDatabase(dbName);\n    handleOpenOrDeleteReq(resolve, reject, req);\n  })\n}\n\n// The \"close\" event occurs during an abnormal shutdown, e.g. a user clearing their browser data.\n// However, it doesn't occur with the normal \"close\" event, so we handle that separately.\n// https://www.w3.org/TR/IndexedDB/#close-a-database-connection\nfunction addOnCloseListener (dbName, listener) {\n  let listeners = onCloseListeners[dbName];\n  if (!listeners) {\n    listeners = onCloseListeners[dbName] = [];\n  }\n  listeners.push(listener);\n}\n\n// list of emoticons that don't match a simple \\W+ regex\n// extracted using:\n// require('emojibase-data/en/data.json').map(_ => _.emoticon).filter(Boolean).filter(_ => !/^\\W+$/.test(_))\nconst irregularEmoticons = new Set([\n  ':D', 'xD', \":'D\", 'o:)',\n  ':x', ':p', ';p', 'xp',\n  ':l', ':z', ':j', '8D',\n  'xo', '8)', ':B', ':o',\n  ':s', \":'o\", 'Dx', 'x(',\n  'D:', ':c', '>0)', ':3',\n  '</3', '<3', '\\\\m/', ':E',\n  '8#'\n]);\n\nfunction extractTokens (str) {\n  return str\n    .split(/[\\s_]+/)\n    .map(word => {\n      if (!word.match(/\\w/) || irregularEmoticons.has(word)) {\n        // for pure emoticons like :) or :-), just leave them as-is\n        return word.toLowerCase()\n      }\n\n      return word\n        .replace(/[)(:,]/g, '')\n        .replace(/’/g, \"'\")\n        .toLowerCase()\n    }).filter(Boolean)\n}\n\nconst MIN_SEARCH_TEXT_LENGTH = 2;\n\n// This is an extra step in addition to extractTokens(). The difference here is that we expect\n// the input to have already been run through extractTokens(). This is useful for cases like\n// emoticons, where we don't want to do any tokenization (because it makes no sense to split up\n// \">:)\" by the colon) but we do want to lowercase it to have consistent search results, so that\n// the user can type ':P' or ':p' and still get the same result.\nfunction normalizeTokens (str) {\n  return str\n    .filter(Boolean)\n    .map(_ => _.toLowerCase())\n    .filter(_ => _.length >= MIN_SEARCH_TEXT_LENGTH)\n}\n\n// Transform emoji data for storage in IDB\nfunction transformEmojiData (emojiData) {\n  const res = emojiData.map(({ annotation, emoticon, group, order, shortcodes, skins, tags, emoji, version }) => {\n    const tokens = [...new Set(\n      normalizeTokens([\n        ...(shortcodes || []).map(extractTokens).flat(),\n        ...tags.map(extractTokens).flat(),\n        ...extractTokens(annotation),\n        emoticon\n      ])\n    )].sort();\n    const res = {\n      annotation,\n      group,\n      order,\n      tags,\n      tokens,\n      unicode: emoji,\n      version\n    };\n    if (emoticon) {\n      res.emoticon = emoticon;\n    }\n    if (shortcodes) {\n      res.shortcodes = shortcodes;\n    }\n    if (skins) {\n      res.skinTones = [];\n      res.skinUnicodes = [];\n      res.skinVersions = [];\n      for (const { tone, emoji, version } of skins) {\n        res.skinTones.push(tone);\n        res.skinUnicodes.push(emoji);\n        res.skinVersions.push(version);\n      }\n    }\n    return res\n  });\n  return res\n}\n\n// helper functions that help compress the code better\n\nfunction callStore (store, method, key, cb) {\n  store[method](key).onsuccess = e => (cb && cb(e.target.result));\n}\n\nfunction getIDB (store, key, cb) {\n  callStore(store, 'get', key, cb);\n}\n\nfunction getAllIDB (store, key, cb) {\n  callStore(store, 'getAll', key, cb);\n}\n\nfunction getAllKeysIDB (store, key, cb) {\n  callStore(store, 'getAllKeys', key, cb);\n}\n\n// like lodash's minBy\nfunction minBy (array, func) {\n  let minItem = array[0];\n  for (let i = 1; i < array.length; i++) {\n    const item = array[i];\n    if (func(minItem) > func(item)) {\n      minItem = item;\n    }\n  }\n  return minItem\n}\n\n// return an array of results representing all items that are found in each one of the arrays\n\nfunction findCommonMembers (arrays, uniqByFunc) {\n  const shortestArray = minBy(arrays, _ => _.length);\n  const results = [];\n  for (const item of shortestArray) {\n    // if this item is included in every array in the intermediate results, add it to the final results\n    if (!arrays.some(array => array.findIndex(_ => uniqByFunc(_) === uniqByFunc(item)) === -1)) {\n      results.push(item);\n    }\n  }\n  return results\n}\n\nasync function isEmpty (db) {\n  return !(await get(db, STORE_KEYVALUE, KEY_URL))\n}\n\nasync function hasData (db, url, eTag) {\n  const [oldETag, oldUrl] = await Promise.all([KEY_ETAG, KEY_URL]\n    .map(key => get(db, STORE_KEYVALUE, key)));\n  return (oldETag === eTag && oldUrl === url)\n}\n\nasync function doFullDatabaseScanForSingleResult (db, predicate) {\n  // This batching algorithm is just a perf improvement over a basic\n  // cursor. The BATCH_SIZE is an estimate of what would give the best\n  // perf for doing a full DB scan (worst case).\n  //\n  // Mini-benchmark for determining the best batch size:\n  //\n  // PERF=1 yarn build:rollup && yarn test:adhoc\n  //\n  // (async () => {\n  //   performance.mark('start')\n  //   await $('emoji-picker').database.getEmojiByShortcode('doesnotexist')\n  //   performance.measure('total', 'start')\n  //   console.log(performance.getEntriesByName('total').slice(-1)[0].duration)\n  // })()\n  const BATCH_SIZE = 50; // Typically around 150ms for 6x slowdown in Chrome for above benchmark\n  return dbPromise(db, STORE_EMOJI, MODE_READONLY, (emojiStore, cb) => {\n    let lastKey;\n\n    const processNextBatch = () => {\n      emojiStore.getAll(lastKey && IDBKeyRange.lowerBound(lastKey, true), BATCH_SIZE).onsuccess = e => {\n        const results = e.target.result;\n        for (const result of results) {\n          lastKey = result.unicode;\n          if (predicate(result)) {\n            return cb(result)\n          }\n        }\n        if (results.length < BATCH_SIZE) {\n          return cb()\n        }\n        processNextBatch();\n      };\n    };\n    processNextBatch();\n  })\n}\n\nasync function loadData (db, emojiData, url, eTag) {\n  try {\n    const transformedData = transformEmojiData(emojiData);\n    await dbPromise(db, [STORE_EMOJI, STORE_KEYVALUE], MODE_READWRITE, ([emojiStore, metaStore]) => {\n      let oldETag;\n      let oldUrl;\n      let oldKeys;\n      let todo = 0;\n\n      function checkFetched () {\n        if (++todo === 3) {\n          onFetched();\n        }\n      }\n\n      function onFetched () {\n        if (oldETag === eTag && oldUrl === url) {\n          // check again within the transaction to guard against concurrency, e.g. multiple browser tabs\n          return\n        }\n        // delete old data\n        for (const key of oldKeys) {\n          emojiStore.delete(key);\n        }\n        // insert new data\n        for (const data of transformedData) {\n          emojiStore.put(data);\n        }\n        metaStore.put(eTag, KEY_ETAG);\n        metaStore.put(url, KEY_URL);\n      }\n\n      getIDB(metaStore, KEY_ETAG, result => {\n        oldETag = result;\n        checkFetched();\n      });\n\n      getIDB(metaStore, KEY_URL, result => {\n        oldUrl = result;\n        checkFetched();\n      });\n\n      getAllKeysIDB(emojiStore, undefined, result => {\n        oldKeys = result;\n        checkFetched();\n      });\n    });\n  } finally {\n  }\n}\n\nasync function getEmojiByGroup (db, group) {\n  return dbPromise(db, STORE_EMOJI, MODE_READONLY, (emojiStore, cb) => {\n    const range = IDBKeyRange.bound([group, 0], [group + 1, 0], false, true);\n    getAllIDB(emojiStore.index(INDEX_GROUP_AND_ORDER), range, cb);\n  })\n}\n\nasync function getEmojiBySearchQuery (db, query) {\n  const tokens = normalizeTokens(extractTokens(query));\n\n  if (!tokens.length) {\n    return []\n  }\n\n  return dbPromise(db, STORE_EMOJI, MODE_READONLY, (emojiStore, cb) => {\n    // get all results that contain all tokens (i.e. an AND query)\n    const intermediateResults = [];\n\n    const checkDone = () => {\n      if (intermediateResults.length === tokens.length) {\n        onDone();\n      }\n    };\n\n    const onDone = () => {\n      const results = findCommonMembers(intermediateResults, _ => _.unicode);\n      cb(results.sort((a, b) => a.order < b.order ? -1 : 1));\n    };\n\n    for (let i = 0; i < tokens.length; i++) {\n      const token = tokens[i];\n      const range = i === tokens.length - 1\n        ? IDBKeyRange.bound(token, token + '\\uffff', false, true) // treat last token as a prefix search\n        : IDBKeyRange.only(token); // treat all other tokens as an exact match\n      getAllIDB(emojiStore.index(INDEX_TOKENS), range, result => {\n        intermediateResults.push(result);\n        checkDone();\n      });\n    }\n  })\n}\n\n// This could have been implemented as an IDB index on shortcodes, but it seemed wasteful to do that\n// when we can already query by tokens and this will give us what we're looking for 99.9% of the time\nasync function getEmojiByShortcode (db, shortcode) {\n  const emojis = await getEmojiBySearchQuery(db, shortcode);\n\n  // In very rare cases (e.g. the shortcode \"v\" as in \"v for victory\"), we cannot search because\n  // there are no usable tokens (too short in this case). In that case, we have to do an inefficient\n  // full-database scan, which I believe is an acceptable tradeoff for not having to have an extra\n  // index on shortcodes.\n\n  if (!emojis.length) {\n    const predicate = _ => ((_.shortcodes || []).includes(shortcode.toLowerCase()));\n    return (await doFullDatabaseScanForSingleResult(db, predicate)) || null\n  }\n\n  return emojis.filter(_ => {\n    const lowerShortcodes = (_.shortcodes || []).map(_ => _.toLowerCase());\n    return lowerShortcodes.includes(shortcode.toLowerCase())\n  })[0] || null\n}\n\nasync function getEmojiByUnicode (db, unicode) {\n  return dbPromise(db, STORE_EMOJI, MODE_READONLY, (emojiStore, cb) => (\n    getIDB(emojiStore, unicode, result => {\n      if (result) {\n        return cb(result)\n      }\n      getIDB(emojiStore.index(INDEX_SKIN_UNICODE), unicode, result => cb(result || null));\n    })\n  ))\n}\n\nfunction get (db, storeName, key) {\n  return dbPromise(db, storeName, MODE_READONLY, (store, cb) => (\n    getIDB(store, key, cb)\n  ))\n}\n\nfunction set (db, storeName, key, value) {\n  return dbPromise(db, storeName, MODE_READWRITE, (store) => (\n    store.put(value, key)\n  ))\n}\n\nfunction incrementFavoriteEmojiCount (db, unicode) {\n  return dbPromise(db, STORE_FAVORITES, MODE_READWRITE, (store) => {\n    getIDB(store, unicode, result => (\n      store.put((result || 0) + 1, unicode)\n    ));\n  })\n}\n\nfunction getTopFavoriteEmoji (db, customEmojiIndex, limit) {\n  if (limit === 0) {\n    return []\n  }\n  return dbPromise(db, [STORE_FAVORITES, STORE_EMOJI], MODE_READONLY, ([favoritesStore, emojiStore], cb) => {\n    const results = [];\n    favoritesStore.index(INDEX_COUNT).openCursor(undefined, 'prev').onsuccess = e => {\n      const cursor = e.target.result;\n      if (!cursor) { // no more results\n        return cb(results)\n      }\n\n      function addResult (result) {\n        results.push(result);\n        if (results.length === limit) {\n          return cb(results) // done, reached the limit\n        }\n        cursor.continue();\n      }\n\n      const unicodeOrName = cursor.primaryKey;\n      const custom = customEmojiIndex.byName(unicodeOrName);\n      if (custom) {\n        return addResult(custom)\n      }\n      // This could be done in parallel (i.e. make the cursor and the get()s parallelized),\n      // but my testing suggests it's not actually faster.\n      getIDB(emojiStore, unicodeOrName, emoji => {\n        if (emoji) {\n          return addResult(emoji)\n        }\n        // emoji not found somehow, ignore (may happen if custom emoji change)\n        cursor.continue();\n      });\n    };\n  })\n}\n\n// @rollup/plugin-strip doesn't strip console.logs properly\n\nfunction log () {\n}\n\nfunction warn () {\n  /* istanbul ignore if */\n  {\n    console.warn(...arguments);\n  }\n}\n\n// trie data structure for prefix searches\n// loosely based on https://github.com/nolanlawson/substring-trie\n\nconst CODA_MARKER = ''; // marks the end of the string\n\nfunction trie (arr, itemToTokens) {\n  const map = new Map();\n  for (const item of arr) {\n    const tokens = itemToTokens(item);\n    for (const token of tokens) {\n      let currentMap = map;\n      for (let i = 0; i < token.length; i++) {\n        const char = token.charAt(i);\n        let nextMap = currentMap.get(char);\n        if (!nextMap) {\n          nextMap = new Map();\n          currentMap.set(char, nextMap);\n        }\n        currentMap = nextMap;\n      }\n      let valuesAtCoda = currentMap.get(CODA_MARKER);\n      if (!valuesAtCoda) {\n        valuesAtCoda = [];\n        currentMap.set(CODA_MARKER, valuesAtCoda);\n      }\n      valuesAtCoda.push(item);\n    }\n  }\n\n  const search = (query, exact) => {\n    let currentMap = map;\n    for (let i = 0; i < query.length; i++) {\n      const char = query.charAt(i);\n      const nextMap = currentMap.get(char);\n      if (nextMap) {\n        currentMap = nextMap;\n      } else {\n        return []\n      }\n    }\n\n    if (exact) {\n      const results = currentMap.get(CODA_MARKER);\n      return results || []\n    }\n\n    const results = [];\n    // traverse\n    const queue = [currentMap];\n    while (queue.length) {\n      const currentMap = queue.shift();\n      const entriesSortedByKey = [...currentMap.entries()].sort((a, b) => a[0] < b[0] ? -1 : 1);\n      for (const [key, value] of entriesSortedByKey) {\n        if (key === CODA_MARKER) { // CODA_MARKER always comes first; it's the empty string\n          results.push(...value);\n        } else {\n          queue.push(value);\n        }\n      }\n    }\n    return results\n  };\n\n  return search\n}\n\nconst requiredKeys = [\n  'name',\n  'url'\n];\n\nfunction assertCustomEmojis (customEmojis) {\n  const isArray = customEmojis && Array.isArray(customEmojis);\n  const firstItemIsFaulty = isArray &&\n    customEmojis.length &&\n    (!customEmojis[0] || requiredKeys.some(key => !(key in customEmojis[0])));\n  if (!isArray || firstItemIsFaulty) {\n    throw new Error('Custom emojis are in the wrong format')\n  }\n}\n\nfunction customEmojiIndex (customEmojis) {\n  assertCustomEmojis(customEmojis);\n\n  const sortByName = (a, b) => a.name.toLowerCase() < b.name.toLowerCase() ? -1 : 1;\n\n  //\n  // all()\n  //\n  const all = customEmojis.sort(sortByName);\n\n  //\n  // search()\n  //\n  const emojiToTokens = emoji => (\n    [...new Set((emoji.shortcodes || []).map(shortcode => extractTokens(shortcode)).flat())]\n  );\n  const searchTrie = trie(customEmojis, emojiToTokens);\n  const searchByExactMatch = _ => searchTrie(_, true);\n  const searchByPrefix = _ => searchTrie(_, false);\n\n  // Search by query for custom emoji. Similar to how we do this in IDB, the last token\n  // is treated as a prefix search, but every other one is treated as an exact match.\n  // Then we AND the results together\n  const search = query => {\n    const tokens = extractTokens(query);\n    const intermediateResults = tokens.map((token, i) => (\n      (i < tokens.length - 1 ? searchByExactMatch : searchByPrefix)(token)\n    ));\n    return findCommonMembers(intermediateResults, _ => _.name).sort(sortByName)\n  };\n\n  //\n  // byShortcode, byName\n  //\n  const shortcodeToEmoji = new Map();\n  const nameToEmoji = new Map();\n  for (const customEmoji of customEmojis) {\n    nameToEmoji.set(customEmoji.name.toLowerCase(), customEmoji);\n    for (const shortcode of (customEmoji.shortcodes || [])) {\n      shortcodeToEmoji.set(shortcode.toLowerCase(), customEmoji);\n    }\n  }\n\n  const byShortcode = shortcode => shortcodeToEmoji.get(shortcode.toLowerCase());\n  const byName = name => nameToEmoji.get(name.toLowerCase());\n\n  return {\n    all,\n    search,\n    byShortcode,\n    byName\n  }\n}\n\n// remove some internal implementation details, i.e. the \"tokens\" array on the emoji object\n// essentially, convert the emoji from the version stored in IDB to the version used in-memory\nfunction cleanEmoji (emoji) {\n  if (!emoji) {\n    return emoji\n  }\n  delete emoji.tokens;\n  if (emoji.skinTones) {\n    const len = emoji.skinTones.length;\n    emoji.skins = Array(len);\n    for (let i = 0; i < len; i++) {\n      emoji.skins[i] = {\n        tone: emoji.skinTones[i],\n        unicode: emoji.skinUnicodes[i],\n        version: emoji.skinVersions[i]\n      };\n    }\n    delete emoji.skinTones;\n    delete emoji.skinUnicodes;\n    delete emoji.skinVersions;\n  }\n  return emoji\n}\n\nfunction warnETag (eTag) {\n  if (!eTag) {\n    warn('emoji-picker-element is more efficient if the dataSource server exposes an ETag header.');\n  }\n}\n\nconst requiredKeys$1 = [\n  'annotation',\n  'emoji',\n  'group',\n  'order',\n  'tags',\n  'version'\n];\n\nfunction assertEmojiData (emojiData) {\n  if (!emojiData ||\n    !Array.isArray(emojiData) ||\n    !emojiData[0] ||\n    (typeof emojiData[0] !== 'object') ||\n    requiredKeys$1.some(key => (!(key in emojiData[0])))) {\n    throw new Error('Emoji data is in the wrong format')\n  }\n}\n\nfunction assertStatus (response, dataSource) {\n  if (Math.floor(response.status / 100) !== 2) {\n    throw new Error('Failed to fetch: ' + dataSource + ':  ' + response.status)\n  }\n}\n\nasync function getETag (dataSource) {\n  const response = await fetch(dataSource, { method: 'HEAD' });\n  assertStatus(response, dataSource);\n  const eTag = response.headers.get('etag');\n  warnETag(eTag);\n  return eTag\n}\n\nasync function getETagAndData (dataSource) {\n  const response = await fetch(dataSource);\n  assertStatus(response, dataSource);\n  const eTag = response.headers.get('etag');\n  warnETag(eTag);\n  const emojiData = await response.json();\n  assertEmojiData(emojiData);\n  return [eTag, emojiData]\n}\n\n// TODO: including these in blob-util.ts causes typedoc to generate docs for them,\n/**\n * Convert an `ArrayBuffer` to a binary string.\n *\n * Example:\n *\n * ```js\n * var myString = blobUtil.arrayBufferToBinaryString(arrayBuff)\n * ```\n *\n * @param buffer - array buffer\n * @returns binary string\n */\nfunction arrayBufferToBinaryString(buffer) {\n    var binary = '';\n    var bytes = new Uint8Array(buffer);\n    var length = bytes.byteLength;\n    var i = -1;\n    while (++i < length) {\n        binary += String.fromCharCode(bytes[i]);\n    }\n    return binary;\n}\n/**\n * Convert a binary string to an `ArrayBuffer`.\n *\n * ```js\n * var myBuffer = blobUtil.binaryStringToArrayBuffer(binaryString)\n * ```\n *\n * @param binary - binary string\n * @returns array buffer\n */\nfunction binaryStringToArrayBuffer(binary) {\n    var length = binary.length;\n    var buf = new ArrayBuffer(length);\n    var arr = new Uint8Array(buf);\n    var i = -1;\n    while (++i < length) {\n        arr[i] = binary.charCodeAt(i);\n    }\n    return buf;\n}\n\n// generate a checksum based on the stringified JSON\nasync function jsonChecksum (object) {\n  const inString = JSON.stringify(object);\n  const inBuffer = binaryStringToArrayBuffer(inString);\n  // this does not need to be cryptographically secure, SHA-1 is fine\n  const outBuffer = await crypto.subtle.digest('SHA-1', inBuffer);\n  const outBinString = arrayBufferToBinaryString(outBuffer);\n  const res = btoa(outBinString);\n  return res\n}\n\nasync function checkForUpdates (db, dataSource) {\n  // just do a simple HEAD request first to see if the eTags match\n  let emojiData;\n  let eTag = await getETag(dataSource);\n  if (!eTag) { // work around lack of ETag/Access-Control-Expose-Headers\n    const eTagAndData = await getETagAndData(dataSource);\n    eTag = eTagAndData[0];\n    emojiData = eTagAndData[1];\n    if (!eTag) {\n      eTag = await jsonChecksum(emojiData);\n    }\n  }\n  if (await hasData(db, dataSource, eTag)) ; else {\n    if (!emojiData) {\n      const eTagAndData = await getETagAndData(dataSource);\n      emojiData = eTagAndData[1];\n    }\n    await loadData(db, emojiData, dataSource, eTag);\n  }\n}\n\nasync function loadDataForFirstTime (db, dataSource) {\n  let [eTag, emojiData] = await getETagAndData(dataSource);\n  if (!eTag) {\n    // Handle lack of support for ETag or Access-Control-Expose-Headers\n    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Expose-Headers#Browser_compatibility\n    eTag = await jsonChecksum(emojiData);\n  }\n\n  await loadData(db, emojiData, dataSource, eTag);\n}\n\nclass Database {\n  constructor ({ dataSource = DEFAULT_DATA_SOURCE, locale = DEFAULT_LOCALE, customEmoji = [] } = {}) {\n    this.dataSource = dataSource;\n    this.locale = locale;\n    this._dbName = `emoji-picker-element-${this.locale}`;\n    this._db = undefined;\n    this._lazyUpdate = undefined;\n    this._custom = customEmojiIndex(customEmoji);\n\n    this._clear = this._clear.bind(this);\n    this._ready = this._init();\n  }\n\n  async _init () {\n    const db = this._db = await openDatabase(this._dbName);\n\n    addOnCloseListener(this._dbName, this._clear);\n    const dataSource = this.dataSource;\n    const empty = await isEmpty(db);\n\n    if (empty) {\n      await loadDataForFirstTime(db, dataSource);\n    } else { // offline-first - do an update asynchronously\n      this._lazyUpdate = checkForUpdates(db, dataSource);\n    }\n  }\n\n  async ready () {\n    if (!this._ready) {\n      this._ready = this._init();\n    }\n    return this._ready\n  }\n\n  async getEmojiByGroup (group) {\n    assertNumber(group);\n    await this.ready();\n    return uniqEmoji(await getEmojiByGroup(this._db, group)).map(cleanEmoji)\n  }\n\n  async getEmojiBySearchQuery (query) {\n    assertNonEmptyString(query);\n    await this.ready();\n    const customs = this._custom.search(query);\n    const natives = uniqEmoji(await getEmojiBySearchQuery(this._db, query)).map(cleanEmoji);\n    return [\n      ...customs,\n      ...natives\n    ]\n  }\n\n  async getEmojiByShortcode (shortcode) {\n    assertNonEmptyString(shortcode);\n    await this.ready();\n    const custom = this._custom.byShortcode(shortcode);\n    if (custom) {\n      return custom\n    }\n    return cleanEmoji(await getEmojiByShortcode(this._db, shortcode))\n  }\n\n  async getEmojiByUnicodeOrName (unicodeOrName) {\n    assertNonEmptyString(unicodeOrName);\n    await this.ready();\n    const custom = this._custom.byName(unicodeOrName);\n    if (custom) {\n      return custom\n    }\n    return cleanEmoji(await getEmojiByUnicode(this._db, unicodeOrName))\n  }\n\n  async getPreferredSkinTone () {\n    await this.ready();\n    return (await get(this._db, STORE_KEYVALUE, KEY_PREFERRED_SKINTONE)) || 0\n  }\n\n  async setPreferredSkinTone (skinTone) {\n    assertNumber(skinTone);\n    await this.ready();\n    return set(this._db, STORE_KEYVALUE, KEY_PREFERRED_SKINTONE, skinTone)\n  }\n\n  async incrementFavoriteEmojiCount (unicodeOrName) {\n    assertNonEmptyString(unicodeOrName);\n    await this.ready();\n    return incrementFavoriteEmojiCount(this._db, unicodeOrName)\n  }\n\n  async getTopFavoriteEmoji (limit) {\n    assertNumber(limit);\n    await this.ready();\n    return (await getTopFavoriteEmoji(this._db, this._custom, limit)).map(cleanEmoji)\n  }\n\n  set customEmoji (customEmojis) {\n    this._custom = customEmojiIndex(customEmojis);\n  }\n\n  get customEmoji () {\n    return this._custom.all\n  }\n\n  async _shutdown () {\n    await this.ready(); // reopen if we've already been closed/deleted\n    try {\n      await this._lazyUpdate; // allow any lazy updates to process before closing/deleting\n    } catch (err) { /* ignore network errors (offline-first) */ }\n    return !!this._db // return true if we need to actually run the close/delete logic\n  }\n\n  // clear references to IDB, e.g. during a close event\n  _clear () {\n    log('_clear database', this._dbName);\n    // We don't need to call removeEventListener or remove the manual \"close\" listeners.\n    // The memory leak tests prove this is unnecessary. It's because:\n    // 1) IDBDatabases that can no longer fire \"close\" automatically have listeners GCed\n    // 2) we clear the manual close listeners in databaseLifecycle.js.\n    this._db = this._ready = this._lazyUpdate = undefined;\n  }\n\n  async close () {\n    if (await this._shutdown()) {\n      await closeDatabase(this._dbName);\n    }\n  }\n\n  async delete () {\n    if (await this._shutdown()) {\n      await deleteDatabase(this._dbName);\n    }\n  }\n}\n\nexport default Database;\n"],"sourceRoot":""}