{"version":3,"sources":["webpack://pinafore/./src/routes/_actions/addStatusOrNotification.js","webpack://pinafore/./src/routes/_actions/emoji.js","webpack://pinafore/./src/routes/_api/emoji.js","webpack://pinafore/./src/routes/_actions/media.js","webpack://pinafore/./src/routes/_api/media.js","webpack://pinafore/./src/routes/_utils/asyncModules/importDatabase.js","webpack://pinafore/./src/routes/_database/asyncDatabase.js","webpack://pinafore/./src/routes/_utils/arrays.js","webpack://pinafore/./src/routes/_utils/createSearchIndexFromStatusOrNotification.js","webpack://pinafore/./src/routes/_utils/computeFilterContextsForStatusOrNotification.js","webpack://pinafore/./src/routes/_utils/sync.js","webpack://pinafore/./src/routes/_utils/timelineItemToSummary.js"],"names":["removeDuplicates","instanceName","timelineName","updates","existingItemIds","timelineItemSummaries","Set","map","_","id","getExistingItemIdsSet","filter","update","has","async","insertUpdatesIntoTimeline","length","itemSummariesToAdd","JSON","parse","stringify","item","newItemSummariesToAdd","timelineItemSummariesToAdd","isValidStatusForThread","thread","itemSummariesToAddIdSet","threadIdSet","focusedStatusId","split","focusedStatusIdx","findIndex","status","in_reply_to_id","insertUpdatesIntoThreads","threads","timelineNames","Object","keys","validUpdates","lazilyProcessFreshUpdates","freshUpdates","slice","Promise","all","s","processFreshUpdates","addStatusOrNotification","newStatusOrNotification","addStatusesOrNotifications","newStatusesOrNotifications","Date","now","syncEmojiForInstance","syncMethod","loggedInInstances","store","accessToken","access_token","url","timeout","getCustomEmoji","database","emoji","customEmoji","isEqual","updateCustomEmojiForInstance","setupCustomEmojiForInstance","insertEmoji","realm","emojiText","unicode","name","composeSelectionStart","idx","oldText","newText","substring","text","doMediaUpload","file","currentInstance","uploadingMedia","response","composeMedia","Error","push","data","description","media","e","console","error","message","deleteMedia","i","splice","contentWarningShown","contentWarning","sensitive","uploadMedia","formData","FormData","append","putMediaMetadata","mediaId","focus","join","asyncDatabase","Proxy","get","obj","prop","args","apply","mergeArrays","leftArray","rightArray","comparator","leftIndex","rightIndex","merged","left","right","comparison","concat","res","len","arguments","arg","Array","isArray","domParser","computeFilterContextsForStatusOrNotification","statusOrNotification","contextsToRegex","searchIndex","originalStatus","reblog","DOMParser","searchContent","spoiler_text","content","poll","options","option","title","replace","parseFromString","documentElement","textContent","createSearchIndexFromStatusOrNotification","entries","context","regex","test","undefined","cacheFirstUpdateAfter","networkFetcher","dbFetcher","dbUpdater","stateSetter","networkPromise","dbResponse","err","fetchAndUpdatePromise","then","networkResponse","cacheFirstUpdateOnlyIfNotInCache","TimelineSummary","this","accountId","account","replyId","reblogId","type","unexpiredInstanceFilterRegexes","filterContexts","timelineItemToSummary"],"mappings":"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","file":"2943.d92a2651b5d516a69f9d.2943.js","sourcesContent":["import { mark, stop } from '../_utils/marks'\nimport { store } from '../_store/store'\nimport uniqBy from 'lodash-es/uniqBy'\nimport isEqual from 'lodash-es/isEqual'\nimport { database } from '../_database/database'\nimport { concat } from '../_utils/arrays'\nimport { scheduleIdleTask } from '../_utils/scheduleIdleTask'\nimport { timelineItemToSummary } from '../_utils/timelineItemToSummary'\n\nfunction getExistingItemIdsSet (instanceName, timelineName) {\n  const timelineItemSummaries = store.getForTimeline(instanceName, timelineName, 'timelineItemSummaries') || []\n  return new Set(timelineItemSummaries.map(_ => _.id))\n}\n\nfunction removeDuplicates (instanceName, timelineName, updates) {\n  // remove duplicates, including duplicates due to reblogs\n  const existingItemIds = getExistingItemIdsSet(instanceName, timelineName)\n  return updates.filter(update => !existingItemIds.has(update.id))\n}\n\nasync function insertUpdatesIntoTimeline (instanceName, timelineName, updates) {\n  updates = removeDuplicates(instanceName, timelineName, updates)\n\n  if (!updates.length) {\n    return\n  }\n\n  await database.insertTimelineItems(instanceName, timelineName, updates)\n\n  const itemSummariesToAdd = store.getForTimeline(instanceName, timelineName, 'timelineItemSummariesToAdd') || []\n  console.log('itemSummariesToAdd', JSON.parse(JSON.stringify(itemSummariesToAdd)))\n  console.log('updates.map(timelineItemToSummary)', JSON.parse(JSON.stringify(updates.map(timelineItemToSummary))))\n  console.log('concat(itemSummariesToAdd, updates.map(timelineItemToSummary))',\n    JSON.parse(JSON.stringify(concat(itemSummariesToAdd, updates.map(item => timelineItemToSummary(item, instanceName))))))\n  const newItemSummariesToAdd = uniqBy(\n    concat(itemSummariesToAdd, updates.map(item => timelineItemToSummary(item, instanceName))),\n    _ => _.id\n  )\n  if (!isEqual(itemSummariesToAdd, newItemSummariesToAdd)) {\n    console.log('adding ', (newItemSummariesToAdd.length - itemSummariesToAdd.length),\n      'items to timelineItemSummariesToAdd for timeline', timelineName)\n    store.setForTimeline(instanceName, timelineName, { timelineItemSummariesToAdd: newItemSummariesToAdd })\n  }\n}\n\nfunction isValidStatusForThread (thread, timelineName, itemSummariesToAdd) {\n  const itemSummariesToAddIdSet = new Set(itemSummariesToAdd.map(_ => _.id))\n  const threadIdSet = new Set(thread.map(_ => _.id))\n  const focusedStatusId = timelineName.split('/')[1] // e.g. \"status/123456\"\n  const focusedStatusIdx = thread.findIndex(_ => _.id === focusedStatusId)\n  return status => {\n    const repliedToStatusIdx = thread.findIndex(_ => _.id === status.in_reply_to_id)\n    return (\n      // A reply to an ancestor status is not valid for this thread, but for the focused status\n      // itself or any of its descendents, it is valid.\n      repliedToStatusIdx >= focusedStatusIdx &&\n      // Not a duplicate\n      !threadIdSet.has(status.id) &&\n      // Not already about to be added\n      !itemSummariesToAddIdSet.has(status.id)\n    )\n  }\n}\n\nasync function insertUpdatesIntoThreads (instanceName, updates) {\n  if (!updates.length) {\n    return\n  }\n\n  const threads = store.getThreads(instanceName)\n  const timelineNames = Object.keys(threads)\n  for (const timelineName of timelineNames) {\n    const thread = threads[timelineName]\n\n    const itemSummariesToAdd = store.getForTimeline(instanceName, timelineName, 'timelineItemSummariesToAdd') || []\n    const validUpdates = updates.filter(isValidStatusForThread(thread, timelineName, itemSummariesToAdd))\n    if (!validUpdates.length) {\n      continue\n    }\n    const newItemSummariesToAdd = uniqBy(\n      concat(itemSummariesToAdd, validUpdates.map(item => timelineItemToSummary(item, instanceName))),\n      _ => _.id\n    )\n    if (!isEqual(itemSummariesToAdd, newItemSummariesToAdd)) {\n      console.log('adding ', (newItemSummariesToAdd.length - itemSummariesToAdd.length),\n        'items to timelineItemSummariesToAdd for thread', timelineName)\n      store.setForTimeline(instanceName, timelineName, { timelineItemSummariesToAdd: newItemSummariesToAdd })\n    }\n  }\n}\n\nasync function processFreshUpdates (instanceName, timelineName) {\n  mark('processFreshUpdates')\n  const freshUpdates = store.getForTimeline(instanceName, timelineName, 'freshUpdates')\n  if (freshUpdates && freshUpdates.length) {\n    const updates = freshUpdates.slice()\n    store.setForTimeline(instanceName, timelineName, { freshUpdates: [] })\n\n    await Promise.all([\n      insertUpdatesIntoTimeline(instanceName, timelineName, updates),\n      insertUpdatesIntoThreads(instanceName, updates.filter(status => status.in_reply_to_id))\n    ])\n  }\n  stop('processFreshUpdates')\n}\n\nfunction lazilyProcessFreshUpdates (instanceName, timelineName) {\n  scheduleIdleTask(() => {\n    /* no await */ processFreshUpdates(instanceName, timelineName)\n  })\n}\n\nexport function addStatusOrNotification (instanceName, timelineName, newStatusOrNotification) {\n  addStatusesOrNotifications(instanceName, timelineName, [newStatusOrNotification])\n}\n\nexport function addStatusesOrNotifications (instanceName, timelineName, newStatusesOrNotifications) {\n  console.log('addStatusesOrNotifications', Date.now())\n  let freshUpdates = store.getForTimeline(instanceName, timelineName, 'freshUpdates') || []\n  freshUpdates = concat(freshUpdates, newStatusesOrNotifications)\n  freshUpdates = uniqBy(freshUpdates, _ => _.id)\n  store.setForTimeline(instanceName, timelineName, { freshUpdates: freshUpdates })\n  lazilyProcessFreshUpdates(instanceName, timelineName)\n}\n","import {\n  cacheFirstUpdateAfter,\n  cacheFirstUpdateOnlyIfNotInCache\n} from '../_utils/sync'\nimport { database } from '../_database/database'\nimport { getCustomEmoji } from '../_api/emoji'\nimport { store } from '../_store/store'\nimport isEqual from 'lodash-es/isEqual'\n\nasync function syncEmojiForInstance (instanceName, syncMethod) {\n  await syncMethod(\n    () => {\n      const { loggedInInstances } = store.get()\n      const accessToken = loggedInInstances[instanceName].access_token\n      return getCustomEmoji(instanceName, accessToken)\n    },\n    () => database.getCustomEmoji(instanceName),\n    emoji => database.setCustomEmoji(instanceName, emoji),\n    emoji => {\n      const { customEmoji } = store.get()\n      if (!isEqual(customEmoji[instanceName], emoji)) { // avoid triggering updates if nothing's changed\n        customEmoji[instanceName] = emoji\n        store.set({ customEmoji })\n      }\n    }\n  )\n}\n\nexport async function updateCustomEmojiForInstance (instanceName) {\n  await syncEmojiForInstance(instanceName, cacheFirstUpdateAfter)\n}\n\nexport async function setupCustomEmojiForInstance (instanceName) {\n  await syncEmojiForInstance(instanceName, cacheFirstUpdateOnlyIfNotInCache)\n}\n\nexport function insertEmoji (realm, emoji) {\n  const emojiText = emoji.unicode || `:${emoji.name}:`\n  const { composeSelectionStart } = store.get()\n  const idx = composeSelectionStart || 0\n  const oldText = store.getComposeData(realm, 'text') || ''\n  const pre = oldText.substring(0, idx)\n  const post = oldText.substring(idx)\n  const newText = `${pre}${emojiText} ${post}`\n  store.setComposeData(realm, { text: newText })\n}\n","import { auth, basename } from './utils'\nimport { DEFAULT_TIMEOUT, get } from '../_utils/ajax'\n\nexport function getCustomEmoji (instanceName, accessToken) {\n  const url = `${basename(instanceName)}/api/v1/custom_emojis`\n  return get(url, auth(accessToken), { timeout: DEFAULT_TIMEOUT })\n}\n","import { store } from '../_store/store'\nimport { uploadMedia } from '../_api/media'\nimport { toast } from '../_components/toast/toast'\nimport { scheduleIdleTask } from '../_utils/scheduleIdleTask'\nimport { formatIntl } from '../_utils/formatIntl'\nimport { database } from '../_database/database'\n\nexport async function doMediaUpload (realm, file) {\n  const { currentInstance, accessToken } = store.get()\n  store.set({ uploadingMedia: true })\n  try {\n    const response = await uploadMedia(currentInstance, accessToken, file)\n    const composeMedia = store.getComposeData(realm, 'media') || []\n    if (composeMedia.length === 4) {\n      throw new Error('Only 4 media max are allowed')\n    }\n    await database.setCachedMediaFile(response.id, file)\n    composeMedia.push({\n      data: response,\n      file: { name: file.name },\n      description: ''\n    })\n    store.setComposeData(realm, {\n      media: composeMedia\n    })\n    scheduleIdleTask(() => store.save())\n  } catch (e) {\n    console.error(e)\n    /* no await */ toast.say(formatIntl([\"Failed to upload media: \",[\"error\"]], { error: (e.message || '') }))\n  } finally {\n    store.set({ uploadingMedia: false })\n  }\n}\n\nexport function deleteMedia (realm, i) {\n  const composeMedia = store.getComposeData(realm, 'media')\n  composeMedia.splice(i, 1)\n\n  store.setComposeData(realm, {\n    media: composeMedia\n  })\n  if (!composeMedia.length) {\n    const contentWarningShown = store.getComposeData(realm, 'contentWarningShown')\n    const contentWarning = store.getComposeData(realm, 'contentWarning')\n    store.setComposeData(realm, {\n      sensitive: contentWarningShown && contentWarning // reset sensitive if the last media is deleted\n    })\n  }\n  scheduleIdleTask(() => store.save())\n}\n","import { auth, basename } from './utils'\nimport { post, put, MEDIA_WRITE_TIMEOUT, WRITE_TIMEOUT } from '../_utils/ajax'\n\nexport async function uploadMedia (instanceName, accessToken, file, description) {\n  const formData = new FormData()\n  formData.append('file', file)\n  if (description) {\n    formData.append('description', description)\n  }\n  const url = `${basename(instanceName)}/api/v1/media`\n  return post(url, formData, auth(accessToken), { timeout: MEDIA_WRITE_TIMEOUT })\n}\n\nexport async function putMediaMetadata (instanceName, accessToken, mediaId, description, focus) {\n  const url = `${basename(instanceName)}/api/v1/media/${mediaId}`\n  return put(url, { description, focus: (focus && focus.join(',')) }, auth(accessToken), { timeout: WRITE_TIMEOUT })\n}\n","export const importDatabase = () => import(\n  '../../_database/databaseApis.js'\n)\n","// All database functions are asynchronous, so we can just proxy here and\n// put an async import of the database, to avoid including it in the main bundle\n// (which doesn't need to run when the user isn't logged in).\n\nimport { importDatabase } from '../_utils/asyncModules/importDatabase.js'\n\nconst handler = {\n  get: function (obj, prop) {\n    return async function (...args) {\n      if (!obj[prop]) {\n        const database = await importDatabase()\n        obj[prop] = database[prop]\n      }\n      return obj[prop].apply(null, args)\n    }\n  }\n}\n\nexport const asyncDatabase = new Proxy({}, handler)\n","// Merge two arrays, using the given comparator\nexport function mergeArrays (leftArray, rightArray, comparator) {\n  let leftIndex = 0\n  let rightIndex = 0\n  const merged = []\n  while (leftIndex < leftArray.length || rightIndex < rightArray.length) {\n    if (leftIndex === leftArray.length) {\n      merged.push(rightArray[rightIndex])\n      rightIndex++\n      continue\n    }\n    if (rightIndex === rightArray.length) {\n      merged.push(leftArray[leftIndex])\n      leftIndex++\n      continue\n    }\n    const left = leftArray[leftIndex]\n    const right = rightArray[rightIndex]\n    const comparison = comparator(right, left)\n    if (comparison === 0) {\n      merged.push(left)\n      rightIndex++\n      leftIndex++\n    } else if (comparison > 0) {\n      merged.push(right)\n      rightIndex++\n    } else {\n      merged.push(left)\n      leftIndex++\n    }\n  }\n  return merged\n}\n\nexport function concat () {\n  let res = []\n  for (let i = 0, len = arguments.length; i < len; i++) {\n    const arg = arguments[i]\n    if (Array.isArray(arg)) {\n      res = res.concat(arguments[i])\n    } else {\n      res.push(arguments[i])\n    }\n  }\n  return res\n}\n","let domParser\n\n// copy-pasta'd from\n// https://github.com/tootsuite/mastodon/blob/2ff01f7/app/javascript/mastodon/actions/importer/normalizer.js#L58-L75\nexport const createSearchIndexFromStatusOrNotification = statusOrNotification => {\n  const status = statusOrNotification.status || statusOrNotification // status on a notification\n  const originalStatus = status.reblog || status\n  domParser = domParser || new DOMParser()\n  const spoilerText = originalStatus.spoiler_text || ''\n  const searchContent = ([spoilerText, originalStatus.content]\n    .concat(\n      (originalStatus.poll && originalStatus.poll.options)\n        ? originalStatus.poll.options.map(option => option.title)\n        : []\n    ))\n    .join('\\n\\n').replace(/<br\\s*\\/?>/g, '\\n').replace(/<\\/p><p>/g, '\\n\\n')\n  return domParser.parseFromString(searchContent, 'text/html').documentElement.textContent\n}\n","import { createSearchIndexFromStatusOrNotification } from './createSearchIndexFromStatusOrNotification'\n\nexport function computeFilterContextsForStatusOrNotification (statusOrNotification, contextsToRegex) {\n  if (!contextsToRegex || !Object.keys(contextsToRegex).length) {\n    // avoid computing the search index, just bail out\n    return undefined\n  }\n  // the searchIndex is really just a string of text\n  const searchIndex = createSearchIndexFromStatusOrNotification(statusOrNotification)\n  const res = Object.entries(contextsToRegex)\n    .filter(([context, regex]) => regex.test(searchIndex))\n    .map(([context]) => context)\n\n  // return undefined instead of a new array to reduce memory usage of TimelineSummary\n  return res.length ? res : undefined\n}\n","// Hit both the cache and the network, setting state for the cached version first,\n// then the network version (as it's assumed to be fresher). Also update the db afterwards.\nexport async function cacheFirstUpdateAfter (networkFetcher, dbFetcher, dbUpdater, stateSetter) {\n  const networkPromise = networkFetcher() // kick off network request immediately\n  let dbResponse\n  try {\n    dbResponse = await dbFetcher()\n  } catch (err) {\n    console.error('ignored DB error', err)\n  } finally {\n    if (dbResponse) {\n      stateSetter(dbResponse)\n    }\n    const fetchAndUpdatePromise = networkPromise.then(networkResponse => {\n      /* no await */ dbUpdater(networkResponse)\n      stateSetter(networkResponse)\n    })\n    if (!dbResponse) { // no cached result available, await the network\n      await fetchAndUpdatePromise\n    }\n  }\n}\n\n// Try the cache first. If we get a hit, set the state and do nothing. If we don't get a cache hit,\n// then go to the network, update the cache, and set the state.\nexport async function cacheFirstUpdateOnlyIfNotInCache (networkFetcher, dbFetcher, dbUpdater, stateSetter) {\n  let dbResponse\n  try {\n    dbResponse = await dbFetcher()\n  } catch (err) {\n    console.error('ignored DB error', err)\n  }\n  if (dbResponse) {\n    stateSetter(dbResponse)\n  } else {\n    const networkResponse = await networkFetcher()\n    /* no await */ dbUpdater(networkResponse)\n    stateSetter(networkResponse)\n  }\n}\n","import { computeFilterContextsForStatusOrNotification } from './computeFilterContextsForStatusOrNotification'\nimport { store } from '../_store/store'\n\nclass TimelineSummary {\n  constructor (item, instanceName) {\n    this.id = item.id\n    this.accountId = item.account.id\n    this.replyId = (item.in_reply_to_id) || undefined\n    this.reblogId = (item.reblog && item.reblog.id) || undefined\n    this.type = item.type || undefined\n\n    // This is admittedly a weird place to do the filtering logic. But there are a few reasons to do it here:\n    // 1. Avoid computing html-to-text (expensive) for users who don't have any filters (probably most users)\n    // 2. Avoiding keeping the entire html-to-text in memory at all times for all summaries\n    // 3. Filters probably change infrequently. When they do, we can just update the summaries\n    const { unexpiredInstanceFilterRegexes } = store.get()\n    const contextsToRegex = unexpiredInstanceFilterRegexes[instanceName]\n    this.filterContexts = computeFilterContextsForStatusOrNotification(item, contextsToRegex)\n  }\n}\n\nexport function timelineItemToSummary (item, instanceName) {\n  return new TimelineSummary(item, instanceName)\n}\n"],"sourceRoot":""}