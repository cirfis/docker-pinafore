{"version":3,"sources":["webpack://pinafore/./src/routes/_components/virtualList/virtualListStore.js","webpack://pinafore/./src/routes/_utils/reselect.js","webpack://pinafore/./src/routes/_utils/RealmStore.js"],"names":["VirtualListStore","RealmStore","state","super","prefix","realms","this","get","key","getAllKeys","startsWith","delete","set","virtualListStore","computeForRealm","compute","items","scrollTop","itemHeights","offsetHeight","showHeader","headerHeight","listOffset","effectiveScrollTop","renderBuffer","visibleItems","totalOffset","len","length","i","height","currentOffset","push","offset","index","s","store","outputKey","inputKey","prevValue","nextValue","count","countKey","input","isEqual","reselect","sum","heightWithoutFooter","showFooter","footerHeight","visibleItem","window","__virtualListStore","init","maxSize","_batches","realm","currentRealm","obj","Object","assign","defaultValue","realmData","subKey","value","realmBatches","batch","updatedKeys","keys","otherKey"],"mappings":"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","file":"1257.8a90bc15118fa0270806.1257.js","sourcesContent":["import { mark, stop } from '../../_utils/marks'\nimport { RealmStore } from '../../_utils/RealmStore'\nimport { reselect } from '../../_utils/reselect'\n\nconst RENDER_BUFFER_FACTOR = 2.5\n\nclass VirtualListStore extends RealmStore {\n  constructor (state) {\n    super(state, /* maxSize */ 10)\n  }\n\n  // TODO: this is hacky\n  clearRealmByPrefix (prefix) {\n    const { realms } = this.get()\n    if (!realms) {\n      return\n    }\n    for (const key of realms.getAllKeys()) {\n      if (key.startsWith(prefix)) {\n        console.log('deleted realm', key)\n        realms.delete(key)\n      }\n    }\n    this.set({ realms })\n  }\n}\n\nconst virtualListStore = new VirtualListStore()\n\nvirtualListStore.computeForRealm('items', null)\nvirtualListStore.computeForRealm('showFooter', false)\nvirtualListStore.computeForRealm('footerHeight', 0)\nvirtualListStore.computeForRealm('showHeader', false)\nvirtualListStore.computeForRealm('headerHeight', 0)\nvirtualListStore.computeForRealm('scrollTop', 0)\nvirtualListStore.computeForRealm('scrollHeight', 0)\nvirtualListStore.computeForRealm('offsetHeight', 0)\nvirtualListStore.computeForRealm('listOffset', 0)\nvirtualListStore.computeForRealm('itemHeights', {})\n\nvirtualListStore.compute('rawVisibleItems',\n  ['items', 'scrollTop', 'itemHeights', 'offsetHeight', 'showHeader', 'headerHeight', 'listOffset'],\n  (items, scrollTop, itemHeights, offsetHeight, showHeader, headerHeight, listOffset) => {\n    if (process.browser && process.env.NODE_ENV !== 'production') {\n      window.rawVisibleItemsComputed = (window.rawVisibleItemsComputed || 0) + 1\n    }\n    mark('compute visibleItems')\n    if (!items) {\n      return null\n    }\n    const effectiveScrollTop = scrollTop - listOffset\n    const renderBuffer = RENDER_BUFFER_FACTOR * offsetHeight\n    const visibleItems = []\n    let totalOffset = showHeader ? headerHeight : 0\n    const len = items.length\n    let i = -1\n    while (++i < len) {\n      const key = items[i]\n      const height = itemHeights[key] || 0\n      const currentOffset = totalOffset\n      totalOffset += height\n      const isAboveViewport = (currentOffset < effectiveScrollTop)\n      if (isAboveViewport) {\n        if ((effectiveScrollTop - height - renderBuffer) > currentOffset) {\n          continue // above the area we want to render\n        }\n      } else {\n        if (currentOffset > (effectiveScrollTop + offsetHeight + renderBuffer)) {\n          break // below the area we want to render\n        }\n      }\n      visibleItems.push({\n        offset: currentOffset,\n        key: key,\n        index: i\n      })\n    }\n    stop('compute visibleItems')\n    return visibleItems\n  })\n\nreselect(virtualListStore, 'visibleItems', 'rawVisibleItems')\n\nvirtualListStore.compute('heightWithoutFooter',\n  ['items', 'itemHeights', 'showHeader', 'headerHeight'],\n  (items, itemHeights, showHeader, headerHeight) => {\n    if (!items) {\n      return 0\n    }\n    let sum = showHeader ? headerHeight : 0\n    let i = -1\n    const len = items.length\n    while (++i < len) {\n      sum += itemHeights[items[i]] || 0\n    }\n    return sum\n  })\n\nvirtualListStore.compute('height',\n  ['heightWithoutFooter', 'showFooter', 'footerHeight'],\n  (heightWithoutFooter, showFooter, footerHeight) => {\n    return showFooter ? (heightWithoutFooter + footerHeight) : heightWithoutFooter\n  })\n\nvirtualListStore.compute('length', ['items'], (items) => items ? items.length : 0)\n\nvirtualListStore.compute('allVisibleItemsHaveHeight',\n  ['visibleItems', 'itemHeights'],\n  (visibleItems, itemHeights) => {\n    if (!visibleItems) {\n      return false\n    }\n    for (const visibleItem of visibleItems) {\n      if (!itemHeights[visibleItem.key]) {\n        return false\n      }\n    }\n    return true\n  })\n\nif (process.browser) {\n  window.__virtualListStore = virtualListStore // for debugging\n\n  if (process.env.NODE_ENV !== 'production') { // for extra debugging\n    virtualListStore.on('state', ({ changed }) => {\n      if (changed.visibleItems) {\n        window.visibleItemsChangedCount = (window.visibleItemsChangedCount || 0) + 1\n      }\n      if (changed.rawVisibleItems) {\n        window.rawVisibleItemsChangedCount = (window.rawVisibleItemsChangedCount || 0) + 1\n      }\n    })\n  }\n}\n\nexport {\n  virtualListStore\n}\n","// Avoid re-renders by caching the most recent value of an array\n// or an object, using an approach similar to https://github.com/reactjs/reselect.\n// This avoids the issue where Svelte may keep re-rendering because it doesn't\n// know if an object/array has changed or not.\n\nimport isEqual from 'lodash-es/isEqual'\n\nif (process.browser && process.env.NODE_ENV !== 'production') {\n  window.reselectStats = {}\n}\n\nexport function reselect (store, outputKey, inputKey) {\n  let prevValue\n  let nextValue\n  let count = 0\n  const countKey = `${outputKey}_reselectCount`\n\n  store.compute(countKey, [inputKey], input => {\n    if (process.browser && process.env.NODE_ENV !== 'production') {\n      window.reselectStats[inputKey] = window.reselectStats[inputKey] || { numInputChanges: 0, numOutputChanges: 0 }\n      window.reselectStats[inputKey].numInputChanges++\n    }\n    if (!isEqual(prevValue, input)) {\n      nextValue = input\n      count++\n    }\n    return count\n  })\n\n  store.compute(outputKey, [countKey], () => {\n    if (process.browser && process.env.NODE_ENV !== 'production') {\n      window.reselectStats[inputKey].numOutputChanges++\n    }\n    prevValue = nextValue\n    nextValue = null\n    return prevValue\n  })\n}\n","// A store where you can divide data into \"realms\" that are backed with an LRU cache.\n// Each realm has self-contained data that you can set with setForRealm() and compute\n// with computeForRealm(). The maxSize determines how many realms to keep in the LRU cache.\nimport { Store } from 'svelte/store.js'\nimport { QuickLRU } from '../_thirdparty/quick-lru/quick-lru'\nimport { mark, stop } from './marks'\nimport { requestPostAnimationFrame } from './requestPostAnimationFrame'\n\nexport class RealmStore extends Store {\n  constructor (init, maxSize) {\n    super(init)\n    this.set({ realms: new QuickLRU({ maxSize: maxSize }) })\n    this._batches = {}\n  }\n\n  setCurrentRealm (realm) {\n    this.set({ currentRealm: realm })\n  }\n\n  setForRealm (obj) {\n    const { currentRealm, realms } = this.get()\n    realms.set(currentRealm, Object.assign(realms.get(currentRealm) || {}, obj))\n    this.set({ realms: realms })\n  }\n\n  computeForRealm (key, defaultValue) {\n    this.compute(key,\n      ['realms', 'currentRealm'],\n      (realms, currentRealm) => {\n        const realmData = realms.get(currentRealm)\n        return (realmData && realmData[key]) || defaultValue\n      })\n  }\n\n  /*\n   * Update several values at once in a realm, assuming the key points\n   * to a plain old javascript object.\n   */\n  batchUpdateForRealm (key, subKey, value) {\n    const { currentRealm } = this.get()\n    let realmBatches = this._batches[currentRealm]\n    if (!realmBatches) {\n      realmBatches = this._batches[currentRealm] = {}\n    }\n    let batch = realmBatches[key]\n    if (!batch) {\n      batch = realmBatches[key] = {}\n    }\n    batch[subKey] = value\n\n    requestPostAnimationFrame(() => {\n      const batch = this._batches[currentRealm] && this._batches[currentRealm][key]\n      if (!batch) {\n        return\n      }\n      const updatedKeys = Object.keys(batch)\n      if (!updatedKeys.length) {\n        return\n      }\n      mark('batchUpdate')\n      const obj = this.get()[key]\n      for (const otherKey of updatedKeys) {\n        obj[otherKey] = batch[otherKey]\n      }\n      delete this._batches[currentRealm][key]\n      const { realms } = this.get()\n      realms.set(currentRealm, Object.assign(realms.get(currentRealm) || {}, { [key]: obj }))\n      this.set({ realms: realms })\n      stop('batchUpdate')\n    })\n  }\n}\n"],"sourceRoot":""}