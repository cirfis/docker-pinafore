{"version":3,"sources":["webpack://pinafore/./src/routes/_actions/filters.js","webpack://pinafore/./src/routes/_api/filters.js","webpack://pinafore/./src/routes/_api/pushSubscription.js","webpack://pinafore/./src/routes/_utils/base64.js","webpack://pinafore/./src/routes/_actions/pushSubscription.js","webpack://pinafore/./src/routes/_static/instanceSettings.js"],"names":["async","syncFilters","instanceName","syncMethod","loggedInInstances","store","accessToken","access_token","url","timeout","getFilters","database","filters","instanceFilters","isEqual","updateFiltersForInstance","setupFiltersForInstance","createOrUpdateFilter","filter","id","updateFilter","toast","createFilter","err","formatIntl","message","postSubscription","subscription","alerts","toJSON","data","urlBase64ToUint8Array","base64String","base64","rawData","window","atob","outputArray","Uint8Array","length","i","charCodeAt","decodeBase64","repeat","replace","updatePushSubscriptionForInstance","currentPushSubscription","registration","navigator","serviceWorker","ready","pushManager","getSubscription","backendSubscription","btoa","server_key","buffer","options","applicationServerKey","unsubscribe","deleteSubscription","updateAlerts","e","startsWith","subscribe","userVisibleOnly","putSubscription","HOME_REBLOGS","HOME_REPLIES","NOTIFICATION_REBLOGS","NOTIFICATION_FAVORITES","NOTIFICATION_FOLLOWS","NOTIFICATION_MENTIONS","NOTIFICATION_POLLS"],"mappings":"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","file":"4332.c06442e819752ea41bec.4332.js","sourcesContent":["import { store } from '../_store/store'\nimport { createFilter, getFilters, updateFilter, deleteFilter as doDeleteFilter } from '../_api/filters'\nimport { cacheFirstUpdateAfter, cacheFirstUpdateOnlyIfNotInCache } from '../_utils/sync'\nimport { database } from '../_database/database'\nimport { isEqual } from 'lodash-es'\nimport { toast } from '../_components/toast/toast'\nimport { formatIntl } from '../_utils/formatIntl'\nimport { emit } from '../_utils/eventBus'\n\nasync function syncFilters (instanceName, syncMethod) {\n  const { loggedInInstances } = store.get()\n  const accessToken = loggedInInstances[instanceName].access_token\n\n  await syncMethod(\n    () => getFilters(instanceName, accessToken),\n    () => database.getFilters(instanceName),\n    filters => database.setFilters(instanceName, filters),\n    filters => {\n      const { instanceFilters } = store.get()\n      if (!isEqual(instanceFilters[instanceName], filters)) { // avoid re-render if nothing changed\n        instanceFilters[instanceName] = filters\n        store.set({ instanceFilters })\n      }\n    }\n  )\n}\n\nexport async function updateFiltersForInstance (instanceName) {\n  await syncFilters(instanceName, cacheFirstUpdateAfter)\n}\n\nexport async function setupFiltersForInstance (instanceName) {\n  await syncFilters(instanceName, cacheFirstUpdateOnlyIfNotInCache)\n}\n\nexport async function createOrUpdateFilter (instanceName, filter) {\n  const { loggedInInstances } = store.get()\n  const accessToken = loggedInInstances[instanceName].access_token\n  try {\n    if (filter.id) {\n      await updateFilter(instanceName, accessToken, filter)\n      /* no await */ toast.say(\"Updated filter\")\n    } else {\n      await createFilter(instanceName, accessToken, filter)\n      /* no await */ toast.say(\"Created filter\")\n    }\n    emit('wordFiltersChanged', instanceName)\n  } catch (err) {\n    /* no await */ toast.say(formatIntl([\"Failed to modify filter: \",[\"error\"]], err.message || ''))\n  }\n}\n\nexport async function deleteFilter (instanceName, id) {\n  const { loggedInInstances } = store.get()\n  const accessToken = loggedInInstances[instanceName].access_token\n  try {\n    await doDeleteFilter(instanceName, accessToken, id)\n    /* no await */ toast.say(\"Deleted filter\")\n    emit('wordFiltersChanged', instanceName)\n  } catch (err) {\n    /* no await */ toast.say(formatIntl([\"Failed to modify filter: \",[\"error\"]], err.message || ''))\n  }\n}\n","import { get, DEFAULT_TIMEOUT, post, WRITE_TIMEOUT, put, del } from '../_utils/ajax'\nimport { auth, basename } from './utils'\n\nexport function getFilters (instanceName, accessToken) {\n  const url = `${basename(instanceName)}/api/v1/filters`\n  return get(url, auth(accessToken), { timeout: DEFAULT_TIMEOUT })\n}\n\nexport function createFilter (instanceName, accessToken, filter) {\n  const url = `${basename(instanceName)}/api/v1/filters`\n  return post(url, filter, auth(accessToken), { timeout: WRITE_TIMEOUT })\n}\n\nexport function updateFilter (instanceName, accessToken, filter) {\n  const url = `${basename(instanceName)}/api/v1/filters/${filter.id}`\n  return put(url, filter, auth(accessToken), { timeout: WRITE_TIMEOUT })\n}\n\nexport function deleteFilter (instanceName, accessToken, id) {\n  const url = `${basename(instanceName)}/api/v1/filters/${id}`\n  return del(url, auth(accessToken), { timeout: WRITE_TIMEOUT })\n}\n","import { auth, basename } from './utils'\nimport { post, put, get, del } from '../_utils/ajax'\n\nexport async function postSubscription (instanceName, accessToken, subscription, alerts) {\n  const url = `${basename(instanceName)}/api/v1/push/subscription`\n\n  return post(url, { subscription: subscription.toJSON(), data: { alerts } }, auth(accessToken))\n}\n\nexport async function putSubscription (instanceName, accessToken, alerts) {\n  const url = `${basename(instanceName)}/api/v1/push/subscription`\n\n  return put(url, { data: { alerts } }, auth(accessToken))\n}\n\nexport async function getSubscription (instanceName, accessToken) {\n  const url = `${basename(instanceName)}/api/v1/push/subscription`\n\n  return get(url, auth(accessToken))\n}\n\nexport async function deleteSubscription (instanceName, accessToken) {\n  const url = `${basename(instanceName)}/api/v1/push/subscription`\n\n  return del(url, auth(accessToken))\n}\n","const decodeBase64 = base64 => {\n  const rawData = window.atob(base64)\n  const outputArray = new Uint8Array(rawData.length)\n\n  for (let i = 0; i < rawData.length; ++i) {\n    outputArray[i] = rawData.charCodeAt(i)\n  }\n\n  return outputArray\n}\n\n// Taken from https://www.npmjs.com/package/web-push\nexport const urlBase64ToUint8Array = (base64String) => {\n  const padding = '='.repeat((4 - base64String.length % 4) % 4)\n  const base64 = (base64String + padding)\n    .replace(/-/g, '+')\n    .replace(/_/g, '/')\n\n  return decodeBase64(base64)\n}\n","import { getSubscription, deleteSubscription, postSubscription, putSubscription } from '../_api/pushSubscription'\nimport { store } from '../_store/store'\nimport { urlBase64ToUint8Array } from '../_utils/base64'\n\nconst dummyApplicationServerKey = 'BImgAz4cF_yvNFp8uoBJCaGpCX4d0atNIFMHfBvAAXCyrnn9IMAFQ10DW_ZvBCzGeR4fZI5FnEi2JVcRE-L88jY='\n\nexport async function updatePushSubscriptionForInstance (instanceName) {\n  const { loggedInInstances, currentPushSubscription } = store.get()\n  const accessToken = loggedInInstances[instanceName].access_token\n\n  if (currentPushSubscription === null) {\n    return\n  }\n\n  const registration = await navigator.serviceWorker.ready\n  const subscription = await registration.pushManager.getSubscription()\n\n  if (subscription === null) {\n    store.setInstanceData(instanceName, 'pushSubscriptions', null)\n    store.save()\n    return\n  }\n\n  try {\n    const backendSubscription = await getSubscription(instanceName, accessToken)\n\n    // Check if applicationServerKey changed (need to get another subscription from the browser)\n    if (btoa(urlBase64ToUint8Array(backendSubscription.server_key).buffer) !== btoa(subscription.options.applicationServerKey)) {\n      await subscription.unsubscribe()\n      await deleteSubscription(instanceName, accessToken)\n      await updateAlerts(instanceName, currentPushSubscription.alerts)\n    } else {\n      store.setInstanceData(instanceName, 'pushSubscriptions', backendSubscription)\n      store.save()\n    }\n  } catch (e) {\n    // TODO: Better way to detect 404\n    if (e.message.startsWith('404:')) {\n      await subscription.unsubscribe()\n      store.setInstanceData(instanceName, 'pushSubscriptions', null)\n      store.save()\n    }\n  }\n}\n\nexport async function updateAlerts (instanceName, alerts) {\n  const { loggedInInstances } = store.get()\n  const accessToken = loggedInInstances[instanceName].access_token\n\n  const registration = await navigator.serviceWorker.ready\n  let subscription = await registration.pushManager.getSubscription()\n\n  if (subscription === null) {\n    // We need applicationServerKey in order to register a push subscription\n    // but the API doesn't expose it as a constant (as it should).\n    // So we need to register a subscription with a dummy applicationServerKey,\n    // send it to the backend saves it and return applicationServerKey, which\n    // we use to register a new subscription.\n    // https://github.com/tootsuite/mastodon/issues/8785\n    subscription = await registration.pushManager.subscribe({\n      applicationServerKey: urlBase64ToUint8Array(dummyApplicationServerKey),\n      userVisibleOnly: true\n    })\n\n    let backendSubscription = await postSubscription(instanceName, accessToken, subscription, alerts)\n\n    await subscription.unsubscribe()\n\n    subscription = await registration.pushManager.subscribe({\n      applicationServerKey: urlBase64ToUint8Array(backendSubscription.server_key),\n      userVisibleOnly: true\n    })\n\n    backendSubscription = await postSubscription(instanceName, accessToken, subscription, alerts)\n\n    store.setInstanceData(instanceName, 'pushSubscriptions', backendSubscription)\n    store.save()\n  } else {\n    try {\n      const backendSubscription = await putSubscription(instanceName, accessToken, alerts)\n      store.setInstanceData(instanceName, 'pushSubscriptions', backendSubscription)\n      store.save()\n    } catch (e) {\n      const backendSubscription = await postSubscription(instanceName, accessToken, subscription, alerts)\n      store.setInstanceData(instanceName, 'pushSubscriptions', backendSubscription)\n      store.save()\n    }\n  }\n}\n","export const HOME_REBLOGS = 'homeReblogs'\nexport const HOME_REPLIES = 'homeReplies'\n\nexport const NOTIFICATION_REBLOGS = 'notificationReblogs'\nexport const NOTIFICATION_FAVORITES = 'notificationFavs'\nexport const NOTIFICATION_FOLLOWS = 'notificationFollows'\nexport const NOTIFICATION_MENTIONS = 'notificationMentions'\nexport const NOTIFICATION_POLLS = 'notificationPolls'\n"],"sourceRoot":""}