{"version":3,"sources":["webpack://pinafore/./src/routes/_utils/sortItemSummariesForThread.js","webpack://pinafore/./src/routes/_utils/maps.js","webpack://pinafore/./src/routes/_actions/timeline.js","webpack://pinafore/./src/routes/_components/timeline/LoadingFooter.html","webpack://pinafore/./src/routes/_components/timeline/MoreHeader.html","webpack://pinafore/./src/routes/_components/timeline/MoreHeaderVirtualWrapper.html","webpack://pinafore/./src/routes/_utils/scrollIntoView.js","webpack://pinafore/./src/routes/_components/shortcut/ScrollListShortcuts.html","webpack://pinafore/./src/routes/_workers/blurhash.js","webpack://pinafore/./src/routes/_utils/blurhash.js","webpack://pinafore/./src/routes/_static/blurhash.js","webpack://pinafore/./src/routes/_actions/createMakeProps.js","webpack://pinafore/./src/routes/_components/timeline/Timeline.html","webpack://pinafore/./src/routes/_actions/showMoreAndScrollToTop.js","webpack://pinafore/./src/routes/_utils/asyncModules/importList.js","webpack://pinafore/./src/routes/_utils/asyncModules/importVirtualList.js","webpack://pinafore/./src/routes/_utils/asyncModules/importNotificationVirtualListItem.js","webpack://pinafore/./src/routes/_utils/asyncModules/importStatusVirtualListItem.js","webpack://pinafore/./src/routes/_api/timelines.js","webpack://pinafore/./src/routes/_static/timelines.js","webpack://pinafore/./src/routes/_utils/statusHtmlToPlainText.js","webpack://pinafore/./src/routes/_utils/statusIdSorting.js"],"names":["sortItemSummariesForThread","summaries","statusId","ancestors","descendants","summariesById","items","func","map","Map","item","set","mapBy","_","id","summariesByReplyId","key","has","get","push","multimapBy","replyId","status","currentStatus","unshift","stack","length","current","shift","newChildren","sort","Array","prototype","apply","isUnbrokenSelfReply","descendant","accountId","parent","promotedDescendants","otherDescendants","byId","async","storeFreshTimelineItemsInDatabase","instanceName","timelineName","database","startsWith","forEach","updateStatus","accessToken","fetchThreadFromNetwork","split","slice","context","Promise","all","fetchFreshThreadFromNetwork","in_reply_to_id","updateStatusAndThread","scheduleIdleTask","addPagedTimelineItems","newSummaries","timelineItemToSummary","oldSummaries","store","mergedSummaries","uniqBy","isEqual","timelineItemSummaries","addPagedTimelineItemSummaries","s","fetchTimelineItems","online","lastTimelineItemId","stale","fetchTimelineItemsFromNetwork","e","console","error","toast","addTimelineItemSummaries","newStale","oldStale","timelineItemSummariesAreStale","fetchTimelineItemsAndPossiblyFallBack","currentTimeline","currentInstance","timelineNextPageId","headers","linkHeader","parsedLinkHeader","nextUrl","next","nextId","URL","searchParams","fetchPagedItems","addTimelineItems","fetchMoreItemsAtBottomOfTimeline","runningUpdate","showMoreItemsForTimeline","itemSummariesToAdd","reverse","timelineItemSummariesToAdd","shouldShowHeader","showHeader","showMoreItemsForCurrentTimeline","preventDefault","stopPropagation","this","virtualListItems","document","querySelector","children","focus","onClickLoadMore","event","showLoading","showLoadButton","shown","$timelineInitialized","$runningUpdate","$disableInfiniteScroll","onClick","showMoreLabel","count","formatIntl","virtualProps","mainNavElement","getTopOverlay","getElementById","clientHeight","firstVisibleElementIndex","elements","offsetHeight","topOverlay","first","firstComplete","len","i","element","rect","getBoundingClientRect","top","bottom","keyToElement","elementToKey","getAttribute","scope","target","tagName","type","shouldIgnoreEvent","spoilersShown","changeActiveItem","timeStamp","activeItemKey","checkActiveItem","index","movement","smoothScroll","setActiveItem","scrollY","height","scrollContainer","scrollTop","scrollIntoViewIfNeeded","activeElement","activeItem","activeItemChangeTime","isVisible","preventScroll","err","getElementsByClassName","Worker_fn","Worker","cache","maxSize","worker","canvas","canvasContext2D","init","decodeUsingCanvas","imageData","createElement","width","getContext","putImageData","blob","resolve","toBlob","createObjectURL","decode","blurhash","result","decoded","postMessage","decodeWithoutCache","on","evictedUrl","revokeObjectURL","getActualStatus","statusOrNotification","decodeAllBlurhashes","mediaWithBlurhashes","concat","filter","media","decodedBlurhash","warn","calculatePlainTextContent","originalStatus","reblog","content","mentions","plainTextContent","statusHtmlToPlainText","createMakeProps","timelineType","timelineValue","promiseChain","fetchFromIndexedDB","itemId","notification","getNotification","getStatus","tryInitBlurhash","getStatusOrNotificationPromise","getStatusOrNotification","reject","then","observe","initializeStarted","doubleRAF","timelineInitialized","disableInfiniteScroll","timeline","setForCurrentTimeline","handleItemIdsToAdd","itemIdsToAdd","timelineItemIds","Set","itemSummaryToAdd","sortedTimelineItemSummaries","showMoreItemsForThread","setForTimeline","newItemIdsToAdd","oldItemIdsToAdd","componentsPromise","components","timelinePreinitialized","showMoreAndScrollToTop","currentTimelineType","currentTimelineValue","firstItemSummary","notificationId","scrollToTop","createStatusOrNotificationUuid","tryToFocusElement","setupTimeline","setupStreaming","setupAsyncComponents","listComponent","listItemComponent","$currentInstance","makeProps","itemIds","LoadingFooter","$showHeader","MoreHeaderVirtualWrapper","headerProps","scrollToItem","onScrollToBottom","onScrollToTop","onScrollTopChanged","initialize","onNoNeedToScroll","Status","undefined","focusRealm","label","$currentTimelineType","mod","default","results","$currentTimelineValue","$firstTimelineItemId","$filteredTimelineItemSummaries","$filteredTimelineItemSummariesToAdd","getTimeline","maxId","since","limit","timelineUrlName","Error","getTimelineUrlPath","url","params","since_id","max_id","local","endsWith","only_media","exclude_replies","exclude_types","json","timeout","last_status","TIMELINE_BATCH_SIZE","timelines","home","name","federated","domParser","DOMParser","html","doc","parseFromString","anchors","querySelectorAll","anchor","href","mention","find","innerText","acct","massageMentions","res","paragraphs","paragraph","brs","j","br","parentNode","replaceChild","createTextNode","textContent","innerTextRetainingNewlines","zeroPad","str","toSize","toPaddedBigInt","toReversePaddedBigInt","padded","reversed","inverseCharCode","MIN_CHAR_CODE","charCodeAt","String","fromCharCode","compareTimelineItemSummaries","left","right","leftPadded","rightPadded"],"mappings":"wTAOO,SAASA,EAA4BC,EAAWC,GACrD,MAAMC,EAAY,GACZC,EAAc,GACdC,ECRD,SAAgBC,EAAOC,GAC5B,MAAMC,EAAM,IAAIC,IAChB,IAAK,MAAMC,KAAQJ,EACjBE,EAAIG,IAAIJ,EAAKG,GAAOA,GAEtB,OAAOF,EDGeI,CAAMX,GAAWY,GAAKA,EAAEC,KACxCC,ECDD,SAAqBT,EAAOC,GACjC,MAAMC,EAAM,IAAIC,IAChB,IAAK,MAAMC,KAAQJ,EAAO,CACxB,MAAMU,EAAMT,EAAKG,GACbF,EAAIS,IAAID,GACVR,EAAIU,IAAIF,GAAKG,KAAKT,GAElBF,EAAIG,IAAIK,EAAK,CAACN,IAGlB,OAAOF,EDToBY,CAAWnB,GAAWY,GAAKA,EAAEQ,UAElDC,EAASjB,EAAca,IAAIhB,GACjC,IAAKoB,EAEH,OAAOrB,EAIT,IAAIsB,EAAgBD,EACpB,GACEC,EAAgBlB,EAAca,IAAIK,EAAcF,SAC5CE,GACFpB,EAAUqB,QAAQD,SAEbA,GAIT,MAAME,EAAQ,CAACH,GACf,KAAOG,EAAMC,QAAQ,CACnB,MAAMC,EAAUF,EAAMG,QAChBC,GAAed,EAAmBG,IAAIS,EAAQb,KAAO,IAAIgB,KAAK,MACpEC,MAAMC,UAAUR,QAAQS,MAAMR,EAAOI,GACjCF,EAAQb,KAAOQ,EAAOR,IACxBV,EAAYe,KAAKQ,GASrB,MAAMO,EAAuBC,IAC3B,IAAIR,EAAUQ,EACd,OAAa,CACX,GAAIR,EAAQS,YAAcd,EAAOc,UAC/B,OAAO,EAET,MAAMC,EAAShC,EAAca,IAAIS,EAAQN,SACzC,IAAKgB,EACH,MAEFV,EAAUU,EAEZ,OAAOV,EAAQb,KAAOZ,GAGlBoC,EAAsB,GACtBC,EAAmB,GACzB,IAAK,MAAMJ,KAAc/B,GACtB8B,EAAoBC,GAAcG,EAAsBC,GAAkBpB,KAAKgB,GAGlF,OAAO,OACLhC,EACA,CAACmB,GACDgB,EACAC,G,uBEpDJ,MAAMC,EAAO3B,GAAKA,EAAEC,GAEpB2B,eAAeC,EAAmCC,EAAcC,EAActC,SACtEuC,EAAA,sBAA6BF,EAAcC,EAActC,GAC3DsC,EAAaE,WAAW,YAI1BxC,EAAMyC,SAAQrC,KACZ,OAAK,gBAAiBA,MAK5B+B,eAAeO,EAAcL,EAAcM,EAAa/C,GACtD,MAAMoB,QAAe,QAAUqB,EAAcM,EAAa/C,GAG1D,aAFM2C,EAAA,eAAsBF,EAAcrB,IAC1C,OAAK,gBAAiBA,GACfA,EAwBTmB,eAAeS,EAAwBP,EAAcM,EAAaL,GAChE,MAAM1C,EAAW0C,EAAaO,MAAM,KAAKC,OAAO,GAAG,GAK7C9B,QAAeuB,EAAA,YAAmBF,EAAczC,GACtD,IAAKoB,EAIH,OAnBJmB,eAA4CE,EAAcM,EAAa/C,GACrE,MAAOoB,EAAQ+B,SAAiBC,QAAQC,IAAI,EAC1C,QAAUZ,EAAcM,EAAa/C,IACrC,QAAiByC,EAAcM,EAAa/C,KAE9C,OAAO,OAAOmD,EAAQlD,UAAWmB,EAAQ+B,EAAQjD,aAcxCoD,CAA4Bb,EAAcM,EAAa/C,GAGhE,IAAKoB,EAAOmC,eAKV,OAxCJhB,eAAsCE,EAAcM,EAAaL,EAAc1C,GAC7E,MAAOoB,EAAQ+B,SAAiBC,QAAQC,IAAI,CAC1CP,EAAaL,EAAcM,EAAa/C,IACxC,QAAiByC,EAAcM,EAAa/C,WAExC2C,EAAA,sBACJF,EACAC,GACA,OAAOS,EAAQlD,UAAWmB,EAAQ+B,EAAQjD,eAE5C,OAA2BuC,EAAcC,GAAc,OAAOS,EAAQlD,UAAWkD,EAAQjD,cA6BxEsD,CAAsBf,EAAcM,EAAaL,EAAc1C,GACvE,CAACoB,IAKV,EAAAqC,EAAA,IAAiB,IAAMX,EAAaL,EAAcM,EAAa/C,KAC/D,MAAMmD,QAAgB,QAAiBV,EAAcM,EAAa/C,GAClE,OAAO,OAAOmD,EAAQlD,UAAWmB,EAAQ+B,EAAQjD,aAWnDqC,eAAemB,EAAuBjB,EAAcC,EAActC,GAClBA,EAAMoB,QACpD,OAAK,iCACL,MAAMmC,EAAevD,EAAME,KAAIE,IAAQ,EAAAoD,EAAA,GAAsBpD,EAAMiC,WAK9DF,eAA8CE,EAAcC,EAAciB,GAC/E,MAAME,EAAeC,EAAA,iBAAqBrB,EAAcC,EAAc,yBAEhEqB,GAAkB,EAAAC,EAAA,IAAO,OAAOH,GAAgB,GAAIF,GAAerB,IAEpE,EAAA2B,EAAA,GAAQJ,EAAcE,IACzBD,EAAA,iBAAqBrB,EAAcC,EAAc,CAAEwB,sBAAuBH,IAVtEI,CAA8B1B,EAAcC,EAAciB,IAChE,IAAAS,GAAK,iCA2BP7B,eAAe8B,EAAoB5B,EAAcM,EAAaL,EAAc4B,IAC1E,OAAK,sBACL,MAAM,mBAAEC,GAAuBT,EAAA,QAC/B,IAAI1D,EACAoE,GAAQ,EACZ,GAAKF,EAIH,IAEElE,QAnDNmC,eAA8CE,EAAcM,EAAaL,EAAc6B,GACrF,GAAI7B,EAAaE,WAAW,WAC1B,OAAOI,EAAuBP,EAAcM,EAAaL,GACpD,CACL,MAAM,MAAEtC,SAAgB,OAAYqC,EAAcM,EAAaL,EAAc6B,EAAoB,KAAM,KACvG,OAAOnE,GA8CSqE,CAA8BhC,EAAcM,EAAaL,EAAc6B,SAC/E/B,EAAkCC,EAAcC,EAActC,GACpE,MAAOsE,GACPC,QAAQC,MAAMF,GACCG,EAAA,MAAU,qDACzBzE,QAAcuC,EAAA,cAAqBF,EAAcC,EAAc6B,EAAoB,KACnFC,GAAQ,OAXVpE,QAAcuC,EAAA,cAAqBF,EAAcC,EAAc6B,EAAoB,KACnFC,GAAQ,EAcV,OADA,IAAAJ,GAAK,sBACE,CAAEhE,QAAOoE,SAWXjC,eAAeuC,EAA0BrC,EAAcC,EAAciB,EAAcoB,GACxF,MAAMlB,EAAeC,EAAA,iBAAqBrB,EAAcC,EAAc,yBAChEsC,EAAWlB,EAAA,iBAAqBrB,EAAcC,EAAc,iCAE5DqB,GAAkB,EAAAC,EAAA,IAAO,OAAYH,GAAgB,GAAIF,EAAc,MAA+BrB,IAEvG,EAAA2B,EAAA,GAAQJ,EAAcE,IACzBD,EAAA,iBAAqBrB,EAAcC,EAAc,CAAEwB,sBAAuBH,IAExEiB,IAAaD,GACfjB,EAAA,iBAAqBrB,EAAcC,EAAc,CAAEuC,8BAA+BF,IAItFxC,eAAe2C,KAEb,OAAK,yCACL,MAAM,gBACJC,EAAe,gBACfC,EAAe,YACfrC,EAAW,OACXuB,GACER,EAAA,QAEJ,GAAwB,cAApBqB,GAAuD,cAApBA,QAtEzC5C,eAAgCE,EAAcM,EAAaL,GACzD,MAAM,mBAAE2C,GAAuBvB,EAAA,SAEzB,MAAE1D,EAAK,QAAEkF,SAAkB,OAAY7C,EAAcM,EAAaL,EAAc2C,EAAoB,KAAM,KAC1GE,EAAaD,EAAQtE,IAAI,QACzBwE,EAAmB,UAASD,GAC5BE,EAAUD,GAAoBA,EAAiBE,KAC/CC,EAASF,GAAW,IAAKG,IAAIH,GAAUI,aAAa7E,IAAI,UAE9D8C,EAAA,iBAAqBrB,EAAcC,EAAc,CAAE2C,mBAAoBM,UACjEnD,EAAkCC,EAAcC,EAActC,SAC9DsD,EAAsBjB,EAAcC,EAActC,GA8DhD0F,CAAgBV,EAAiBrC,EAAaoC,OAC/C,CACL,MAAM,MAAE/E,EAAK,MAAEoE,SAAgBH,EAAmBe,EAAiBrC,EAAaoC,EAAiBb,SArCrG/B,eAAiCE,EAAcC,EAActC,EAAOoE,GACzBpE,EAAMoB,QAC/C,OAAK,4BACL,MAAMmC,EAAevD,EAAME,KAAIE,IAAQ,EAAAoD,EAAA,GAAsBpD,EAAMiC,KACnEqC,EAAyBrC,EAAcC,EAAciB,EAAca,IACnE,IAAAJ,GAAK,4BAiCG2B,CAAiBX,EAAiBD,EAAiB/E,EAAOoE,IAElE,IAAAJ,GAAK,yCAwBA7B,eAAeyD,EAAkCvD,EAAcC,GAEpEoB,EAAA,iBAAqBrB,EAAcC,EAAc,CAAEuD,eAAe,UAC5Df,IAENpB,EAAA,iBAAqBrB,EAAcC,EAAc,CAAEuD,eAAe,IAG7D1D,eAAe2D,EAA0BzD,EAAcC,IAC5D,OAAK,4BACL,IAAIyD,EAAqBrC,EAAA,iBAAqBrB,EAAcC,EAAc,+BAAiC,GAC3GyD,EAAqBA,EAAmBvE,KAAK,MAA8BwE,UAC3EtB,EAAyBrC,EAAcC,EAAcyD,GAAoB,GACzErC,EAAA,iBAAqBrB,EAAcC,EAAc,CAC/C2D,2BAA4B,GAC5BC,kBAAkB,EAClBC,YAAY,KAEd,IAAAnC,GAAK,4BAGA,SAASoC,IACd,MAAM,gBAAEpB,EAAe,gBAAED,GAAoBrB,EAAA,QAC7C,OAAOoC,EACLd,EACAD,G,MCpKS,CACP,gBAAiBT,GACfA,EAAE+B,iBACF/B,EAAEgC,kBACF,MAAM,gBAAEtB,EAAe,gBAAED,GAAoBwB,KAAK7C,MAAM9C,MACzCgF,EAAiCZ,EAAiBD,GAEjE,IAEE,MAAMyB,EAAmBC,SAASC,cAAc,iBAAiBC,SAChDH,EAAiBA,EAAiBpF,OAAS,GACnDsF,cAAc,WAAWE,QAClC,MAAOtC,GACPC,QAAQC,MAAMF,M,mDArBPZ,EAAA,E,2vCAjES,M,gBAUJmD,gBAAgBC,G,q0BAdPC,YAAc,QAAU,IAAE,kB,2BACpC,EAAAA,c,yHAQSC,eAAiB,QAAU,IAAE,kB,2BACtC,EAAAA,gB,mCAXOC,MAAQ,GAAK,UAAQ,kB,4MAClBF,YAAc,QAAU,IAAE,oB,sCACpC,EAAAA,e,yEAQSC,eAAiB,QAAU,IAAE,oB,yCACtC,EAAAA,kB,gEAXOC,MAAQ,GAAK,UAAQ,oB,0aAqEjD,UAGc,qBAAEC,EAAoB,eAAEC,EAAc,uBAAEC,I,OAC9CF,IAAyBE,GAA0BD,G,yFAEvC,eAAEA,I,OAAqBA,E,iIACpB,eAAEA,EAAc,uBAAEC,I,OAA8BD,GAAkBC,E,2DC3D5E,CACP,QAASN,GACP,MAAM,QAAEO,GAAYd,KAAK3F,MACrByG,GACFA,EAAQP,K,waApBgCO,QAAQP,G,+DACrDQ,e,iJAAAA,e,mPAAAA,gB,4VAwBiB,MAAEC,I,OAChB,EAAAC,EAAA,GAAW,CAAC,QAAQ,CAAC,SAAS,SAAU,CAAED,U,mLC3B/BE,aAAaF,MAAK,UAChBE,aAAaJ,S,0JADfI,aAAaF,O,6BACXE,aAAaJ,S,gPCKlC,IAAIK,EACJ,SAASC,IAIP,OAHKD,IACHA,EAAiBjB,SAASmB,eAAe,aAEpCF,EAAeG,aAajB,SAASC,EAA0BC,GACxC,MAAMC,GAAe,UACfC,EAAaN,IACnB,IAAIO,GAAS,EACTC,GAAiB,EACrB,MAAMC,EAAML,EAAS3G,OACrB,IAAIiH,GAAK,EACT,OAASA,EAAID,GAAK,CAChB,MAAME,EAAUP,EAASM,GACzB,IAAKC,EACH,SAEF,MAAMC,EAAOD,EAAQE,wBACrB,GAAID,EAAKE,IAAMT,GAAgBO,EAAKG,QAAUT,EAAY,CACxDC,EAAQG,EACRF,EAAiBI,EAAKE,IAAMR,GAAcI,EAAKD,EAAM,EAAMC,EAAI,EAAIA,EACnE,OAGJ,MAAO,CAAEH,QAAOC,iB,cC3BhB,MAEMQ,EAAejI,GAAO+F,SAASmB,eAAelH,GAC9CkI,EAAeN,GAAWA,EAAQO,aAAa,MAC/CC,EAAQ,S,MA0BH,CACP,UAAWhC,GACT,GA1BoBA,KAGxB,MAAM,OAAEiC,EAAM,IAAErI,GAAQoG,EAKxB,OAJgBiC,GACG,UAAnBA,EAAOC,SACS,UAAhBD,EAAOE,OACiB,YAARvI,GAA6B,cAARA,IAmB7BwI,CAAkBpC,GACpB,OAEF,GAAkB,MAAdA,EAAMpG,KAAe6F,KAAK7C,MAAM9C,MAAMmE,gBAAgBvC,WAAW,WAAY,CAE/EsE,EAAMR,kBACNQ,EAAMT,iBACN,MAAM,cAAE8C,GAAkB5C,KAAK3F,MAG/B,OAFA,OAAK,qBAAsBuI,QAC3B5C,KAAKlG,IAAI,CAAE8I,eAAgBA,IAG7B,GAAkB,MAAdrC,EAAMpG,KAA6B,cAAdoG,EAAMpG,IAI7B,OAHAoG,EAAMR,kBACNQ,EAAMT,sBACNE,KAAK6C,iBAAiB,EAAGtC,EAAMuC,WAGjC,GAAkB,MAAdvC,EAAMpG,KAA6B,YAAdoG,EAAMpG,IAI7B,OAHAoG,EAAMR,kBACNQ,EAAMT,sBACNE,KAAK6C,kBAAkB,EAAGtC,EAAMuC,WAGlC,IAAIC,EAAgB/C,KAAKgD,gBAAgBzC,EAAMuC,WAC/C,IAAKC,EAAe,CAClB,MAAM,SAAEvB,GAAaxB,KAAK3F,MACpB4I,EAAQ1B,EAAyBC,GAAUG,MAC7CsB,GAAS,IACXF,EAAgBV,EAAab,EAASyB,KAGtCF,IACF,QAAyBA,EAAexC,IAG5C,iBAAkB2C,EAAUJ,GAC1B,MAAM,SAAEtB,GAAaxB,KAAK3F,MAC1B,IAAI4I,GAAS,EACTF,EAAgB/C,KAAKgD,gBAAgBF,GACzC,GAAIC,EAAe,CACjB,MAAMlB,EAAML,EAAS3G,OACrB,IAAIiH,GAAK,EACT,OAASA,EAAID,GACX,GAAIQ,EAAab,EAASM,MAAQiB,EAAe,CAC/CE,EAAQnB,EACR,OAIN,GAAc,IAAVmB,IAA6B,IAAdC,EAIjB,OAHAH,EAAgB,KAChB/C,KAAKlG,IAAI,CAAEiJ,uBACX,EAAAI,EAAA,IAAa,UAAsB,GAAoB,GAAwB,GAGjF,IAAe,IAAXF,EAAc,CAChB,MAAM,MAAEtB,EAAK,cAAEC,GAAkBL,EAAyBC,GAC1DyB,EAASC,EAAW,EAAKtB,EAAgBD,OAEzCsB,GAASC,EAEPD,GAAS,GAAKA,EAAQzB,EAAS3G,SACjCkI,EAAgBV,EAAab,EAASyB,IACtCjD,KAAKoD,cAAcL,EAAeD,GDlErC,SAAiCf,GACtC,MAAMC,EAAOD,EAAQE,wBACfP,EAAaN,IACbK,GAAe,UACrB,IAAI4B,EAAU,EACd,GAAIrB,EAAKE,IAAMR,EACb2B,EAAU3B,MACL,MAAIM,EAAKG,OAASV,GAUvB,OAVqC,CACrC,MAAM6B,EAAStB,EAAKG,OAASH,EAAKE,IAEhCmB,EADG5B,EAAeC,EAAc4B,EACtB7B,EAAe6B,EAIf5B,GAKd,MAAM6B,GAAkB,UAClBC,EAAYD,EAAgBC,WAClC,EAAAL,EAAA,GAAaI,EAAiBC,EAAYxB,EAAKE,IAAMmB,GAA0B,GAAwB,GC8C/FI,CAAuBrB,EAAaW,MAGxC,gBAAiBD,GACf,MAAMY,EAAgBxD,SAASwD,cAC/B,IAAKA,EACH,OAAO,KAET,MAAMC,EAAaD,EAAcpB,aAAa,MAC9C,IAAKqB,EACH,OAAO,KAET,MAAM,qBAAEC,GAAyB5D,KAAK3F,MACtC,OAAKyI,EAAYc,EA9GW,MDF7B,SAAoB7B,GACzB,IAAKA,EACH,OAAO,EAET,MAAMC,EAAOD,EAAQE,wBACfR,GAAe,UACfC,EAAaN,IACnB,OAAOY,EAAKE,IAAMT,GAAgBO,EAAKG,QAAUT,EC0GtCmC,CAAUzB,EAAauB,KAC1B3D,KAAKoD,cAAc,KAAM,GAClB,MAEFO,GAET,cAAexJ,EAAK2I,GAClB9C,KAAKlG,IAAI,CAAE8J,qBAAsBd,IACjC,IACEV,EAAajI,GAAKkG,MAAM,CACtByD,eAAe,IAEjB,MAAOC,GACP/F,QAAQC,MAAM,sBAAuB8F,M,eAnGzC,QAAoBxB,EAAOvC,M,eAG3B,QAAuBuC,EAAOvC,M,8CALnB7C,EAAA,E,qBALA,CACXyG,qBAAsB,EACtBpC,SAAUtB,SAAS8D,uBAAuB,sBAC1CpB,eAAe,G,6eCrCN,SAASqB,KACtB,OAAO,IAAIC,OAAO,IAA0B,6C,0BCO9C,MAAMC,GAAQ,I,QAAI,GAAS,CAAEC,QAAS,MAEtC,IAAIC,GACAC,GACAC,GAOG,SAASC,KACdH,GAASA,IAAU,IAAI,KAAJ,CAAkB,IAAI,IAa3CzI,eAAe6I,GAAmBC,GAT3BJ,KACHA,GAASpE,SAASyE,cAAc,UAChCL,GAAOhB,OC1BwB,GD2B/BgB,GAAOM,MC3BwB,GD4B/BL,GAAkBD,GAAOO,WAAW,OAOtCN,GAAgBO,aAAaJ,EAAW,EAAG,GAC3C,MAAMK,QAAa,IAAItI,SAAQuI,GAAWV,GAAOW,OAAOD,KACxD,OAAO/F,IAAIiG,gBAAgBH,GAYtBnJ,eAAeuJ,GAAQC,GAC5B,IAAIC,EAASlB,GAAM9J,IAAI+K,GAKvB,OAJKC,IACHA,QAZJzJ,eAAmCwJ,GACjCZ,KACA,MAAM,QAAEc,EAAO,UAAEZ,SAAoBL,GAAOkB,YAAYH,GACxD,OAAIE,GAGGb,GAAkBC,GAMRc,CAAmBJ,GAClCjB,GAAMrK,IAAIsL,EAAUC,IAEfA,EAzCTlB,GAAMsB,GAAG,SAAS,CAACC,EAAYN,KAE7BnG,IAAI0G,gBAAgBD,M,0BEetB,SAASE,GAAiBC,GACxB,OAAO,SAAIA,EAAsB,CAAC,aAChC,SAAIA,EAAsB,CAAC,eAAgB,WAG/CjK,eAAekK,GAAqBD,GAClC,MAAMpL,EAASmL,GAAgBC,GAC/B,IAAKpL,EACH,OAEF,MAAMsL,GAAsB,SAAItL,EAAQ,CAAC,qBAAsB,IAC5DuL,QAAO,SAAIvL,EAAQ,CAAC,SAAU,qBAAsB,KACpDwL,QAAOjM,GAAKA,EAAEoL,WACbW,EAAoBlL,UACtB,OAAK,kBAAkBJ,EAAOR,YACxBwC,QAAQC,IAAIqJ,EAAoBpM,KAAIiC,UACxC,IACEsK,EAAMC,sBAAwBhB,GAAee,EAAMd,UACnD,MAAOrB,GACP/F,QAAQoI,KAAK,sCAAuCrC,SAGxD,IAAAtG,GAAK,kBAAkBhD,EAAOR,OAIlC2B,eAAeyK,GAA2BR,GACxC,MAAMpL,EAASmL,GAAgBC,GAC/B,IAAKpL,EACH,OAEF,MAAM6L,EAAiB7L,EAAO8L,OAAS9L,EAAO8L,OAAS9L,EACjD+L,EAAUF,EAAeE,SAAW,GACpCC,EAAWH,EAAeG,UAAY,SAGtC,IAAIhK,SAAQuI,KAChB,EAAAlI,EAAA,IAAiB,KACfwJ,EAAeI,kBAAmB,EAAAC,GAAA,GAAsBH,EAASC,GACjEzB,UAKC,SAAS4B,GAAiB9K,EAAc+K,EAAcC,GAC3D,IAAIC,EAAetK,QAAQuI,UAI3BpJ,eAAeoL,EAAoBC,IACjC,OAAK,sBAAsBA,KAC3B,IAIE,aAHoC,kBAAjBJ,EA5EzBjL,eAAgCE,EAAc+K,EAAcC,EAAeG,GACzE,MAAO,CACLJ,eACAC,gBACAI,mBAAoBlL,EAAA,kBAAyBF,EAAcmL,IAyErDE,CAAgBrL,EAAc+K,EAAcC,EAAeG,GArErErL,eAA0BE,EAAc+K,EAAcC,EAAeG,GACnE,MAAO,CACLJ,eACAC,gBACArM,aAAcuB,EAAA,YAAmBF,EAAcmL,IAkEzCG,CAAUtL,EAAc+K,EAAcC,EAAeG,IAEzD,SACA,IAAAxJ,GAAK,sBAAsBwJ,MAe/B,OAhFF,WACE,IACEzC,KACA,MAAOT,GACP/F,QAAQC,MAAM,kCAAmC8F,IAmDnDsD,GAyBOJ,IACL,MAAMK,EAZR1L,eAAwCqL,GACtC,MAAMpB,QAA6BmB,EAAmBC,GAKtD,aAJMxK,QAAQC,IAAI,CAChBoJ,GAAoBD,GACpBQ,GAA0BR,KAErBA,EAMgC0B,CAAwBN,GAC/D,OAAO,IAAIxK,SAAQ,CAACuI,EAASwC,KAC3BT,EAAeA,EACZU,MAAK,IAAMH,IACXG,KAAKzC,EAASwC,O,2DCwBV,CACPE,QAAO,MACP,aACE,MAAM,kBAAEC,GAAsB3H,KAAK3F,MAC/BsN,IAGJ3H,KAAKlG,IAAI,CAAE6N,mBAAmB,KAC9B,OAAK,uBACL,EAAAC,GAAA,IAAU,KAER5H,KAAK7C,MAAMrD,IAAI,CAAE+N,qBAAqB,KACtC,IAAApK,GAAK,2BAGT,mBAAoB+F,GAClBxD,KAAKlG,IAAI,CAAE0J,UAAWA,KAExB,mBACE,MAAM,aAAEqD,GAAiB7G,KAAK3F,OACxB,oBAAEwN,EAAmB,cAAEvI,EAAa,sBAAEwI,GAA0B9H,KAAK7C,MAAM9C,MACjF,IAAKwN,GACDvI,GACAwI,GACiB,WAAjBjB,EACF,OAEF,MAAM,gBAAEpI,GAAoBuB,KAAK7C,MAAM9C,OACjC,SAAE0N,GAAa/H,KAAK3F,MACXgF,EAAiCZ,EAAiBsJ,IAEnE,gBACE,MAAM,iBAAEpI,GAAqBK,KAAK7C,MAAM9C,MACpCsF,GACFK,KAAK7C,MAAM6K,sBAAsB,CAC/BpI,YAAY,EACZD,kBAAkB,KAIxB,iBACE,MAAM,gBAAElB,EAAe,sBAAEqJ,GAA0B9H,KAAK7C,MAAM9C,OACxD,SAAE0N,EAAQ,aAAElB,GAAiB7G,KAAK3F,MAClC4N,EAAqB,KACzB,MAAM,aAAEC,GAAiBlI,KAAK3F,MAC9B,IAAK6N,IAAiBA,EAAarN,OACjC,QAEF,OAAK,sBACL,MAAM,UAAE2I,GAAcxD,KAAK3F,OACrB,iBACJsF,EAAgB,WAChBC,GACEI,KAAK7C,MAAM9C,MACM,WAAjBwM,EV4DPjL,eAAuCE,EAAcC,IAC1D,OAAK,0BACL,MAAMyD,EAAqBrC,EAAA,iBAAqBrB,EAAcC,EAAc,8BACtEwB,EAAwBJ,EAAA,iBAAqBrB,EAAcC,EAAc,yBACzEoM,EAAkB,IAAIC,IAAI7K,EAAsB5D,KAAIK,GAAKA,EAAEC,MAEjE,IAAK,MAAMoO,KAAoB7I,EACxB2I,EAAgB/N,IAAIiO,EAAiBpO,KACxCsD,EAAsBjD,KAAK+N,GAG/B,MAAMhP,EAAW0C,EAAaO,MAAM,KAAKC,OAAO,GAAG,GAC7C+L,QAAoCnP,EAA2BoE,EAAuBlE,GAC5F8D,EAAA,iBAAqBrB,EAAcC,EAAc,CAC/C2D,2BAA4B,GAC5BnC,sBAAuB+K,KAEzB,IAAA7K,GAAK,0BU3EK8K,CAAuB9J,EAAiBsJ,GAC9BD,GAAuC,IAAdtE,GAAoB7D,GAAqBC,GAM5EI,KAAK7C,MAAMqL,eAAe/J,EAAiBsJ,EAAU,CAAEpI,kBAAkB,IAErEmI,GACF9H,KAAK7C,MAAMqL,eAAe/J,EAAiBsJ,EAAU,CAAEnI,YAAY,KANrEL,EAAyBd,EAAiBsJ,IAS5C,IAAAtK,GAAK,uBAEPuC,KAAK0H,QAAQ,gBAAgB,CAACe,EAAiBC,KACxCD,GACAA,EAAgB5N,UACjB,EAAAyC,EAAA,GAAQmL,EAAiBC,KAG7B,EAAA5L,EAAA,GAAiBmL,OAGrB,uBACEjI,KAAK0H,QAAQ,qBAAqB9L,UAChC,GAAI+M,EAAmB,CAErB,MAAMC,QAAmBD,EAEzB3I,KAAKlG,IAAI,CAAE8O,oBAIjB,mBAKE5I,KAAK7C,MAAMrD,IAAI,CAAE+O,wBAAwB,KAE3CC,uBC/NC,WAGLjJ,IACA,MAAM,gBACJpB,EAAe,sBACflB,EAAqB,oBACrBwL,EAAmB,qBACnBC,GACE7L,EAAA,QACE8L,EAAmB1L,GAAyBA,EAAsB,GACxE,IAAK0L,EACH,OAEF,MAAMC,EAAyC,kBAAxBH,GAA2CE,EAAiBhP,GAC7EZ,EAAmC,kBAAxB0P,GAA2CE,EAAiBhP,IAC7E,EAAAkP,GAAA,IAAyB,GACzB,MAAMlP,GAAK,EAAAmP,GAAA,GACT3K,EAAiBsK,EACjBC,EAAsBE,EAAgB7P,IAExC,EAAAgQ,GAAA,GAAkBpP,K,eXyKb2B,kBAEL,OAAK,iBAKL,MAAM,sBACJ2B,EAAqB,8BACrBe,EAA6B,gBAC7BE,GACErB,EAAA,UAECI,GACDe,GACAE,EAAgBvC,WAAW,mBACvBsC,KAER,IAAAd,GAAK,iBU7JD6L,GACAtJ,KAAKuJ,iBACLvJ,KAAKwJ,uB,2BAvDmBZ,WAAWa,c,iCACZb,WAAWc,kB,QACdC,iBAAmB,IAAM,EAAA5B,S,YAChC6B,U,QACMC,Q,YACK,E,kBACKC,c,aACLC,Y,kBACKC,yB,cAChBC,Y,eACAC,c,gFACkBC,mB,gBACHC,gB,gBACKC,mBAAmB9J,G,gBACxB+J,a,gBACGC,mB,kTAdR3B,WAAWc,oB,4CACdC,iBAAmB,IAAM,EAAA5B,U,4BAChC6B,W,sBACMC,S,sCAEUC,e,+BACLC,a,iDACKC,0B,gCAChBC,a,kCACAC,c,SAVWtB,WAAWa,gB,6SA+HxBtM,EAAA,E,yNAtEA,CACX2M,cAAa,EACbE,yBAAwB,EACxBQ,OAAM,IACNhH,UAAW,EACXoF,gBAAY6B,I,6hBA/DC,oB,WAFMC,Y,8KAuBoB5B,4B,mFAxBxB6B,O,+MAAAA,O,mfAAAA,O,EAGZ/B,W,8FAFgB8B,Y,wkBA0GJ,qBAAEE,I,OAA2BA,E,gGArDlD,UAmB0B,aAAE/D,IACpB,OAAOpK,QAAQC,IAAI,CACA,WAAjBmK,EE3EsB,+BAE9BY,MAAKoD,GAAOA,EAAIC,UCFqB,wDAErCrD,MAAKoD,GAAOA,EAAIC,UH4ES,kBAAjBjE,EI9E6C,+BAErDY,MAAKoD,GAAOA,EAAIC,UCF+B,6BAE/CrD,MAAKoD,GAAOA,EAAIC,YL+EPrD,MAAKsD,IAAW,CACjBtB,cAAesB,EAAQ,GACvBrB,kBAAmBqB,EAAQ,O,gHAyBf,sBAAEC,I,OAA4BA,E,kIAtBlC,iBAAErB,EAAgB,aAAE9C,EAAY,cAAEC,I,OAC5CF,GAAgB+C,EAAkB9C,EAAcC,G,kIAE1C,SAAEiB,EAAQ,iBAAE4B,EAAgB,aAAE9C,EAAY,cAAEC,IAClD,GAAI,IAAUiB,GACZ,MAAO,aAAa,IAAUA,GAAU4C,qBAAqBhB,IAG/D,OAAQ9C,GACN,IAAK,MACH,MAAO,cAAcC,YACvB,IAAK,SACH,MAAO,mBACT,IAAK,UACH,MAAO,6BACT,IAAK,OACH,MAAO,iBACT,IAAK,gBACH,MAAO,oBAAoB6C,K,oIAOlB,aAAE9C,EAAY,cAAEC,EAAa,qBAAEmE,I,MAC3B,WAAjBpE,GACAoE,GACAnE,IAAkBmE,GAClBnE,E,wGAEQ,+BAAEoE,I,OACVA,GAAkCA,EAA+BvR,KAAIK,GAAKA,EAAEC,K,kHAE/D,oCAAEkR,I,OACfA,GAAuCA,EAAoCxR,KAAIK,GAAKA,EAAEC,K,8FAE1E,aAAEiO,IACd,MAAO,CACLlH,MAAOkH,EAAeA,EAAarN,OAAS,EAC5CiG,QAASjB,G,6GAGA,iBAAE8J,EAAgB,SAAE5B,I,MAAe,GAAG4B,KAAoB5B,I,2GMnGtEnM,eAAewP,EAAatP,EAAcM,EAAa2L,EAAUsD,EAAOC,EAAOC,GACpF,MAAMC,EA5BR,SAA6BzD,GAC3B,OAAQA,GACN,IAAK,QACL,IAAK,YACH,MAAO,mBACT,IAAK,OACH,MAAO,iBACT,IAAK,gBACL,IAAK,yBACH,MAAO,gBACT,IAAK,YACH,MAAO,aACT,IAAK,SACH,MAAO,gBACT,IAAK,YACH,MAAO,YAEX,GAAIA,EAAS9L,WAAW,QACtB,MAAO,gBACF,GAAI8L,EAAS9L,WAAW,YAC7B,MAAO,WACF,GAAI8L,EAAS9L,WAAW,SAC7B,MAAO,iBAET,MAAM,IAAIwP,MAAM,0BAA0B1D,KAIlB2D,CAAmB3D,GAC3C,IAAI4D,EAAM,IAAG,OAAS7P,aAAwB0P,IAE1CzD,EAAS9L,WAAW,QACtB0P,GAAO,IAAM5D,EAASzL,MAAM,KAAK,GACxByL,EAAS9L,WAAW,YAC7B0P,GAAO,IAAM5D,EAASzL,MAAM,KAAK,GAAK,YAC7ByL,EAAS9L,WAAW,WAC7B0P,GAAO,IAAM5D,EAASzL,MAAM,KAAK,IAGnC,MAAMsP,EAAS,GACXN,IACFM,EAAOC,SAAWP,GAGhBD,IACFO,EAAOE,OAAST,GAGdE,IACFK,EAAOL,MAAQA,GAGA,UAAbxD,IACF6D,EAAOG,OAAQ,GAGbhE,EAAS9L,WAAW,cAClB8L,EAASiE,SAAS,SACpBJ,EAAOK,YAAa,EAEpBL,EAAOM,iBAAmBnE,EAASiE,SAAS,kBAI/B,2BAAbjE,IACF6D,EAAOO,cAAgB,CAAC,SAAU,YAAa,SAAU,SAG3DR,GAAO,KAAM,QAAaC,GAG1B,IAAMQ,KAAM3S,EAAK,QAAEkF,SAAkB,QAAegN,GAAK,OAAKvP,GAAc,CAAEiQ,QAAS,OAKvF,MAHiB,WAAbtE,IACFtO,EAAQA,EAAME,KAAIE,GAAQA,EAAKyS,eAE1B,CAAE7S,QAAOkF,a,qDC/EX,MAAM4N,EAAsB,GAEtBC,EAAY,CACvBC,KAAM,CAAEC,KAAM,OAAQ/B,MAAO,QAC7BoB,MAAO,CAAEW,KAAM,QAAS/B,MAAO,SAC/BgC,UAAW,CAAED,KAAM,YAAa/B,MAAO,e,qECFzC,MAAMiC,EAA+B,IAAIC,UAgClC,SAASlG,EAAuBmG,EAAMrG,GAC3C,IAAKqG,EACH,MAAO,IAET,OAAK,yBACLA,GAAO,OAAuBA,GAC9B,MAAMC,EAAMH,EAAUI,gBAAgBF,EAAM,cAnC9C,SAA0BC,EAAKtG,GAC7B,MAAMwG,EAAUF,EAAIG,iBAAiB,aACrC,IAAK,IAAIpL,EAAI,EAAGA,EAAImL,EAAQpS,OAAQiH,IAAK,CACvC,MAAMqL,EAASF,EAAQnL,GACjBsL,EAAOD,EAAO7K,aAAa,QAC3B+K,EAAU5G,EAAS6G,MAAKD,GAAWA,EAAQ1B,MAAQyB,IACrDC,IACFF,EAAOI,UAAY,IAAIF,EAAQG,SA6BnCC,CAAgBV,EAAKtG,GACrB,MAAMiH,EAvBR,SAAqCX,GACnC,IAAIW,EAAM,GACV,MAAMC,EAAaZ,EAAIG,iBAAiB,KACxC,IAAK,IAAIpL,EAAI,EAAGA,EAAI6L,EAAW9S,OAAQiH,IAAK,CAC1C,MAAM8L,EAAYD,EAAW7L,GACvB+L,EAAMD,EAAUV,iBAAiB,MACvC,IAAK,IAAIY,EAAI,EAAGA,EAAID,EAAIhT,OAAQiT,IAAK,CACnC,MAAMC,EAAKF,EAAIC,GACfC,EAAGC,WAAWC,aAAalB,EAAImB,eAAe,MAAOH,GAEvDL,IAAQ5L,EAAI,EAAI,OAAS,IAAM8L,EAAUO,YAE3C,OAAOT,EAWKU,CAA2BrB,GAEvC,OADA,IAAAtP,GAAK,yBACEiQ,I,6ECjCF,SAASW,EAASC,EAAKC,GAC5B,OAAO,QAASD,EAAKC,EAAQ,KAGxB,SAASC,EAAgBvU,GAC9B,OAAOoU,EAAQpU,EAPK,IAUf,SAASwU,EAAuBxU,GACrC,MAAMyU,EAASF,EAAevU,GAC9B,IAAI0U,EAAW,GACf,IAAK,IAAI7M,EAAI,EAAGA,EAAI4M,EAAO7T,OAAQiH,IAAK,CACtC,MACM8M,EAAkBC,IADPH,EAAOI,WAAWhN,GAEnC6M,GAAYI,OAAOC,aAAaJ,GAElC,OAAOD,EAGF,SAASM,EAA8BC,EAAMC,GAClD,MAAMC,EAAaZ,EAAeU,EAAKjV,IACjCoV,EAAcb,EAAeW,EAAMlV,IACzC,OAAOmV,EAAaC,GAAe,EAAID,IAAeC,EAAc,EAAI","file":"3038.dd1918c280be2c6a0580.3038.js","sourcesContent":["// This is designed to exactly mimic Mastodon's ordering for threads. As described by Gargron:\n// \"statuses are ordered in the postgresql query and then any of OP's self-replies bubble to the top\"\n// Source: https://github.com/tootsuite/mastodon/blob/ef15246/app/models/concerns/status_threading_concern.rb\nimport { concat } from './arrays'\nimport { compareTimelineItemSummaries } from './statusIdSorting'\nimport { mapBy, multimapBy } from './maps'\n\nexport function sortItemSummariesForThread (summaries, statusId) {\n  const ancestors = []\n  const descendants = []\n  const summariesById = mapBy(summaries, _ => _.id)\n  const summariesByReplyId = multimapBy(summaries, _ => _.replyId)\n\n  const status = summariesById.get(statusId)\n  if (!status) {\n    // bail out, for some reason we can't find the status (should never happen)\n    return summaries\n  }\n\n  // find ancestors\n  let currentStatus = status\n  do {\n    currentStatus = summariesById.get(currentStatus.replyId)\n    if (currentStatus) {\n      ancestors.unshift(currentStatus)\n    }\n  } while (currentStatus)\n\n  // find descendants\n  // This mirrors the depth-first ordering used in the Postgres query in the Mastodon implementation\n  const stack = [status]\n  while (stack.length) {\n    const current = stack.shift()\n    const newChildren = (summariesByReplyId.get(current.id) || []).sort(compareTimelineItemSummaries)\n    Array.prototype.unshift.apply(stack, newChildren)\n    if (current.id !== status.id) { // the status is not a descendant of itself\n      descendants.push(current)\n    }\n  }\n\n  // Normally descendants are sorted in depth-first order, via normal ID sorting\n  // but replies that come from the account they're actually replying to get promoted\n  // This only counts if it's an unbroken self-reply, e.g. in the case of\n  //     A -> A -> A -> B -> A -> A\n  // B has broken the chain, so only the first three As are considered unbroken self-replies\n  const isUnbrokenSelfReply = (descendant) => {\n    let current = descendant\n    while (true) {\n      if (current.accountId !== status.accountId) {\n        return false\n      }\n      const parent = summariesById.get(current.replyId)\n      if (!parent) {\n        break\n      }\n      current = parent\n    }\n    return current.id === statusId\n  }\n\n  const promotedDescendants = []\n  const otherDescendants = []\n  for (const descendant of descendants) {\n    (isUnbrokenSelfReply(descendant) ? promotedDescendants : otherDescendants).push(descendant)\n  }\n\n  return concat(\n    ancestors,\n    [status],\n    promotedDescendants,\n    otherDescendants\n  )\n}\n","// utilities for working with Maps\n\nexport function mapBy (items, func) {\n  const map = new Map()\n  for (const item of items) {\n    map.set(func(item), item)\n  }\n  return map\n}\n\nexport function multimapBy (items, func) {\n  const map = new Map()\n  for (const item of items) {\n    const key = func(item)\n    if (map.has(key)) {\n      map.get(key).push(item)\n    } else {\n      map.set(key, [item])\n    }\n  }\n  return map\n}\n","import { store } from '../_store/store'\nimport { getTimeline } from '../_api/timelines'\nimport { toast } from '../_components/toast/toast'\nimport { mark, stop } from '../_utils/marks'\nimport { concat, mergeArrays } from '../_utils/arrays'\nimport { compareTimelineItemSummaries } from '../_utils/statusIdSorting'\nimport isEqual from 'lodash-es/isEqual'\nimport { database } from '../_database/database'\nimport { getStatus, getStatusContext } from '../_api/statuses'\nimport { emit } from '../_utils/eventBus'\nimport { TIMELINE_BATCH_SIZE } from '../_static/timelines'\nimport { timelineItemToSummary } from '../_utils/timelineItemToSummary'\nimport uniqBy from 'lodash-es/uniqBy'\nimport { addStatusesOrNotifications } from './addStatusOrNotification'\nimport { scheduleIdleTask } from '../_utils/scheduleIdleTask'\nimport { sortItemSummariesForThread } from '../_utils/sortItemSummariesForThread'\nimport li from 'li'\n\nconst byId = _ => _.id\n\nasync function storeFreshTimelineItemsInDatabase (instanceName, timelineName, items) {\n  await database.insertTimelineItems(instanceName, timelineName, items)\n  if (timelineName.startsWith('status/')) {\n    // For status threads, we want to be sure to update the favorite/reblog counts even if\n    // this is a stale \"view\" of the status. See 119-status-counts-update.js for\n    // an example of why we need this.\n    items.forEach(item => {\n      emit('statusUpdated', item)\n    })\n  }\n}\n\nasync function updateStatus (instanceName, accessToken, statusId) {\n  const status = await getStatus(instanceName, accessToken, statusId)\n  await database.insertStatus(instanceName, status)\n  emit('statusUpdated', status)\n  return status\n}\n\nasync function updateStatusAndThread (instanceName, accessToken, timelineName, statusId) {\n  const [status, context] = await Promise.all([\n    updateStatus(instanceName, accessToken, statusId),\n    getStatusContext(instanceName, accessToken, statusId)\n  ])\n  await database.insertTimelineItems(\n    instanceName,\n    timelineName,\n    concat(context.ancestors, status, context.descendants)\n  )\n  addStatusesOrNotifications(instanceName, timelineName, concat(context.ancestors, context.descendants))\n}\n\nasync function fetchFreshThreadFromNetwork (instanceName, accessToken, statusId) {\n  const [status, context] = await Promise.all([\n    getStatus(instanceName, accessToken, statusId),\n    getStatusContext(instanceName, accessToken, statusId)\n  ])\n  return concat(context.ancestors, status, context.descendants)\n}\n\nasync function fetchThreadFromNetwork (instanceName, accessToken, timelineName) {\n  const statusId = timelineName.split('/').slice(-1)[0]\n\n  // For threads, we do several optimizations to make it a bit faster to load.\n  // The vast majority of statuses have no replies and aren't in reply to anything,\n  // so we want that to be as fast as possible.\n  const status = await database.getStatus(instanceName, statusId)\n  if (!status) {\n    // If for whatever reason the status is not cached, fetch everything from the network\n    // and wait for the result. This happens in very unlikely cases (e.g. loading /statuses/<id>\n    // where <id> is not cached locally) but is worth covering.\n    return fetchFreshThreadFromNetwork(instanceName, accessToken, statusId)\n  }\n\n  if (!status.in_reply_to_id) {\n    // status is not a reply to another status (fast path)\n    // Update the status and thread asynchronously, but return just the status for now\n    // Any replies to the status will load asynchronously\n    /* no await */ updateStatusAndThread(instanceName, accessToken, timelineName, statusId)\n    return [status]\n  }\n  // status is a reply to some other status, meaning we don't want some\n  // jerky behavior where it suddenly scrolls into place. Update the status asynchronously\n  // but grab the thread now\n  scheduleIdleTask(() => updateStatus(instanceName, accessToken, statusId))\n  const context = await getStatusContext(instanceName, accessToken, statusId)\n  return concat(context.ancestors, status, context.descendants)\n}\n\nasync function fetchTimelineItemsFromNetwork (instanceName, accessToken, timelineName, lastTimelineItemId) {\n  if (timelineName.startsWith('status/')) { // special case - this is a list of descendents and ancestors\n    return fetchThreadFromNetwork(instanceName, accessToken, timelineName)\n  } else { // normal timeline\n    const { items } = await getTimeline(instanceName, accessToken, timelineName, lastTimelineItemId, null, TIMELINE_BATCH_SIZE)\n    return items\n  }\n}\nasync function addPagedTimelineItems (instanceName, timelineName, items) {\n  console.log('addPagedTimelineItems, length:', items.length)\n  mark('addPagedTimelineItemSummaries')\n  const newSummaries = items.map(item => timelineItemToSummary(item, instanceName))\n  await addPagedTimelineItemSummaries(instanceName, timelineName, newSummaries)\n  stop('addPagedTimelineItemSummaries')\n}\n\nexport async function addPagedTimelineItemSummaries (instanceName, timelineName, newSummaries) {\n  const oldSummaries = store.getForTimeline(instanceName, timelineName, 'timelineItemSummaries')\n\n  const mergedSummaries = uniqBy(concat(oldSummaries || [], newSummaries), byId)\n\n  if (!isEqual(oldSummaries, mergedSummaries)) {\n    store.setForTimeline(instanceName, timelineName, { timelineItemSummaries: mergedSummaries })\n  }\n}\n\nasync function fetchPagedItems (instanceName, accessToken, timelineName) {\n  const { timelineNextPageId } = store.get()\n  console.log('saved timelineNextPageId', timelineNextPageId)\n  const { items, headers } = await getTimeline(instanceName, accessToken, timelineName, timelineNextPageId, null, TIMELINE_BATCH_SIZE)\n  const linkHeader = headers.get('Link')\n  const parsedLinkHeader = li.parse(linkHeader)\n  const nextUrl = parsedLinkHeader && parsedLinkHeader.next\n  const nextId = nextUrl && (new URL(nextUrl)).searchParams.get('max_id')\n  console.log('new timelineNextPageId', nextId)\n  store.setForTimeline(instanceName, timelineName, { timelineNextPageId: nextId })\n  await storeFreshTimelineItemsInDatabase(instanceName, timelineName, items)\n  await addPagedTimelineItems(instanceName, timelineName, items)\n}\n\nasync function fetchTimelineItems (instanceName, accessToken, timelineName, online) {\n  mark('fetchTimelineItems')\n  const { lastTimelineItemId } = store.get()\n  let items\n  let stale = false\n  if (!online) {\n    items = await database.getTimeline(instanceName, timelineName, lastTimelineItemId, TIMELINE_BATCH_SIZE)\n    stale = true\n  } else {\n    try {\n      console.log('fetchTimelineItemsFromNetwork')\n      items = await fetchTimelineItemsFromNetwork(instanceName, accessToken, timelineName, lastTimelineItemId)\n      await storeFreshTimelineItemsInDatabase(instanceName, timelineName, items)\n    } catch (e) {\n      console.error(e)\n      /* no await */ toast.say(\"Internet request failed. Showing offline content.\")\n      items = await database.getTimeline(instanceName, timelineName, lastTimelineItemId, TIMELINE_BATCH_SIZE)\n      stale = true\n    }\n  }\n  stop('fetchTimelineItems')\n  return { items, stale }\n}\n\nasync function addTimelineItems (instanceName, timelineName, items, stale) {\n  console.log('addTimelineItems, length:', items.length)\n  mark('addTimelineItemSummaries')\n  const newSummaries = items.map(item => timelineItemToSummary(item, instanceName))\n  addTimelineItemSummaries(instanceName, timelineName, newSummaries, stale)\n  stop('addTimelineItemSummaries')\n}\n\nexport async function addTimelineItemSummaries (instanceName, timelineName, newSummaries, newStale) {\n  const oldSummaries = store.getForTimeline(instanceName, timelineName, 'timelineItemSummaries')\n  const oldStale = store.getForTimeline(instanceName, timelineName, 'timelineItemSummariesAreStale')\n\n  const mergedSummaries = uniqBy(mergeArrays(oldSummaries || [], newSummaries, compareTimelineItemSummaries), byId)\n\n  if (!isEqual(oldSummaries, mergedSummaries)) {\n    store.setForTimeline(instanceName, timelineName, { timelineItemSummaries: mergedSummaries })\n  }\n  if (oldStale !== newStale) {\n    store.setForTimeline(instanceName, timelineName, { timelineItemSummariesAreStale: newStale })\n  }\n}\n\nasync function fetchTimelineItemsAndPossiblyFallBack () {\n  console.log('fetchTimelineItemsAndPossiblyFallBack')\n  mark('fetchTimelineItemsAndPossiblyFallBack')\n  const {\n    currentTimeline,\n    currentInstance,\n    accessToken,\n    online\n  } = store.get()\n\n  if (currentTimeline === 'favorites' || currentTimeline === 'bookmarks') {\n    // Always fetch favorites from the network, we currently don't have a good way of storing\n    // these in IndexedDB because of \"internal ID\" system Mastodon uses to paginate these\n    await fetchPagedItems(currentInstance, accessToken, currentTimeline)\n  } else {\n    const { items, stale } = await fetchTimelineItems(currentInstance, accessToken, currentTimeline, online)\n    await addTimelineItems(currentInstance, currentTimeline, items, stale)\n  }\n  stop('fetchTimelineItemsAndPossiblyFallBack')\n}\n\nexport async function setupTimeline () {\n  console.log('setupTimeline')\n  mark('setupTimeline')\n  // If we don't have any item summaries, or if the current item summaries are stale\n  // (i.e. via offline mode), then we need to re-fetch\n  // Also do this if it's a thread, because threads change pretty frequently and\n  // we don't have a good way to update them.\n  const {\n    timelineItemSummaries,\n    timelineItemSummariesAreStale,\n    currentTimeline\n  } = store.get()\n  console.log({ timelineItemSummaries, timelineItemSummariesAreStale, currentTimeline })\n  if (!timelineItemSummaries ||\n      timelineItemSummariesAreStale ||\n      currentTimeline.startsWith('status/')) {\n    await fetchTimelineItemsAndPossiblyFallBack()\n  }\n  stop('setupTimeline')\n}\n\nexport async function fetchMoreItemsAtBottomOfTimeline (instanceName, timelineName) {\n  console.log('setting runningUpdate: true')\n  store.setForTimeline(instanceName, timelineName, { runningUpdate: true })\n  await fetchTimelineItemsAndPossiblyFallBack()\n  console.log('setting runningUpdate: false')\n  store.setForTimeline(instanceName, timelineName, { runningUpdate: false })\n}\n\nexport async function showMoreItemsForTimeline (instanceName, timelineName) {\n  mark('showMoreItemsForTimeline')\n  let itemSummariesToAdd = store.getForTimeline(instanceName, timelineName, 'timelineItemSummariesToAdd') || []\n  itemSummariesToAdd = itemSummariesToAdd.sort(compareTimelineItemSummaries).reverse()\n  addTimelineItemSummaries(instanceName, timelineName, itemSummariesToAdd, false)\n  store.setForTimeline(instanceName, timelineName, {\n    timelineItemSummariesToAdd: [],\n    shouldShowHeader: false,\n    showHeader: false\n  })\n  stop('showMoreItemsForTimeline')\n}\n\nexport function showMoreItemsForCurrentTimeline () {\n  const { currentInstance, currentTimeline } = store.get()\n  return showMoreItemsForTimeline(\n    currentInstance,\n    currentTimeline\n  )\n}\n\nexport async function showMoreItemsForThread (instanceName, timelineName) {\n  mark('showMoreItemsForThread')\n  const itemSummariesToAdd = store.getForTimeline(instanceName, timelineName, 'timelineItemSummariesToAdd')\n  const timelineItemSummaries = store.getForTimeline(instanceName, timelineName, 'timelineItemSummaries')\n  const timelineItemIds = new Set(timelineItemSummaries.map(_ => _.id))\n  // TODO: update database and do the thread merge correctly\n  for (const itemSummaryToAdd of itemSummariesToAdd) {\n    if (!timelineItemIds.has(itemSummaryToAdd.id)) {\n      timelineItemSummaries.push(itemSummaryToAdd)\n    }\n  }\n  const statusId = timelineName.split('/').slice(-1)[0]\n  const sortedTimelineItemSummaries = await sortItemSummariesForThread(timelineItemSummaries, statusId)\n  store.setForTimeline(instanceName, timelineName, {\n    timelineItemSummariesToAdd: [],\n    timelineItemSummaries: sortedTimelineItemSummaries\n  })\n  stop('showMoreItemsForThread')\n}\n","<div class=\"loading-footer {shown ? '' : 'hidden'}\">\n  <div class=\"loading-wrapper {showLoading ? 'shown' : ''}\"\n       aria-hidden={!showLoading}\n       role=\"alert\"\n  >\n    <LoadingSpinner size={48} />\n    <span class=\"loading-footer-info\">\n      Loading moreâ€¦\n    </span>\n  </div>\n  <div class=\"button-wrapper {showLoadButton ? 'shown' : ''}\"\n       aria-hidden={!showLoadButton}\n  >\n    <button type=\"button\"\n            class=\"primary\"\n            on:click=\"onClickLoadMore(event)\">\n      Load more\n    </button>\n  </div>\n</div>\n<style>\n  .loading-footer {\n    padding: 20px 0;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    position: relative;\n  }\n  .loading-wrapper {\n    flex: 1;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    opacity: 0;\n    pointer-events: none;\n    transition: opacity 0.2s linear;\n  }\n  .loading-wrapper.shown {\n    opacity: 1;\n    pointer-events: auto;\n  }\n  .loading-footer-info {\n    margin-left: 20px;\n    font-size: 1.3em;\n  }\n  .button-wrapper {\n    position: absolute;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    top: 0;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    opacity: 0;\n    pointer-events: none;\n    transition: none;\n  }\n  .button-wrapper.shown {\n    opacity: 1;\n    pointer-events: auto;\n    transition: opacity 0.2s linear 0.2s;\n  }\n</style>\n<script>\n  import LoadingSpinner from '../LoadingSpinner.html'\n  import { store } from '../../_store/store'\n  import { fetchMoreItemsAtBottomOfTimeline } from '../../_actions/timeline'\n\n  export default {\n    store: () => store,\n    computed: {\n      shown: ({ $timelineInitialized, $runningUpdate, $disableInfiniteScroll }) => (\n        $timelineInitialized && ($disableInfiniteScroll || $runningUpdate)\n      ),\n      showLoading: ({ $runningUpdate }) => $runningUpdate,\n      showLoadButton: ({ $runningUpdate, $disableInfiniteScroll }) => !$runningUpdate && $disableInfiniteScroll\n    },\n    methods: {\n      onClickLoadMore (e) {\n        e.preventDefault()\n        e.stopPropagation()\n        const { currentInstance, currentTimeline } = this.store.get()\n        /* no await */ fetchMoreItemsAtBottomOfTimeline(currentInstance, currentTimeline)\n        // focus the last item in the timeline; it makes the most sense to me since the button disappears\n        try {\n          // TODO: should probably expose this as an API on the virtual list instead of reaching into the DOM\n          const virtualListItems = document.querySelector('.virtual-list').children\n          const lastItem = virtualListItems[virtualListItems.length - 2] // -2 because the footer is last\n          lastItem.querySelector('article').focus()\n        } catch (e) {\n          console.error(e)\n        }\n      }\n    },\n    components: {\n      LoadingSpinner\n    }\n  }\n</script>\n","<div class=\"more-items-header\">\n  <button class=\"primary\" type=\"button\" on:click=\"onClick(event)\">\n    {showMoreLabel}\n  </button>\n</div>\n<style>\n  .more-items-header {\n    display: flex;\n    padding: 5px;\n    align-items: center;\n    justify-content:center;\n  }\n</style>\n<script>\n  import { formatIntl } from '../../_utils/formatIntl'\n\n  export default {\n    methods: {\n      onClick (event) {\n        const { onClick } = this.get()\n        if (onClick) {\n          onClick(event)\n        }\n      }\n    },\n    computed: {\n      showMoreLabel: ({ count }) => (\n        formatIntl([\"Show \",[\"count\"],\" more\"], { count })\n      )\n    }\n  }\n</script>\n","<MoreHeader count={virtualProps.count}\n            onClick={virtualProps.onClick}\n/>\n<script>\n  import MoreHeader from './MoreHeader.html'\n  export default {\n    components: {\n      MoreHeader\n    }\n  }\n</script>","import {\n  getScrollContainer,\n  getOffsetHeight\n} from './scrollContainer'\nimport { smoothScroll } from './smoothScroll'\n\nlet mainNavElement\nfunction getTopOverlay () {\n  if (!mainNavElement) {\n    mainNavElement = document.getElementById('main-nav')\n  }\n  return mainNavElement.clientHeight\n}\n\nexport function isVisible (element) {\n  if (!element) {\n    return false\n  }\n  const rect = element.getBoundingClientRect()\n  const offsetHeight = getOffsetHeight()\n  const topOverlay = getTopOverlay()\n  return rect.top < offsetHeight && rect.bottom >= topOverlay\n}\n\nexport function firstVisibleElementIndex (elements) {\n  const offsetHeight = getOffsetHeight()\n  const topOverlay = getTopOverlay()\n  let first = -1\n  let firstComplete = -1\n  const len = elements.length\n  let i = -1\n  while (++i < len) {\n    const element = elements[i]\n    if (!element) {\n      continue\n    }\n    const rect = element.getBoundingClientRect()\n    if (rect.top < offsetHeight && rect.bottom >= topOverlay) {\n      first = i\n      firstComplete = (rect.top < topOverlay && i < (len - 1)) ? i + 1 : i\n      break\n    }\n  }\n  return { first, firstComplete }\n}\n\nexport function scrollIntoViewIfNeeded (element) {\n  const rect = element.getBoundingClientRect()\n  const topOverlay = getTopOverlay()\n  const offsetHeight = getOffsetHeight()\n  let scrollY = 0\n  if (rect.top < topOverlay) {\n    scrollY = topOverlay\n  } else if (rect.bottom > offsetHeight) {\n    const height = rect.bottom - rect.top\n    if ((offsetHeight - topOverlay) > height) {\n      scrollY = offsetHeight - height\n    } else {\n      // if element height is too great to fit,\n      // prefer showing the top of the element\n      scrollY = topOverlay\n    }\n  } else {\n    return // not needed\n  }\n  const scrollContainer = getScrollContainer()\n  const scrollTop = scrollContainer.scrollTop\n  smoothScroll(scrollContainer, scrollTop + rect.top - scrollY, /* horizontal */ false, /* preferFast */ false)\n}\n","<script>\n  import {\n    isVisible,\n    firstVisibleElementIndex,\n    scrollIntoViewIfNeeded\n} from '../../_utils/scrollIntoView'\n  import {\n    addShortcutFallback,\n    removeShortcutFallback,\n    onKeyDownInShortcutScope\n} from '../../_utils/shortcuts'\n  import { smoothScroll } from '../../_utils/smoothScroll'\n  import { getScrollContainer } from '../../_utils/scrollContainer'\n  import { store } from '../../_store/store'\n  import { emit } from '../../_utils/eventBus'\n\n  const VISIBILITY_CHECK_DELAY_MS = 600\n\n  const keyToElement = key => document.getElementById(key)\n  const elementToKey = element => element.getAttribute('id')\n  const scope = 'global'\n\n  const shouldIgnoreEvent = event => {\n    // For accessibility reasons, do not override the arrowup/arrowdown behavior for radio buttons\n    // (e.g. in a poll). Up/down is supposed to change the radio value, not the current status.\n    const { target, key } = event\n    const isRadio = target &&\n    target.tagName === 'INPUT' &&\n    target.type === 'radio'\n    const isArrow = key === 'ArrowUp' || key === 'ArrowDown'\n    return isRadio && isArrow\n  }\n\n  export default {\n    data: () => ({\n      activeItemChangeTime: 0,\n      elements: document.getElementsByClassName('shortcut-list-item'),\n      spoilersShown: false\n    }),\n    store: () => store,\n    oncreate () {\n      addShortcutFallback(scope, this)\n    },\n    ondestroy () {\n      removeShortcutFallback(scope, this)\n    },\n    methods: {\n      onKeyDown (event) {\n        if (shouldIgnoreEvent(event)) {\n          return\n        }\n        if (event.key === 'z' && this.store.get().currentTimeline.startsWith('status/')) {\n          // if we're in a thread, toggle all content warnings on or off\n          event.stopPropagation()\n          event.preventDefault()\n          const { spoilersShown } = this.get()\n          emit('toggleAllSpoilers', !spoilersShown)\n          this.set({ spoilersShown: !spoilersShown })\n          return\n        }\n        if (event.key === 'j' || event.key === 'ArrowDown') {\n          event.stopPropagation()\n          event.preventDefault()\n          this.changeActiveItem(1, event.timeStamp)\n          return\n        }\n        if (event.key === 'k' || event.key === 'ArrowUp') {\n          event.stopPropagation()\n          event.preventDefault()\n          this.changeActiveItem(-1, event.timeStamp)\n          return\n        }\n        let activeItemKey = this.checkActiveItem(event.timeStamp)\n        if (!activeItemKey) {\n          const { elements } = this.get()\n          const index = firstVisibleElementIndex(elements).first\n          if (index >= 0) {\n            activeItemKey = elementToKey(elements[index])\n          }\n        }\n        if (activeItemKey) {\n          onKeyDownInShortcutScope(activeItemKey, event)\n        }\n      },\n      changeActiveItem (movement, timeStamp) {\n        const { elements } = this.get()\n        let index = -1\n        let activeItemKey = this.checkActiveItem(timeStamp)\n        if (activeItemKey) {\n          const len = elements.length\n          let i = -1\n          while (++i < len) {\n            if (elementToKey(elements[i]) === activeItemKey) {\n              index = i\n              break\n            }\n          }\n        }\n        if (index === 0 && movement === -1) {\n          activeItemKey = null\n          this.set({ activeItemKey })\n          smoothScroll(getScrollContainer(), 0, /* horizontal */ false, /* preferFast */ false)\n          return\n        }\n        if (index === -1) {\n          const { first, firstComplete } = firstVisibleElementIndex(elements)\n          index = (movement > 0) ? firstComplete : first\n        } else {\n          index += movement\n        }\n        if (index >= 0 && index < elements.length) {\n          activeItemKey = elementToKey(elements[index])\n          this.setActiveItem(activeItemKey, timeStamp)\n          scrollIntoViewIfNeeded(keyToElement(activeItemKey))\n        }\n      },\n      checkActiveItem (timeStamp) {\n        const activeElement = document.activeElement\n        if (!activeElement) {\n          return null\n        }\n        const activeItem = activeElement.getAttribute('id')\n        if (!activeItem) {\n          return null\n        }\n        const { activeItemChangeTime } = this.get()\n        if ((timeStamp - activeItemChangeTime) > VISIBILITY_CHECK_DELAY_MS &&\n            !isVisible(keyToElement(activeItem))) {\n          this.setActiveItem(null, 0)\n          return null\n        }\n        return activeItem\n      },\n      setActiveItem (key, timeStamp) {\n        this.set({ activeItemChangeTime: timeStamp })\n        try {\n          keyToElement(key).focus({\n            preventScroll: true\n          })\n        } catch (err) {\n          console.error('Ignored focus error', err)\n        }\n      }\n    }\n  }\n</script>\n","export default function Worker_fn() {\n  return new Worker(__webpack_public_path__ + \"blurhash.f87cb077f8cbb103ff28.blurhash.js\");\n}\n","import BlurhashWorker from '../_workers/blurhash'\nimport PromiseWorker from 'promise-worker'\nimport { BLURHASH_RESOLUTION as RESOLUTION } from '../_static/blurhash'\nimport { QuickLRU } from '../_thirdparty/quick-lru/quick-lru'\n\n// A timeline will typically show 20-30 articles at once in the virtual list. The maximum number\n// of sensitive images per article is 4. 30*4=120, so this is a very conservative number.\n// Blurhash blobs seem to range from ~1.2-2kB, so this cache could grow to about 2kB*150=300kB max.\nconst cache = new QuickLRU({ maxSize: 150 })\n\nlet worker\nlet canvas\nlet canvasContext2D\n\ncache.on('evict', (evictedUrl, blurhash) => {\n  console.log('evicted URL', evictedUrl, 'with blurhash', blurhash)\n  URL.revokeObjectURL(evictedUrl)\n})\n\nexport function init () {\n  worker = worker || new PromiseWorker(new BlurhashWorker())\n}\n\nfunction initCanvas () {\n  if (!canvas) {\n    canvas = document.createElement('canvas')\n    canvas.height = RESOLUTION\n    canvas.width = RESOLUTION\n    canvasContext2D = canvas.getContext('2d')\n  }\n}\n\n// canvas is the backup if we can't use OffscreenCanvas\nasync function decodeUsingCanvas (imageData) {\n  initCanvas()\n  canvasContext2D.putImageData(imageData, 0, 0)\n  const blob = await new Promise(resolve => canvas.toBlob(resolve))\n  return URL.createObjectURL(blob)\n}\n\nasync function decodeWithoutCache (blurhash) {\n  init()\n  const { decoded, imageData } = await worker.postMessage(blurhash)\n  if (decoded) {\n    return decoded\n  }\n  return decodeUsingCanvas(imageData)\n}\n\nexport async function decode (blurhash) {\n  let result = cache.get(blurhash)\n  if (!result) {\n    result = await decodeWithoutCache(blurhash)\n    cache.set(blurhash, result)\n  }\n  return result\n}\n","export const BLURHASH_RESOLUTION = 32\n","import { database } from '../_database/database'\nimport { decode as decodeBlurhash, init as initBlurhash } from '../_utils/blurhash'\nimport { mark, stop } from '../_utils/marks'\nimport { get } from '../_utils/lodash-lite'\nimport { statusHtmlToPlainText } from '../_utils/statusHtmlToPlainText'\nimport { scheduleIdleTask } from '../_utils/scheduleIdleTask'\n\nasync function getNotification (instanceName, timelineType, timelineValue, itemId) {\n  return {\n    timelineType,\n    timelineValue,\n    notification: await database.getNotification(instanceName, itemId)\n  }\n}\n\nasync function getStatus (instanceName, timelineType, timelineValue, itemId) {\n  return {\n    timelineType,\n    timelineValue,\n    status: await database.getStatus(instanceName, itemId)\n  }\n}\n\nfunction tryInitBlurhash () {\n  try {\n    initBlurhash()\n  } catch (err) {\n    console.error('could not start blurhash worker', err)\n  }\n}\n\nfunction getActualStatus (statusOrNotification) {\n  return get(statusOrNotification, ['status']) ||\n    get(statusOrNotification, ['notification', 'status'])\n}\n\nasync function decodeAllBlurhashes (statusOrNotification) {\n  const status = getActualStatus(statusOrNotification)\n  if (!status) {\n    return\n  }\n  const mediaWithBlurhashes = get(status, ['media_attachments'], [])\n    .concat(get(status, ['reblog', 'media_attachments'], []))\n    .filter(_ => _.blurhash)\n  if (mediaWithBlurhashes.length) {\n    mark(`decodeBlurhash-${status.id}`)\n    await Promise.all(mediaWithBlurhashes.map(async media => {\n      try {\n        media.decodedBlurhash = await decodeBlurhash(media.blurhash)\n      } catch (err) {\n        console.warn('Could not decode blurhash, ignoring', err)\n      }\n    }))\n    stop(`decodeBlurhash-${status.id}`)\n  }\n}\n\nasync function calculatePlainTextContent (statusOrNotification) {\n  const status = getActualStatus(statusOrNotification)\n  if (!status) {\n    return\n  }\n  const originalStatus = status.reblog ? status.reblog : status\n  const content = originalStatus.content || ''\n  const mentions = originalStatus.mentions || []\n  // Calculating the plaintext from the HTML is a non-trivial operation, so we might\n  // as well do it in advance, while blurhash is being decoded on the worker thread.\n  await new Promise(resolve => {\n    scheduleIdleTask(() => {\n      originalStatus.plainTextContent = statusHtmlToPlainText(content, mentions)\n      resolve()\n    })\n  })\n}\n\nexport function createMakeProps (instanceName, timelineType, timelineValue) {\n  let promiseChain = Promise.resolve()\n\n  tryInitBlurhash() // start the blurhash worker a bit early to save time\n\n  async function fetchFromIndexedDB (itemId) {\n    mark(`fetchFromIndexedDB-${itemId}`)\n    try {\n      const res = await (timelineType === 'notifications'\n        ? getNotification(instanceName, timelineType, timelineValue, itemId)\n        : getStatus(instanceName, timelineType, timelineValue, itemId))\n      return res\n    } finally {\n      stop(`fetchFromIndexedDB-${itemId}`)\n    }\n  }\n\n  async function getStatusOrNotification (itemId) {\n    const statusOrNotification = await fetchFromIndexedDB(itemId)\n    await Promise.all([\n      decodeAllBlurhashes(statusOrNotification),\n      calculatePlainTextContent(statusOrNotification)\n    ])\n    return statusOrNotification\n  }\n\n  // The results from IndexedDB or the worker thread can return in random order,\n  // so we ensure consistent ordering based on the order this function is called in.\n  return itemId => {\n    const getStatusOrNotificationPromise = getStatusOrNotification(itemId) // start the promise ASAP\n    return new Promise((resolve, reject) => {\n      promiseChain = promiseChain\n        .then(() => getStatusOrNotificationPromise)\n        .then(resolve, reject)\n    })\n  }\n}\n","<h1 class=\"sr-only\">{label}</h1>\n<FocusRestoration realm={focusRealm}>\n  <div class=\"timeline\" role=\"feed\">\n    {#if components}\n      <svelte:component this={components.listComponent}\n                  component={components.listItemComponent}\n                  realm=\"{$currentInstance + '/' + timeline}\"\n                  {makeProps}\n                  items={itemIds}\n                  showFooter={true}\n                  footerComponent={LoadingFooter}\n                  showHeader={$showHeader}\n                  headerComponent={MoreHeaderVirtualWrapper}\n                  {headerProps}\n                  {scrollToItem}\n                  on:scrollToBottom=\"onScrollToBottom()\"\n                  on:scrollToTop=\"onScrollToTop()\"\n                  on:scrollTopChanged=\"onScrollTopChanged(event)\"\n                  on:initialized=\"initialize()\"\n                  on:noNeedToScroll=\"onNoNeedToScroll()\"\n      />\n    {/if}\n  </div>\n</FocusRestoration>\n<Shortcut scope=\"global\" key=\".\" on:pressed=\"showMoreAndScrollToTop()\" />\n<ScrollListShortcuts />\n<script>\n  import { store } from '../../_store/store'\n  import Status from '../status/Status.html'\n  import LoadingFooter from './LoadingFooter.html'\n  import MoreHeaderVirtualWrapper from './MoreHeaderVirtualWrapper.html'\n  import ScrollListShortcuts from '../shortcut/ScrollListShortcuts.html'\n  import Shortcut from '../shortcut/Shortcut.html'\n  import { importVirtualList } from '../../_utils/asyncModules/importVirtualList'\n  import { importList } from '../../_utils/asyncModules/importList'\n  import { importStatusVirtualListItem } from '../../_utils/asyncModules/importStatusVirtualListItem'\n  import { importNotificationVirtualListItem } from '../../_utils/asyncModules/importNotificationVirtualListItem'\n  import { timelines } from '../../_static/timelines'\n  import {\n    fetchMoreItemsAtBottomOfTimeline,\n    setupTimeline,\n    showMoreItemsForTimeline,\n    showMoreItemsForThread,\n    showMoreItemsForCurrentTimeline\n  } from '../../_actions/timeline'\n  import { scheduleIdleTask } from '../../_utils/scheduleIdleTask'\n  import { mark, stop } from '../../_utils/marks'\n  import isEqual from 'lodash-es/isEqual'\n  import { doubleRAF } from '../../_utils/doubleRAF'\n  import { observe } from 'svelte-extras'\n  import { createMakeProps } from '../../_actions/createMakeProps'\n  import { showMoreAndScrollToTop } from '../../_actions/showMoreAndScrollToTop'\n  import FocusRestoration from '../FocusRestoration.html'\n\n  export default {\n    oncreate () {\n      console.log('timeline oncreate()')\n      setupTimeline()\n      this.setupStreaming()\n      this.setupAsyncComponents()\n    },\n    data: () => ({\n      LoadingFooter,\n      MoreHeaderVirtualWrapper,\n      Status,\n      scrollTop: 0,\n      components: undefined\n    }),\n    computed: {\n      // For threads, it's simpler to just render all items as a pseudo-virtual list\n      // due to need to scroll to the right item and thus calculate all item heights up-front.\n      // Here we lazy-load both the virtual list component itself as well as the component\n      // it renders.\n      componentsPromise: ({ timelineType }) => {\n        return Promise.all([\n          timelineType === 'status'\n            ? importList()\n            : importVirtualList(),\n          timelineType === 'notifications'\n            ? importNotificationVirtualListItem()\n            : importStatusVirtualListItem()\n        ]).then(results => ({\n          listComponent: results[0],\n          listItemComponent: results[1]\n        }))\n      },\n      makeProps: ({ $currentInstance, timelineType, timelineValue }) => (\n        createMakeProps($currentInstance, timelineType, timelineValue)\n      ),\n      label: ({ timeline, $currentInstance, timelineType, timelineValue }) => {\n        if (timelines[timeline]) {\n          return `Statuses: ${timelines[timeline].label} timeline on ${$currentInstance}`\n        }\n\n        switch (timelineType) {\n          case 'tag':\n            return `Statuses: #${timelineValue} hashtag`\n          case 'status':\n            return 'Statuses: thread'\n          case 'account':\n            return 'Statuses: account timeline'\n          case 'list':\n            return 'Statuses: list'\n          case 'notifications':\n            return `Notifications on ${$currentInstance}`\n        }\n      },\n      timelineType: ({ $currentTimelineType }) => $currentTimelineType,\n      timelineValue: ({ $currentTimelineValue }) => $currentTimelineValue,\n      // Scroll to the first item if this is a \"status in own thread\" timeline.\n      // Don't scroll to the first item because it obscures the \"back\" button.\n      scrollToItem: ({ timelineType, timelineValue, $firstTimelineItemId }) => (\n        timelineType === 'status' &&\n        $firstTimelineItemId &&\n        timelineValue !== $firstTimelineItemId &&\n        timelineValue\n      ),\n      itemIds: ({ $filteredTimelineItemSummaries }) => (\n        $filteredTimelineItemSummaries && $filteredTimelineItemSummaries.map(_ => _.id)\n      ),\n      itemIdsToAdd: ({ $filteredTimelineItemSummariesToAdd }) => (\n        $filteredTimelineItemSummariesToAdd && $filteredTimelineItemSummariesToAdd.map(_ => _.id)\n      ),\n      headerProps: ({ itemIdsToAdd }) => {\n        return {\n          count: itemIdsToAdd ? itemIdsToAdd.length : 0,\n          onClick: showMoreItemsForCurrentTimeline\n        }\n      },\n      focusRealm: ({ $currentInstance, timeline }) => `${$currentInstance}-${timeline}`\n    },\n    store: () => store,\n    methods: {\n      observe,\n      initialize () {\n        const { initializeStarted } = this.get()\n        if (initializeStarted) {\n          return\n        }\n        this.set({ initializeStarted: true })\n        mark('initializeTimeline')\n        doubleRAF(() => {\n          console.log('timeline initialized')\n          this.store.set({ timelineInitialized: true })\n          stop('initializeTimeline')\n        })\n      },\n      onScrollTopChanged (scrollTop) {\n        this.set({ scrollTop: scrollTop })\n      },\n      onScrollToBottom () {\n        const { timelineType } = this.get()\n        const { timelineInitialized, runningUpdate, disableInfiniteScroll } = this.store.get()\n        if (!timelineInitialized ||\n            runningUpdate ||\n            disableInfiniteScroll ||\n            timelineType === 'status') { // for status contexts, we've already fetched the whole thread\n          return\n        }\n        const { currentInstance } = this.store.get()\n        const { timeline } = this.get()\n        /* no await */ fetchMoreItemsAtBottomOfTimeline(currentInstance, timeline)\n      },\n      onScrollToTop () {\n        const { shouldShowHeader } = this.store.get()\n        if (shouldShowHeader) {\n          this.store.setForCurrentTimeline({\n            showHeader: true,\n            shouldShowHeader: false\n          })\n        }\n      },\n      setupStreaming () {\n        const { currentInstance, disableInfiniteScroll } = this.store.get()\n        const { timeline, timelineType } = this.get()\n        const handleItemIdsToAdd = () => {\n          const { itemIdsToAdd } = this.get()\n          if (!itemIdsToAdd || !itemIdsToAdd.length) {\n            return\n          }\n          mark('handleItemIdsToAdd')\n          const { scrollTop } = this.get()\n          const {\n            shouldShowHeader,\n            showHeader\n          } = this.store.get()\n          if (timelineType === 'status') {\n            // this is a thread, just insert the statuses already\n            showMoreItemsForThread(currentInstance, timeline)\n          } else if (!disableInfiniteScroll && scrollTop === 0 && !shouldShowHeader && !showHeader) {\n            // if the user is scrolled to the top and we're not showing the header, then\n            // just insert the statuses. this is \"chat room mode\"\n            showMoreItemsForTimeline(currentInstance, timeline)\n          } else {\n            // user hasn't scrolled to the top, show a header instead\n            this.store.setForTimeline(currentInstance, timeline, { shouldShowHeader: true })\n            // unless the user has disabled infinite scroll entirely\n            if (disableInfiniteScroll) {\n              this.store.setForTimeline(currentInstance, timeline, { showHeader: true })\n            }\n          }\n          stop('handleItemIdsToAdd')\n        }\n        this.observe('itemIdsToAdd', (newItemIdsToAdd, oldItemIdsToAdd) => {\n          if (!newItemIdsToAdd ||\n              !newItemIdsToAdd.length ||\n              isEqual(newItemIdsToAdd, oldItemIdsToAdd)) {\n            return\n          }\n          scheduleIdleTask(handleItemIdsToAdd)\n        })\n      },\n      setupAsyncComponents () {\n        this.observe('componentsPromise', async componentsPromise => {\n          if (componentsPromise) {\n            console.log('loading timeline components')\n            const components = await componentsPromise\n            console.log('loaded timeline components')\n            this.set({ components })\n          }\n        })\n      },\n      onNoNeedToScroll () {\n        // If the timeline doesn't need to scroll, then we can safely \"preinitialize,\"\n        // i.e. render anything above the fold of the timeline. This avoids the affect\n        // where the scrollable content appears to jump around if we need to scroll it.\n        console.log('timeline preinitialized')\n        this.store.set({ timelinePreinitialized: true })\n      },\n      showMoreAndScrollToTop\n    },\n    components: {\n      ScrollListShortcuts,\n      Shortcut,\n      FocusRestoration\n    }\n  }\n</script>\n","import { showMoreItemsForCurrentTimeline } from './timeline'\nimport { scrollToTop } from '../_utils/scrollToTop'\nimport { createStatusOrNotificationUuid } from '../_utils/createStatusOrNotificationUuid'\nimport { store } from '../_store/store'\nimport { tryToFocusElement } from '../_utils/tryToFocusElement'\n\nexport function showMoreAndScrollToTop () {\n  // Similar to Twitter, pressing \".\" will click the \"show more\" button and select\n  // the first toot.\n  showMoreItemsForCurrentTimeline()\n  const {\n    currentInstance,\n    timelineItemSummaries,\n    currentTimelineType,\n    currentTimelineValue\n  } = store.get()\n  const firstItemSummary = timelineItemSummaries && timelineItemSummaries[0]\n  if (!firstItemSummary) {\n    return\n  }\n  const notificationId = currentTimelineType === 'notifications' && firstItemSummary.id\n  const statusId = currentTimelineType !== 'notifications' && firstItemSummary.id\n  scrollToTop(/* smooth */ false)\n  const id = createStatusOrNotificationUuid(\n    currentInstance, currentTimelineType,\n    currentTimelineValue, notificationId, statusId\n  )\n  tryToFocusElement(id)\n}\n","export const importList = () => import(\n  '../../_components/list/List.html'\n).then(mod => mod.default)\n","export const importVirtualList = () => import(\n  '../../_components/virtualList/VirtualList.html'\n).then(mod => mod.default)\n","export const importNotificationVirtualListItem = () => import(\n  '../../_components/timeline/NotificationVirtualListItem.html'\n).then(mod => mod.default)\n","export const importStatusVirtualListItem = () => import(\n  '../../_components/timeline/StatusVirtualListItem.html'\n).then(mod => mod.default)\n","import { getWithHeaders, paramsString, DEFAULT_TIMEOUT } from '../_utils/ajax'\nimport { auth, basename } from './utils'\n\nfunction getTimelineUrlPath (timeline) {\n  switch (timeline) {\n    case 'local':\n    case 'federated':\n      return 'timelines/public'\n    case 'home':\n      return 'timelines/home'\n    case 'notifications':\n    case 'notifications/mentions':\n      return 'notifications'\n    case 'favorites':\n      return 'favourites'\n    case 'direct':\n      return 'conversations'\n    case 'bookmarks':\n      return 'bookmarks'\n  }\n  if (timeline.startsWith('tag/')) {\n    return 'timelines/tag'\n  } else if (timeline.startsWith('account/')) {\n    return 'accounts'\n  } else if (timeline.startsWith('list/')) {\n    return 'timelines/list'\n  }\n  throw new Error(`Invalid timeline type: ${timeline}`)\n}\n\nexport async function getTimeline (instanceName, accessToken, timeline, maxId, since, limit) {\n  const timelineUrlName = getTimelineUrlPath(timeline)\n  let url = `${basename(instanceName)}/api/v1/${timelineUrlName}`\n\n  if (timeline.startsWith('tag/')) {\n    url += '/' + timeline.split('/')[1]\n  } else if (timeline.startsWith('account/')) {\n    url += '/' + timeline.split('/')[1] + '/statuses'\n  } else if (timeline.startsWith('list/')) {\n    url += '/' + timeline.split('/')[1]\n  }\n\n  const params = {}\n  if (since) {\n    params.since_id = since\n  }\n\n  if (maxId) {\n    params.max_id = maxId\n  }\n\n  if (limit) {\n    params.limit = limit\n  }\n\n  if (timeline === 'local') {\n    params.local = true\n  }\n\n  if (timeline.startsWith('account/')) {\n    if (timeline.endsWith('media')) {\n      params.only_media = true\n    } else {\n      params.exclude_replies = !timeline.endsWith('/with_replies')\n    }\n  }\n\n  if (timeline === 'notifications/mentions') {\n    params.exclude_types = ['follow', 'favourite', 'reblog', 'poll']\n  }\n\n  url += '?' + paramsString(params)\n\n  console.log('fetching url', url)\n  let { json: items, headers } = await getWithHeaders(url, auth(accessToken), { timeout: DEFAULT_TIMEOUT })\n\n  if (timeline === 'direct') {\n    items = items.map(item => item.last_status)\n  }\n  return { items, headers }\n}\n","export const TIMELINE_BATCH_SIZE = 20\n\nexport const timelines = {\n  home: { name: 'home', label: \"Home\" },\n  local: { name: 'local', label: \"Local\" },\n  federated: { name: 'federated', label: \"Federated\" }\n}\n","import { mark, stop } from './marks'\nimport { massageStatusPlainText } from './massageStatusPlainText'\n\nconst domParser = process.browser && new DOMParser()\n\n// mentions like \"@foo\" have to be expanded to \"@foo@example.com\"\nfunction massageMentions (doc, mentions) {\n  const anchors = doc.querySelectorAll('a.mention')\n  for (let i = 0; i < anchors.length; i++) {\n    const anchor = anchors[i]\n    const href = anchor.getAttribute('href')\n    const mention = mentions.find(mention => mention.url === href)\n    if (mention) {\n      anchor.innerText = `@${mention.acct}`\n    }\n  }\n}\n\n// paragraphs should be separated by double newlines\n// single <br/>s should become single newlines\nfunction innerTextRetainingNewlines (doc) {\n  let res = ''\n  const paragraphs = doc.querySelectorAll('p')\n  for (let i = 0; i < paragraphs.length; i++) {\n    const paragraph = paragraphs[i]\n    const brs = paragraph.querySelectorAll('br')\n    for (let j = 0; j < brs.length; j++) {\n      const br = brs[j]\n      br.parentNode.replaceChild(doc.createTextNode('\\n'), br)\n    }\n    res += (i > 0 ? '\\n\\n' : '') + paragraph.textContent\n  }\n  return res\n}\n\nexport function statusHtmlToPlainText (html, mentions) {\n  if (!html) {\n    return ''\n  }\n  mark('statusHtmlToPlainText')\n  html = massageStatusPlainText(html)\n  const doc = domParser.parseFromString(html, 'text/html')\n  massageMentions(doc, mentions)\n  const res = innerTextRetainingNewlines(doc)\n  stop('statusHtmlToPlainText')\n  return res\n}\n","// Pleroma uses base62 IDs, Mastodon uses 0-9 big ints encoded as strings.\n// Using base62 for both works, since the first 10 characters of base62\n// are 0-9.\n\nimport { padStart } from './lodash-lite'\n\n// Pleroma uses the 0-9A-Za-z alphabet for base62, which is the same as ASCII, which\n// is the same as JavaScript sort order and IndexedDB order.\nconst MIN_CHAR_CODE = 48 // '0'.charCodeAt(0)\nconst MAX_CHAR_CODE = 122 // 'z'.charCodeAt(0)\nconst MAX_ID_LENGTH = 30 // assume that Mastodon/Pleroma IDs won't get any bigger than this\n\nexport function zeroPad (str, toSize) {\n  return padStart(str, toSize, '0')\n}\n\nexport function toPaddedBigInt (id) {\n  return zeroPad(id, MAX_ID_LENGTH)\n}\n\nexport function toReversePaddedBigInt (id) {\n  const padded = toPaddedBigInt(id)\n  let reversed = ''\n  for (let i = 0; i < padded.length; i++) {\n    const charCode = padded.charCodeAt(i)\n    const inverseCharCode = MIN_CHAR_CODE + MAX_CHAR_CODE - charCode\n    reversed += String.fromCharCode(inverseCharCode)\n  }\n  return reversed\n}\n\nexport function compareTimelineItemSummaries (left, right) {\n  const leftPadded = toPaddedBigInt(left.id)\n  const rightPadded = toPaddedBigInt(right.id)\n  return leftPadded < rightPadded ? -1 : leftPadded === rightPadded ? 0 : 1\n}\n"],"sourceRoot":""}