{"version":3,"sources":["webpack://pinafore/./src/routes/_components/FocusRestoration.html","webpack://pinafore/./src/routes/_static/pages.js","webpack://pinafore/./src/routes/_thirdparty/quick-lru/quick-lru.js","webpack://pinafore/./src/routes/_utils/tryToFocusElement.js"],"names":["cache","maxSize","window","__focusRestorationCache","this","onPushState","bind","setInCache","ignoreBlurEvents","addEventListener","removeEventListener","obj","realm","get","has","set","Object","assign","key","elementId","getInCache","deleteInCache","e","element","target","getAttribute","setupPushState","restoreFocus","teardownPushState","saveFocus","event","clearFocus","PAGE_HISTORY_SIZE","QuickLRU","EventEmitter","options","super","TypeError","Map","oldCache","_size","value","listenerCount","keys","emit","delete","_set","deleted","clear","Set","add","async","tryToFocusElement","id","i","Promise","resolve","setTimeout","document","getElementById","focus","preventScroll","console","error"],"mappings":"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","file":"2845.4845bce66f852fffa712.2845.js","sourcesContent":["<div\n  on:focusin=\"saveFocus(event)\"\n  on:focusout=\"clearFocus()\"\n>\n  <slot></slot>\n</div>\n<script>\n  import { PAGE_HISTORY_SIZE } from '../_static/pages'\n  import { QuickLRU } from '../_thirdparty/quick-lru/quick-lru'\n  import { tryToFocusElement } from '../_utils/tryToFocusElement'\n\n  const cache = new QuickLRU({ maxSize: PAGE_HISTORY_SIZE })\n\n  if (process.browser) {\n    window.__focusRestorationCache = cache\n  }\n\n  export default {\n    oncreate () {\n      this.setupPushState()\n      this.restoreFocus()\n      if (process.env.NODE_ENV !== 'production') {\n        if (!this.get().realm) {\n          throw new Error('FocusRestoration needs a realm')\n        }\n      }\n    },\n    ondestroy () {\n      this.teardownPushState()\n    },\n    methods: {\n      setupPushState () {\n        this.onPushState = this.onPushState.bind(this)\n        this.setInCache({ ignoreBlurEvents: false })\n        window.addEventListener('pushState', this.onPushState)\n      },\n      teardownPushState () {\n        window.removeEventListener('pushState', this.onPushState)\n      },\n      setInCache (obj) {\n        const { realm } = this.get()\n        if (!cache.has(realm)) {\n          cache.set(realm, {})\n        }\n        Object.assign(cache.get(realm), obj)\n      },\n      deleteInCache (key) {\n        const { realm } = this.get()\n        if (cache.has(realm)) {\n          delete cache.get(realm)[key]\n        }\n      },\n      getInCache () {\n        const { realm } = this.get()\n        return cache.get(realm) || {}\n      },\n      onPushState () {\n        this.setInCache({ ignoreBlurEvents: true })\n      },\n      restoreFocus () {\n        const { realm } = this.get()\n        const { elementId } = this.getInCache()\n        if (!elementId) {\n          return\n        }\n        console.log('restoreFocus', realm, elementId)\n        tryToFocusElement(elementId)\n      },\n      clearFocus () {\n        const { realm } = this.get()\n        const { ignoreBlurEvents } = this.getInCache()\n        if (!ignoreBlurEvents) {\n          console.log('clearFocus', realm)\n          this.deleteInCache('elementId')\n        }\n      },\n      saveFocus (e) {\n        const { realm } = this.get()\n        const element = e.target\n        if (element) {\n          const elementId = element.getAttribute('id')\n          if (elementId) {\n            console.log('saveFocus', realm, elementId)\n            this.setInCache({ elementId })\n          }\n        }\n      }\n    }\n  }\n</script>\n","export const PAGE_HISTORY_SIZE = 10\n","// Forked from https://github.com/sindresorhus/quick-lru/blob/16d15d470a8eb87c2a7dd5b80892d9b74f1acd3c/index.js\n// Adds the ability to listen for 'evict' events using an EventEmitter, also removes some unused code\n\nimport { EventEmitter } from 'events-light'\n\nexport class QuickLRU extends EventEmitter {\n  constructor (options = {}) {\n    super()\n    if (!(options.maxSize && options.maxSize > 0)) {\n      throw new TypeError('`maxSize` must be a number greater than 0')\n    }\n\n    this.maxSize = options.maxSize\n    this.cache = new Map()\n    this.oldCache = new Map()\n    this._size = 0\n  }\n\n  _set (key, value) {\n    this.cache.set(key, value)\n    this._size++\n\n    if (this._size >= this.maxSize) {\n      this._size = 0\n      if (this.listenerCount('evict')) {\n        for (const key of this.oldCache.keys()) {\n          if (!this.cache.has(key)) {\n            this.emit('evict', this.oldCache.get(key), key)\n          }\n        }\n      }\n      this.oldCache = this.cache\n      this.cache = new Map()\n    }\n  }\n\n  get (key) {\n    if (this.cache.has(key)) {\n      return this.cache.get(key)\n    }\n\n    if (this.oldCache.has(key)) {\n      const value = this.oldCache.get(key)\n      this.oldCache.delete(key)\n      this._set(key, value)\n      return value\n    }\n  }\n\n  set (key, value) {\n    if (this.cache.has(key)) {\n      this.cache.set(key, value)\n    } else {\n      this._set(key, value)\n    }\n\n    return this\n  }\n\n  has (key) {\n    return this.cache.has(key) || this.oldCache.has(key)\n  }\n\n  // unused\n  // peek (key) {\n  //   if (this.cache.has(key)) {\n  //     return this.cache.get(key)\n  //   }\n  //\n  //   if (this.oldCache.has(key)) {\n  //     return this.oldCache.get(key)\n  //   }\n  // }\n\n  delete (key) {\n    const deleted = this.cache.delete(key)\n    if (deleted) {\n      this._size--\n    }\n\n    return this.oldCache.delete(key) || deleted\n  }\n\n  clear () {\n    this.cache.clear()\n    this.oldCache.clear()\n    this._size = 0\n  }\n\n  getAllKeys () {\n    const set = new Set()\n    for (const key of this.cache.keys()) {\n      set.add(key)\n    }\n    for (const key of this.oldCache.keys()) {\n      set.add(key)\n    }\n    return set\n  }\n\n  // unused\n  // * keys() {\n  //   for (const [key] of this) {\n  //     yield key;\n  //   }\n  // }\n  //\n  // * values() {\n  //   for (const [, value] of this) {\n  //     yield value;\n  //   }\n  // }\n  //\n  // * [Symbol.iterator]() {\n  //   for (const item of this.cache) {\n  //     yield item;\n  //   }\n  //\n  //   for (const item of this.oldCache) {\n  //     const [key] = item;\n  //     if (!this.cache.has(key)) {\n  //       yield item;\n  //     }\n  //   }\n  // }\n  //\n  // get size () {\n  //   let oldCacheSize = 0\n  //   for (const key of this.oldCache.keys()) {\n  //     if (!this.cache.has(key)) {\n  //       oldCacheSize++\n  //     }\n  //   }\n  //\n  //   return this._size + oldCacheSize\n  // }\n}\n","// try 5 times to wait for the element to be rendered and then focus it\nimport { scheduleIdleTask } from './scheduleIdleTask'\n\nconst RETRIES = 5\nconst TIMEOUT = 50\n\nexport async function tryToFocusElement (id) {\n  for (let i = 0; i < RETRIES; i++) {\n    if (i > 0) {\n      await new Promise(resolve => setTimeout(resolve, TIMEOUT))\n    }\n    await new Promise(resolve => scheduleIdleTask(resolve))\n    const element = document.getElementById(id)\n    if (element) {\n      try {\n        element.focus({ preventScroll: true })\n        console.log('focused element', id)\n        return\n      } catch (e) {\n        console.error(e)\n      }\n    }\n  }\n  console.log('failed to focus element', id)\n}\n"],"sourceRoot":""}