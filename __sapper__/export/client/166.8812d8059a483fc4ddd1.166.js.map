{"version":3,"sources":["webpack://pinafore/./src/routes/_database/constants.js","webpack://pinafore/./src/routes/_database/cache.js","webpack://pinafore/./src/routes/_thirdparty/idb-keyval/idb-keyval.js","webpack://pinafore/./src/routes/_database/knownInstances.js","webpack://pinafore/./src/routes/_database/migrations.js","webpack://pinafore/./src/routes/_database/databaseLifecycle.js","webpack://pinafore/./src/routes/_database/helpers.js","webpack://pinafore/./src/routes/_database/keys.js","webpack://pinafore/./src/routes/_database/accounts.js","webpack://pinafore/./src/routes/_database/clear.js","webpack://pinafore/./src/routes/_database/timelines/lookup.js","webpack://pinafore/./src/routes/_database/timelines/cacheStatus.js","webpack://pinafore/./src/routes/_database/utils.js","webpack://pinafore/./src/routes/_database/cleanup.js","webpack://pinafore/./src/routes/_database/timelines/insertion.js","webpack://pinafore/./src/routes/_database/timelines/fetchAccount.js","webpack://pinafore/./src/routes/_database/timelines/fetchStatus.js","webpack://pinafore/./src/routes/_database/timelines/pinnedStatuses.js","webpack://pinafore/./src/routes/_database/timelines/fetchNotification.js","webpack://pinafore/./src/routes/_database/timelines/pagination.js","webpack://pinafore/./src/routes/_database/timelines/getStatusOrNotification.js","webpack://pinafore/./src/routes/_database/timelines/updateStatus.js","webpack://pinafore/./src/routes/_database/timelines/deletion.js","webpack://pinafore/./src/routes/_database/meta.js","webpack://pinafore/./src/routes/_database/relationships.js","webpack://pinafore/./src/routes/_static/share.js","webpack://pinafore/./src/routes/_database/webShare.js","webpack://pinafore/./src/routes/_database/mediaUploadFileCache.js","webpack://pinafore/./src/routes/_static/database.js","webpack://pinafore/./src/routes/_static/timelines.js","webpack://pinafore/./src/routes/_thirdparty/quick-lru/quick-lru.js","webpack://pinafore/./src/routes/_utils/statusIdSorting.js"],"names":["STATUSES_STORE","STATUS_TIMELINES_STORE","META_STORE","ACCOUNTS_STORE","RELATIONSHIPS_STORE","NOTIFICATIONS_STORE","NOTIFICATION_TIMELINES_STORE","PINNED_STATUSES_STORE","THREADS_STORE","TIMESTAMP","ACCOUNT_ID","STATUS_ID","REBLOG_ID","USERNAME_LOWERCASE","DB_VERSION_CURRENT","CURRENT_TIME","Date","now","statusesCache","maxSize","caches","accountsCache","relationshipsCache","metaCache","notificationsCache","getOrCreateInstanceCache","cache","instanceName","cached","clearCache","clearAllCaches","allCaches","setInCache","key","value","set","getInCache","get","hasInCache","has","deleteFromCache","delete","Store","dbName","storeName","this","_dbName","_storeName","_init","type","callback","_dbp","then","db","Promise","resolve","reject","transaction","oncomplete","onabort","onerror","error","objectStore","openreq","indexedDB","open","onsuccess","result","onupgradeneeded","createObjectStore","close","undefined","store","getDefaultStore","req","_withIDBStore","put","del","keys","openKeyCursor","openCursor","call","push","continue","_close","lifecycle","async","event","newState","PREFIX","migrations","version","migration","tx","done","name","init","indexes","Object","forEach","indexKey","createIndex","keyPath","statusId","notificationId","stores","storeDoneCount","e","target","newKey","split","add","length","openReqs","databaseCache","getDatabase","Error","onblocked","console","currentTarget","migrationsToDo","filter","oldVersion","doNextMigration","shift","createDatabase","addKnownInstance","dbPromise","readOnlyOrReadWrite","cb","map","res","deleteDatabase","openReq","deleteKnownInstance","getGenericEntityWithId","id","setGenericEntityWithId","entity","cloneForStorage","obj","Array","isArray","toLowerCase","createTimelineId","timeline","createTimelineKeyRange","maxId","negBigInt","start","end","IDBKeyRange","bound","createThreadId","i","createThreadKeyRange","createPinnedStatusKeyRange","accountId","getAccount","setAccount","account","searchAccountsByUsername","usernamePrefix","limit","accountsStore","keyRange","accountUsernamePrefix","index","getAll","clearDatabaseForInstance","getReblogsForStatus","statusesStore","only","getNotificationIdsForStatuses","statusIds","notificationsStore","getAllKeys","cacheStatus","status","reblog","closeDatabase","scheduleIdleTask","deleteAll","batchedGetAll","callGetAll","nextBatch","results","cleanup","storeNames","statusTimelinesStore","notificationTimelinesStore","relationshipsStore","threadsStore","pinnedStatusesStore","cutoff","upperBound","cleanupStatuses","cleanupNotifications","cleanupAccounts","relationshipId","cleanupRelationships","s","doCleanup","scheduleCleanup","debounce","knownInstances","_","startsWith","substring","getKnownInstances","instance","putStatus","putAccount","storeStatus","storeNotification","notification","storeAccount","putNotification","insertTimelineItems","timelineItems","notifications","timelineStore","insertTimelineNotifications","statuses","existingKeys","newKeys","times","keysToDelete","difference","otherStatus","insertStatusThread","slice","insertTimelineStatuses","insertStatus","fetchAccount","fetchStatus","insertPinnedStatuses","existingPinnedStatuses","createPinnedStatusId","getPinnedStatuses","pinnedResults","fetchNotification","getTimeline","timelineResults","getNotificationTimeline","thread","otherStatusId","getStatusThread","getStatusTimeline","getStatus","getNotification","updateStatus","updateFunc","setStatusFavorited","favorited","delta","favourited","favourites_count","setStatusReblogged","reblogged","reblogs_count","setStatusPinned","pinned","setStatusMuted","muted","setStatusBookmarked","bookmarked","deleteStatusesAndNotifications","notificationIds","deleteStatus","deleteNotification","getMetaProperty","setMetaProperty","getInstanceVerifyCredentials","setInstanceVerifyCredentials","getInstanceInfo","setInstanceInfo","getLists","setLists","getCustomEmoji","setCustomEmoji","getFollowRequestCount","setFollowRequestCount","getFilters","setFilters","getRelationship","setRelationship","relationship","WEB_SHARE_TARGET_DATA_IDB_KEY","deleteWebShareData","setWebShareData","data","getWebShareData","closeKeyValIDBConnection","DELIMITER","DELETE_AFTER","deleteAfter","keyToData","indexOf","sort","getCachedMediaFile","allKeys","setCachedMediaFile","file","includes","timestamp","parse","dataToKey","toISOString","deleteCachedMediaFile","getAllCachedFileIds","setDeleteCachedMediaFilesAfter","newDeleteAfter","CLEANUP_TIME_AGO","CLEANUP_DELAY","TIMELINE_BATCH_SIZE","timelines","home","label","local","federated","QuickLRU","EventEmitter","options","super","TypeError","Map","oldCache","_size","listenerCount","emit","_set","deleted","clear","Set","zeroPad","str","toSize","toPaddedBigInt","toReversePaddedBigInt","padded","reversed","inverseCharCode","MIN_CHAR_CODE","charCodeAt","String","fromCharCode","compareTimelineItemSummaries","left","right","leftPadded","rightPadded"],"mappings":"mrCAAO,MAAMA,EAAiB,cACjBC,EAAyB,sBACzBC,EAAa,UACbC,EAAiB,cACjBC,EAAsB,mBACtBC,EAAsB,mBACtBC,EAA+B,4BAC/BC,EAAwB,qBACxBC,EAAgB,aAEhBC,EAAY,gBACZC,EAAa,qBACbC,EAAY,uBACZC,EAAY,uBACZC,EAAqB,qBAOrBC,EAAgC,GAChCC,EAAsB,IAAMC,KAAKC,M,cCpBvC,MAAMC,EAAgB,CAC3BC,QAAS,IACTC,OAAQ,IAEGC,EAAgB,CAC3BF,QAAS,GACTC,OAAQ,IAEGE,EAAqB,CAChCH,QAAS,GACTC,OAAQ,IAEGG,EAAY,CACvBJ,QAAS,GACTC,OAAQ,IAEGI,EAAqB,CAChCL,QAAS,GACTC,OAAQ,IAaV,SAASK,EAA0BC,EAAOC,GACxC,IAAIC,EAASF,EAAMN,OAAOO,GAI1B,OAHKC,IACHA,EAASF,EAAMN,OAAOO,GAAgB,IAAI,IAAS,CAAER,QAASO,EAAMP,WAE/DS,EAGF,SAASC,EAAYH,EAAOC,UAC1BD,EAAMN,OAAOO,GAEf,SAASG,EAAgBH,GAC9B,MAAMI,EAAY,CAACb,EAAeG,EAAeC,EAAoBC,EAAWC,GAChF,IAAK,MAAME,KAASK,EAClBF,EAAWH,EAAOC,GAGf,SAASK,EAAYN,EAAOC,EAAcM,EAAKC,GAEpD,OADsBT,EAAyBC,EAAOC,GACjCQ,IAAIF,EAAKC,GAGzB,SAASE,EAAYV,EAAOC,EAAcM,GAE/C,OADsBR,EAAyBC,EAAOC,GACjCU,IAAIJ,GAGpB,SAASK,EAAYZ,EAAOC,EAAcM,GAU/C,OATsBR,EAAyBC,EAAOC,GAC5BY,IAAIN,GAWzB,SAASO,EAAiBd,EAAOC,EAAcM,GAC9BR,EAAyBC,EAAOC,GACxCc,OAAOR,G,aCtEvB,MAAMS,EACJ,YAAaC,EAAS,eAAgBC,EAAY,UAChDC,KAAKD,UAAYA,EACjBC,KAAKC,QAAUH,EACfE,KAAKE,WAAaH,EAClBC,KAAKG,QAGP,cAAeC,EAAMC,GAEnB,OADAL,KAAKG,QACEH,KAAKM,KAAKC,MAAKC,GAAM,IAAIC,SAAQ,CAACC,EAASC,KAChD,MAAMC,EAAcJ,EAAGI,YAAYZ,KAAKD,UAAWK,GACnDQ,EAAYC,WAAa,IAAMH,IAC/BE,EAAYE,QAAUF,EAAYG,QAAU,IAAMJ,EAAOC,EAAYI,OACrEX,EAASO,EAAYK,YAAYjB,KAAKD,iBAI1C,QACMC,KAAKM,OAGTN,KAAKM,KAAO,IAAIG,SAAQ,CAACC,EAASC,KAChC,MAAMO,EAAUC,UAAUC,KAAKpB,KAAKC,QAAS,GAC7CiB,EAAQH,QAAU,IAAMJ,EAAOO,EAAQF,OACvCE,EAAQG,UAAY,IAAMX,EAAQQ,EAAQI,QAE1CJ,EAAQK,gBAAkB,KACxBL,EAAQI,OAAOE,kBAAkBxB,KAAKE,iBAK5C,SAEE,OADAF,KAAKG,QACEH,KAAKM,KAAKC,MAAKC,IACpBA,EAAGiB,QACHzB,KAAKM,UAAOoB,MAKlB,IAAIC,EAEJ,SAASC,IAIP,OAHKD,IACHA,EAAQ,IAAI9B,GAEP8B,EAGT,SAASnC,EAAKJ,GAEZ,IAAIyC,EACJ,OAFcD,IAEDE,cAAc,YAAYH,IACrCE,EAAMF,EAAMnC,IAAIJ,MACfmB,MAAK,IAAMsB,EAAIP,SAGpB,SAAShC,EAAKF,EAAKC,GAEjB,OADcuC,IACDE,cAAc,aAAaH,IACtCA,EAAMI,IAAI1C,EAAOD,MAIrB,SAAS4C,EAAK5C,GAEZ,OADcwC,IACDE,cAAc,aAAaH,IACtCA,EAAM/B,OAAOR,MAWjB,SAAS6C,IACP,MAAMN,EAAQC,IACRK,EAAO,GACb,OAAON,EAAMG,cAAc,YAAYH,KAGpCA,EAAMO,eAAiBP,EAAMQ,YAAYC,KAAKT,GAAON,UAAY,WAC3DrB,KAAKsB,SAGVW,EAAKI,KAAKrC,KAAKsB,OAAOlC,KACtBY,KAAKsB,OAAOgB,gBAEb/B,MAAK,IAAM0B,IAGhB,SAAS,IAEP,OADcL,IACDW,SAIbC,EAAA,mBAA2B,eAAeC,UACjB,WAAnBC,EAAMC,gBACF,OC3GZ,MAAMC,EAAS,kB,aCyFR,MAAMC,EAAa,CACxB,CACEC,QJ7E8B,EI8E9BC,UAjFJ,SAA2BvC,EAAIwC,EAAIC,GACjC,SAASzB,EAAmB0B,EAAMC,EAAMC,GACtC,MAAMzB,EAAQwB,EACV3C,EAAGgB,kBAAkB0B,EAAMC,GAC3B3C,EAAGgB,kBAAkB0B,GACrBE,GACFC,OAAOpB,KAAKmB,GAASE,SAAQC,IAC3B5B,EAAM6B,YAAYD,EAAUH,EAAQG,OAK1C/B,EAAkBrE,EAAgB,CAAEsG,QAAS,MAAQ,CACnD,CAAC7F,GAAYA,EACb,CAACG,GAAYA,IAEfyD,EAAkBpE,EAAwB,KAAM,CAC9CsG,SAAU,KAEZlC,EAAkBhE,EAAqB,CAAEiG,QAAS,MAAQ,CACxD,CAAC7F,GAAYA,EACb,CAACE,GAAYA,IAEf0D,EAAkB/D,EAA8B,KAAM,CACpDkG,eAAgB,KAElBnC,EAAkBlE,EAAgB,CAAEmG,QAAS,MAAQ,CACnD,CAAC7F,GAAYA,IAEf4D,EAAkBjE,EAAqB,CAAEkG,QAAS,MAAQ,CACxD,CAAC7F,GAAYA,IAEf4D,EAAkB7D,EAAe,KAAM,CACrC+F,SAAU,KAEZlC,EAAkB9D,EAAuB,KAAM,CAC7CgG,SAAU,KAEZlC,EAAkBnE,GAClB4F,MA4CA,CACEH,QJhFsC,GIiFtCC,UA3CJ,SAAqCvC,EAAIwC,EAAIC,GAC3CD,EAAG/B,YAAY3D,GACZkG,YAAYxF,EAAoBA,GACnCiF,MA0CA,CACEH,QJnFoC,GIoFpCC,UAzCJ,SAAgCvC,EAAIwC,EAAIC,GACtC,MAAMW,EAAS,CAACxG,EAAwBK,GACxC,IAAIoG,EAAiB,EAIrBD,EAAON,SAAQ3B,IACb,MAAMV,EAAc+B,EAAG/B,YAAYU,GACpBV,EAAYkB,aACpBd,UAAYyC,IACjB,MAAM,OAAExC,GAAWwC,EAAEC,OACrB,GAAIzC,EAAQ,CACV,MAAM,IAAElC,EAAG,MAAEC,GAAUiC,EAEjB0C,EAAS5E,EAAI6E,MAAM,MAAU,GAAK,MAAW,QAAsB5E,GAEzE4B,EAAYrB,OAAOR,GAAKiC,UAAY,KAClCJ,EAAYiD,IAAI7E,EAAO2E,GAAQ3C,UAAY,KACzCC,EAAOgB,mBAILuB,IAAmBD,EAAOO,QAC9BlB,W,cC5EV,MAAMmB,EAAW,GACXC,EAAgB,GA6Bf5B,eAAe6B,EAAaxF,GACjC,IAAKA,EACH,MAAM,IAAIyF,MAAM,8CAMlB,OAJKF,EAAcvF,KACjBuF,EAAcvF,SAhClB,SAAyBA,GACvB,OAAO,IAAI2B,SAAQ,CAACC,EAASC,KAC3B,MAAMkB,EAAMV,UAAUC,KAAKtC,EAAcb,GACzCmG,EAAStF,GAAgB+C,EACzBA,EAAId,QAAUJ,EACdkB,EAAI2C,UAAY,KACdC,QAAQzD,MAAM,gBAEhBa,EAAIN,gBAAmBuC,IACrB,MAAMtD,EAAKqB,EAAIP,OACT0B,EAAKc,EAAEY,cAAc9D,YAErB+D,EAAiB9B,EAAW+B,QAAO,EAAG9B,aAAcgB,EAAEe,WAAa/B,KAEzE,SAASgC,IACP,IAAKH,EAAeR,OAClB,OAEF,MAAM,UAAEpB,GAAc4B,EAAeI,QACrChC,EAAUvC,EAAIwC,EAAI8B,GAEpBA,IAEFjD,EAAIR,UAAY,IAAMX,EAAQmB,EAAIP,WASE0D,CAAelG,SFjChD2D,eAAiC3D,GACtC,OAAOQ,EAAIsD,EAAS9D,GAAc,GEiC1BmG,CAAiBnG,IAElBuF,EAAcvF,GAGhB2D,eAAeyC,EAAW1E,EAAIT,EAAWoF,EAAqBC,GACnE,OAAO,IAAI3E,SAAQ,CAACC,EAASC,KAC3B,MAAMqC,EAAKxC,EAAGI,YAAYb,EAAWoF,GAC/BxD,EAA6B,iBAAd5B,EACjBiD,EAAG/B,YAAYlB,GACfA,EAAUsF,KAAInC,GAAQF,EAAG/B,YAAYiC,KACzC,IAAIoC,EACJF,EAAGzD,GAAQL,IACTgE,EAAMhE,KAGR0B,EAAGnC,WAAa,IAAMH,EAAQ4E,GAC9BtC,EAAGjC,QAAU,IAAMJ,EAAOqC,EAAGhC,UAI1B,SAASuE,EAAgBzG,GAC9B,OAAO,IAAI2B,SAAQ,CAACC,EAASC,KAE3B,MAAM6E,EAAUpB,EAAStF,GACrB0G,GAAWA,EAAQlE,QACrBkE,EAAQlE,OAAOG,eAEV2C,EAAStF,UACTuF,EAAcvF,GACrB,MAAM+C,EAAMV,UAAUoE,eAAezG,GACrC+C,EAAIR,UAAY,IAAMX,IACtBmB,EAAId,QAAU,IAAMJ,EAAOkB,EAAIb,OAC/Ba,EAAI2C,UAAY,IAAMC,QAAQzD,MAAM,YAAYlC,gBAC/CyB,MAAK,IFhEHkC,eAAoC3D,GACzC,OAAOkD,EAAIY,EAAS9D,GE+DN2G,CAAoB3G,KAC/ByB,MAAK,IAAMtB,EAAeH,KCzExB2D,eAAeiD,EAAwB/D,EAAO9C,EAAOC,EAAc6G,GACxE,GAAIlG,EAAWZ,EAAOC,EAAc6G,GAClC,OAAOpG,EAAWV,EAAOC,EAAc6G,GAEzC,MAAMnF,QAAW8D,EAAYxF,GACvBwC,QAAe4D,EAAU1E,EAAImB,EAAO,YAAY,CAACA,EAAOtB,KAC5DsB,EAAMnC,IAAImG,GAAItE,UAAayC,GAAMzD,EAASyD,EAAEC,OAAOzC,WAGrD,OADAnC,EAAWN,EAAOC,EAAc6G,EAAIrE,GAC7BA,EAGFmB,eAAemD,EAAwBjE,EAAO9C,EAAOC,EAAc+G,GACxE1G,EAAWN,EAAOC,EAAc+G,EAAOF,GAAIE,GAE3C,OAAOX,QADUZ,EAAYxF,GACR6C,EAAO,aAAcA,IACxCA,EAAMI,IAAI8D,MAIP,SAASC,EAAiBC,GAC/B,MAAMT,EAAM,GACNrD,EAAOoB,OAAOpB,KAAK8D,GACzB,IAAK,MAAM3G,KAAO6C,EAAM,CACtB,MAAM5C,EAAQ0G,EAAI3G,GAElB,GAAKC,KAAU2G,MAAMC,QAAQ5G,IAA2B,IAAjBA,EAAM8E,QAG7C,OAAQ/E,GACN,IAAK,UACHkG,EAAIzH,GAAcwB,EAAMsG,GACxB,MACF,IAAK,SACHL,EAAIxH,GAAauB,EAAMsG,GACvB,MACF,IAAK,SACHL,EAAIvH,GAAasB,EAAMsG,GACvB,MACF,IAAK,OACHL,EAAIlG,GAAOC,EACXiG,EAAsB,mBAAIjG,EAAM6G,cAChC,MACF,QACEZ,EAAIlG,GAAOC,GAKjB,OADAiG,EAAI1H,GAAaM,IACVoH,ECjDF,SAASa,EAAkBC,EAAUT,GAE1C,OAAOS,EAAW,MAAW,QAAsBT,GAG9C,SAASU,GAAwBD,EAAUE,GAChD,MAAMC,EAAYD,IAAS,QAAsBA,GAC3CE,EAAQD,EAAaH,EAAW,KAAWG,EAAcH,EAAW,KACpEK,EAAML,EAAW,MACvB,OAAOM,YAAYC,MAAMH,EAAOC,GAAK,GAAM,GAOtC,SAASG,GAAgBlD,EAAUmD,GACxC,OAAOnD,EAAW,MAAW,QAAQmD,EAAG,GAGnC,SAASC,GAAsBpD,GACpC,OAAOgD,YAAYC,MACjBjD,EAAW,KACXA,EAAW,OAYR,SAASqD,GAA4BC,GAC1C,OAAON,YAAYC,MACjBK,EAAY,KACZA,EAAY,OCtCTvE,eAAewE,GAAYnI,EAAckI,GAC9C,OAAOtB,EAAuBpI,EAAgBkB,EAAeM,EAAckI,GAGtEvE,eAAeyE,GAAYpI,EAAcqI,GAC9C,OAAOvB,EAAuBtI,EAAgBkB,EAAeM,EAAcgH,EAAgBqB,IAGtF1E,eAAe2E,GAA0BtI,EAAcuI,EAAgBC,GAC5EA,EAAQA,GAAS,GAEjB,OAAOpC,QADUZ,EAAYxF,GACRxB,EAAgB,YAAY,CAACiK,EAAelH,KAC/D,MAAMmH,GDkC2CC,EClCIJ,EAAenB,cDmC/DQ,YAAYC,MACjBc,EACAA,EAAwB,MAHrB,IAA8CA,ECjCjDF,EAAcG,MAAM1J,GAAoB2J,OAAOH,EAAUF,GAAOjG,UAAYyC,IAC1EzD,EAASyD,EAAEC,OAAOzC,YCjBjBmB,eAAemF,GAA0B9I,GAC9CE,EAAWX,EAAeS,GAC1BE,EAAWR,EAAeM,GAC1BE,EAAWN,EAAWI,SAChByG,EAAezG,GCJhB2D,eAAeoF,GAAqB/I,EAAc6G,GACvD,MAAMnF,QAAW8D,EAAYxF,SACvBoG,EAAU1E,EAAIrD,EAAgB,YAAY,CAAC2K,EAAezH,KAC9DyH,EAAcJ,MAAM3J,GAAW4J,OAAOjB,YAAYqB,KAAKpC,IAAKtE,UAAYyC,IACtEzD,EAASyD,EAAEC,OAAOzC,YAKjBmB,eAAeuF,GAA+BlJ,EAAcmJ,GAEjE,OAAO/C,QADUZ,EAAYxF,GACRtB,EAAqB,YAAY,CAAC0K,EAAoB7H,KACzE,MAAMiF,EAAM,GACZjF,EAASiF,GACT2C,EAAU3E,SAAQI,IACJwE,EAAmBR,MAAM5J,GAAWqK,WAAWzB,YAAYqB,KAAKrE,IACxErC,UAAYyC,IACd,IAAK,MAAM6B,KAAM7B,EAAEC,OAAOzC,OACxBgE,EAAIjD,KAAKsD,UCjBZ,SAASyC,GAAaC,EAAQvJ,GACnCK,EAAWd,EAAeS,EAAcuJ,EAAO1C,GAAI0C,GACnDlJ,EAAWX,EAAeM,EAAcuJ,EAAOlB,QAAQxB,GAAI0C,EAAOlB,SAC9DkB,EAAOC,QACTnJ,EAAWX,EAAeM,EAAcuJ,EAAOC,OAAOnB,QAAQxB,GAAI0C,EAAOC,OAAOnB,SNsFlF3E,EAAA,mBAA2B,eAAeE,IACjB,WAAnBA,EAAMC,UACRU,OAAOpB,KAAKmC,GAAUd,SAAQxE,KAd7B,SAAwBA,GAE7B,MAAM0G,EAAUpB,EAAStF,GACrB0G,GAAWA,EAAQlE,QACrBkE,EAAQlE,OAAOG,eAEV2C,EAAStF,UACTuF,EAAcvF,GACrBG,EAAeH,GAOTyJ,CAAczJ,UASpB,EAAA0J,EAAA,IAAiB,IAAMxG,EAAI,uB,+CO1GtB,SAASyG,GAAW9G,EAAO+F,EAAOF,GACvCE,EAAMS,WAAWX,GAAUnG,UAAYyC,IACrC,IAAK,MAAMxC,KAAUwC,EAAEC,OAAOzC,OAC5BK,EAAM/B,OAAO0B,I,eCoBnB,SAASoH,GAAeC,EAAYtI,IAClC,SAASuI,IACPD,IAAatH,UAAY,SAAUyC,GACjC,MAAM+E,EAAU/E,EAAEC,OAAOzC,OACzBjB,EAASwI,GACLA,EAAQ1E,QACVyE,KAINA,GAmEKnG,eAAeqG,GAAShK,IAE7B,QAAK,WAAWA,KAChB,MAAM0B,QAAW8D,EAAYxF,GACvBiK,EAAa,CACjB5L,EACAC,EACAI,EACAC,EACAH,EACAC,EACAI,EACAD,SAEIwH,EAAU1E,EAAIuI,EAAY,aAAcnF,IAC5C,MACEkE,EACAkB,EACAd,EACAe,EACA1B,EACA2B,EACAC,EACAC,GACExF,EAEEyF,EAASlL,KAAKC,MAAQ,MA1FhC,SAA0B0J,EAAekB,EAAsBG,EAAcE,GAC3EX,IACE,IAAMZ,EAAcJ,MAAM9J,GAAWuK,WAAWzB,YAAY4C,WAAWD,GAjBxD,MAkBfR,IACEA,EAAQvF,SAAQI,IACdoE,EAAclI,OAAO8D,GACrB+E,GACEO,EACAA,EAAqBtB,MAAM,YAC3BhB,YAAYqB,KAAKrE,IAEnB+E,GACEU,EACAA,EACArC,GAAqBpD,UA8E3B6F,CAAgBzB,EAAekB,EAAsBG,EAAcE,GAvEvE,SAA+BnB,EAAoBe,EAA4BI,GAC7EX,IACE,IAAMR,EAAmBR,MAAM9J,GAAWuK,WAAWzB,YAAY4C,WAAWD,GAtC7D,MAuCfR,IACEA,EAAQvF,SAAQK,IACduE,EAAmBtI,OAAO+D,GAC1B8E,GACEQ,EACAA,EAA2BvB,MAAM,kBACjChB,YAAYqB,KAAKpE,UA+DvB6F,CAAqBtB,EAAoBe,EAA4BI,GAxDzE,SAA0B9B,EAAe6B,EAAqBC,GAC5DX,IACE,IAAMnB,EAAcG,MAAM9J,GAAWuK,WAAWzB,YAAY4C,WAAWD,GAtDxD,MAuDfR,IACEA,EAAQvF,SAAQ0D,IACdO,EAAc3H,OAAOoH,GACrByB,GACEW,EACAA,EACArC,GAA2BC,UAgDjCyC,CAAgBlC,EAAe6B,EAAqBC,GAzCxD,SAA+BH,EAAoBG,GACjDX,IACE,IAAMQ,EAAmBxB,MAAM9J,GAAWuK,WAAWzB,YAAY4C,WAAWD,GAtE7D,MAuEfR,IACEA,EAAQvF,SAAQoG,IACdR,EAAmBtJ,OAAO8J,SAqC9BC,CAAqBT,EAAoBG,OAE3C,KAAAO,GAAK,WAAW9K,KAGlB,SAAS+K,GAAW/K,IAClB,EAAA0J,EAAA,IAAiB,IAAMM,GAAQhK,KAY1B,MAAMgL,IAAoC,EAAAC,GAAA,IATjDtH,iBAEE,MAAMuH,QV1IDvH,iBACL,aAAcR,KACX2C,QAAOqF,GAAKA,EAAEC,WAAWtH,KACzByC,KAAI4E,GAAKA,EAAEE,UAAUvH,EAAOuB,UUuIFiG,GAC7B,IAAK,MAAMC,KAAYL,EACrBH,GAAUQ,KAK8D,MChIrE,SAASC,GAAWxC,EAAeO,GACxCP,EAAc/F,IAAI+D,EAAgBuC,IAG7B,SAASkC,GAAYhD,EAAeJ,GACzCI,EAAcxF,IAAI+D,EAAgBqB,IAW7B,SAASqD,GAAa1C,EAAeP,EAAec,GACzDiC,GAAUxC,EAAeO,GACzBkC,GAAWhD,EAAec,EAAOlB,SAC7BkB,EAAOC,SACTgC,GAAUxC,EAAeO,EAAOC,QAChCiC,GAAWhD,EAAec,EAAOC,OAAOnB,UAIrC,SAASsD,GAAmBvC,EAAoBJ,EAAeP,EAAemD,GAC/EA,EAAarC,QACfmC,GAAY1C,EAAeP,EAAemD,EAAarC,QAfpD,SAAuBd,EAAeJ,GAC3CoD,GAAWhD,EAAeJ,GAgB1BwD,CAAapD,EAAemD,EAAavD,SArBpC,SAA0Be,EAAoBwC,GACnDxC,EAAmBnG,IAAI+D,EAAgB4E,IAqBvCE,CAAgB1C,EAAoBwC,GA4D/BjI,eAAeoI,GAAqB/L,EAAcsH,EAAU0E,GAGjE,GADehB,KACE,kBAAb1D,GAA6C,2BAAbA,EAClC,OA7DJ3D,eAA4C3D,EAAcsH,EAAU2E,GAClE,IAAK,MAAML,KAAgBK,EACzB5L,EAAWR,EAAoBG,EAAc4L,EAAa/E,GAAI+E,GAC9DvL,EAAWX,EAAeM,EAAc4L,EAAavD,QAAQxB,GAAI+E,EAAavD,SAC1EuD,EAAarC,QACflJ,EAAWd,EAAeS,EAAc4L,EAAarC,OAAO1C,GAAI+E,EAAarC,QAGjF,MAAM7H,QAAW8D,EAAYxF,GACvBiK,EAAa,CAACtL,EAA8BD,EAAqBF,EAAgBH,SACjF+H,EAAU1E,EAAIuI,EAAY,aAAcnF,IAC5C,MAAOoH,EAAe9C,EAAoBX,EAAeO,GAAiBlE,EAC1E,IAAK,MAAM8G,KAAgBK,EACzBN,GAAkBvC,EAAoBJ,EAAeP,EAAemD,GACpEM,EAAcjJ,IAAI2I,EAAa/E,GAAIQ,EAAiBC,EAAUsE,EAAa/E,QA+CtEsF,CAA4BnM,EAAcsH,EAAU0E,GACtD,GAAI1E,EAAS8D,WAAW,WAAY,CAEzC,OA9BJzH,eAAmC3D,EAAc4E,EAAUwH,GACzD,IAAK,MAAM7C,KAAU6C,EACnB9C,GAAYC,EAAQvJ,GAEtB,MAAM0B,QAAW8D,EAAYxF,GACvBiK,EAAa,CAACpL,EAAeR,EAAgBG,SAC7C4H,EAAU1E,EAAIuI,EAAY,aAAcnF,IAC5C,MAAOuF,EAAcrB,EAAeP,GAAiB3D,EACrDuF,EAAahB,WAAWrB,GAAqBpD,IAAWrC,UAAYyC,IAClE,MAAMqH,EAAerH,EAAEC,OAAOzC,OACxB8J,GAAU,EAAAC,GAAA,GAAMH,EAAS/G,QAAQ0C,GAAKD,GAAelD,EAAUmD,KAC/DyE,GAAe,EAAAC,GAAA,GAAWJ,EAAcC,GAC9C,IAAK,MAAMhM,KAAOkM,EAChBnC,EAAavJ,OAAOR,IAGxB8L,EAAS5H,SAAQ,CAACkI,EAAa3E,KAC7B2D,GAAY1C,EAAeP,EAAeiE,GAC1CrC,EAAapH,IAAIyJ,EAAY7F,GAAIiB,GAAelD,EAAUmD,UAYrD4E,CAAmB3M,EADTsH,EAASnC,MAAM,KAAKyH,OAAO,GAAG,GACGZ,GAElD,OA/CJrI,eAAuC3D,EAAcsH,EAAU8E,GAC7D,IAAK,MAAM7C,KAAU6C,EACnB9C,GAAYC,EAAQvJ,GAEtB,MAAM0B,QAAW8D,EAAYxF,GACvBiK,EAAa,CAAC3L,EAAwBD,EAAgBG,SACtD4H,EAAU1E,EAAIuI,EAAY,aAAcnF,IAC5C,MAAOoH,EAAelD,EAAeP,GAAiB3D,EACtD,IAAK,MAAMyE,KAAU6C,EACnBV,GAAY1C,EAAeP,EAAec,GAC1C2C,EAAcjJ,IAAIsG,EAAO1C,GAAIQ,EAAiBC,EAAUiC,EAAO1C,QAqC1DgG,CAAuB7M,EAAcsH,EAAU0E,GAInDrI,eAAemJ,GAAc9M,EAAcuJ,GAChDD,GAAYC,EAAQvJ,GACpB,MAAM0B,QAAW8D,EAAYxF,SACvBoG,EAAU1E,EAAI,CAACrD,EAAgBG,GAAiB,aAAa,EAAEwK,EAAeP,MAClFiD,GAAY1C,EAAeP,EAAec,MChIvC,SAASwD,GAActE,EAAe5B,EAAItF,GAC/CkH,EAAc/H,IAAImG,GAAItE,UAAYyC,IAChCzD,EAASyD,EAAEC,OAAOzC,SCCf,SAASwK,GAAahE,EAAeP,EAAe5B,EAAItF,GAC7DyH,EAActI,IAAImG,GAAItE,UAAYyC,IAChC,MAAMuE,EAASvE,EAAEC,OAAOzC,OACxBjB,EAASgI,GACJA,IAGLwD,GAAatE,EAAec,EAAOxK,IAAasJ,IAC9CkB,EAAOlB,QAAUA,KAEfkB,EAAOtK,IACT+N,GAAYhE,EAAeP,EAAec,EAAOtK,IAAYuK,IAC3DD,EAAOC,OAASA,OCRjB7F,eAAesJ,GAAsBjN,EAAckI,EAAWkE,GACnE,IAAK,MAAM7C,KAAU6C,EACnB9C,GAAYC,EAAQvJ,GAEtB,MAAM0B,QAAW8D,EAAYxF,GACvBiK,EAAa,CAACrL,EAAuBP,EAAgBG,SACrD4H,EAAU1E,EAAIuI,EAAY,aAAcnF,IAC5C,MAAOwF,EAAqBtB,EAAeP,GAAiB3D,EAEtD4D,EAAWT,GAA2BC,GAC5CoC,EAAoBzB,OAAOH,GAAUnG,UAAYyC,IAE/C,MAAMkI,EAAyBlI,EAAEC,OAAOzC,OACxC,IAAK,IAAIuF,EAAIqE,EAAS/G,OAAQ0C,EAAImF,EAAuB7H,OAAQ0C,IAC/DuC,EAAoBxJ,OAAOmH,GAA2BC,IAExDkE,EAAS5H,SAAQ,CAAC+E,EAAQxB,KACxB2D,GAAY1C,EAAeP,EAAec,GAC1Ce,EAAoBrH,IAAIsG,EAAO1C,GVYhC,SAA+BqB,EAAWH,GAC/C,OAAOG,EAAY,MAAW,QAAQH,EAAG,GUbAoF,CAAqBjF,EAAWH,WAMpEpE,eAAeyJ,GAAmBpN,EAAckI,GACrD,MAAM+B,EAAa,CAACrL,EAAuBP,EAAgBG,GAE3D,OAAO4H,QADUZ,EAAYxF,GACRiK,EAAY,YAAY,CAACnF,EAAQvD,KACpD,MAAO+I,EAAqBtB,EAAeP,GAAiB3D,EACtD4D,EAAWT,GAA2BC,GAC5CoC,EAAoBzB,OAAOH,GAAUnG,UAAYyC,IAC/C,MAAMqI,EAAgBrI,EAAEC,OAAOzC,OACzBgE,EAAM,IAAIU,MAAMmG,EAAchI,QACpCgI,EAAc7I,SAAQ,CAACI,EAAUmD,KAC/BiF,GAAYhE,EAAeP,EAAe7D,GAAU2E,IAClD/C,EAAIuB,GAAKwB,QAGbhI,EAASiF,OCzCR,SAAS8G,GAAmBlE,EAAoBJ,EAAeP,EAAe5B,EAAItF,GACvF6H,EAAmB1I,IAAImG,GAAItE,UAAYyC,IACrC,MAAM4G,EAAe5G,EAAEC,OAAOzC,OAC9BjB,EAASqK,GACTmB,GAAatE,EAAemD,EAAa7M,IAAasJ,IACpDuD,EAAavD,QAAUA,KAErBuD,EAAa5M,IACfgO,GAAYhE,EAAeP,EAAemD,EAAa5M,IAAYuK,IACjEqC,EAAarC,OAASA,M,eCsEvB5F,eAAe4J,GAAavN,EAAcsH,EAAUE,EAAOgB,GAGhE,GAFAhB,EAAQA,GAAS,KACjBgB,EAAQA,GAAS,KACA,kBAAblB,GAA6C,2BAAbA,EAClC,OAtEJ3D,eAAwC3D,EAAcsH,EAAUE,EAAOgB,GACrE,MAAMyB,EAAa,CAACtL,EAA8BD,EAAqBL,EAAgBG,GAEvF,OAAO4H,QADUZ,EAAYxF,GACRiK,EAAY,YAAY,CAACnF,EAAQvD,KACpD,MAAO2K,EAAe9C,EAAoBJ,EAAeP,GAAiB3D,EACpE4D,EAAWnB,GAAuBD,EAAUE,GAElD0E,EAAcrD,OAAOH,EAAUF,GAAOjG,UAAYyC,IAChD,MAAMwI,EAAkBxI,EAAEC,OAAOzC,OAC3BgE,EAAM,IAAIU,MAAMsG,EAAgBnI,QACtCmI,EAAgBhJ,SAAQ,CAACK,EAAgBkD,KACvCuF,GAAkBlE,EAAoBJ,EAAeP,EAAe5D,GAAgB+G,IAClFpF,EAAIuB,GAAK6D,QAGbrK,EAASiF,OAuDJiH,CAAwBzN,EAAcsH,EAAUE,EAAOgB,GACzD,GAAIlB,EAAS8D,WAAW,WAAY,CAEzC,OAlCJzH,eAAgC3D,EAAc4E,GAC5C,MAAMqF,EAAa,CAACpL,EAAeR,EAAgBG,GAEnD,OAAO4H,QADUZ,EAAYxF,GACRiK,EAAY,YAAY,CAACnF,EAAQvD,KACpD,MAAO8I,EAAcrB,EAAeP,GAAiB3D,EAC/C4D,EAAWV,GAAqBpD,GACtCyF,EAAaxB,OAAOH,GAAUnG,UAAYyC,IACxC,MAAM0I,EAAS1I,EAAEC,OAAOzC,OACxB,GAAIkL,EAAOrI,OAAQ,CACjB,MAAMmB,EAAM,IAAIU,MAAMwG,EAAOrI,QAC7B9D,EAASiF,GACTkH,EAAOlJ,SAAQ,CAACmJ,EAAe5F,KAC7BiF,GAAYhE,EAAeP,EAAekF,GAAepE,IACvD/C,EAAIuB,GAAKwB,aAKbyD,GAAYhE,EAAeP,EAAe7D,GAAU2E,IAElDhI,EADY,CAACgI,WAeZqE,CAAgB5N,EADNsH,EAASnC,MAAM,KAAKyH,OAAO,GAAG,IAG/C,OAvDJjJ,eAAkC3D,EAAcsH,EAAUE,EAAOgB,GAC/D,MAAMyB,EAAa,CAAC3L,EAAwBD,EAAgBG,GAE5D,OAAO4H,QADUZ,EAAYxF,GACRiK,EAAY,YAAY,CAACnF,EAAQvD,KACpD,MAAO2K,EAAelD,EAAeP,GAAiB3D,EACvCoH,EAAcrD,OAAOtB,GAAuBD,EAAUE,GAAQgB,GACtEjG,UAAYyC,IACjB,MAAMwI,EAAkBxI,EAAEC,OAAOzC,OAC3BgE,EAAM,IAAIU,MAAMsG,EAAgBnI,QACtCmI,EAAgBhJ,SAAQ,CAACI,EAAUmD,KACjCiF,GAAYhE,EAAeP,EAAe7D,GAAU2E,IAClD/C,EAAIuB,GAAKwB,QAGbhI,EAASiF,OAyCJqH,CAAkB7N,EAAcsH,EAAUE,EAAOgB,GClFrD7E,eAAemK,GAAW9N,EAAc6G,GAC7C,GAAIlG,EAAWpB,EAAeS,EAAc6G,GAC1C,OAAOpG,EAAWlB,EAAeS,EAAc6G,GAEjD,MAAMnF,QAAW8D,EAAYxF,GACvBiK,EAAa,CAAC5L,EAAgBG,GAC9BgE,QAAe4D,EAAU1E,EAAIuI,EAAY,YAAY,CAACnF,EAAQvD,KAClE,MAAOyH,EAAeP,GAAiB3D,EACvCkI,GAAYhE,EAAeP,EAAe5B,EAAItF,MAGhD,OADAlB,EAAWd,EAAeS,EAAc6G,EAAIrE,GACrCA,EAGFmB,eAAeoK,GAAiB/N,EAAc6G,GACnD,GAAIlG,EAAWd,EAAoBG,EAAc6G,GAC/C,OAAOpG,EAAWZ,EAAoBG,EAAc6G,GAEtD,MAAMnF,QAAW8D,EAAYxF,GACvBiK,EAAa,CAACvL,EAAqBL,EAAgBG,GACnDgE,QAAe4D,EAAU1E,EAAIuI,EAAY,YAAY,CAACnF,EAAQvD,KAClE,MAAO6H,EAAoBJ,EAAeP,GAAiB3D,EAC3DwI,GAAkBlE,EAAoBJ,EAAeP,EAAe5B,EAAItF,MAG1E,OADAlB,EAAWR,EAAoBG,EAAc6G,EAAIrE,GAC1CA,ECzBTmB,eAAeqK,GAAchO,EAAc4E,EAAUqJ,GACnD,MAAMvM,QAAW8D,EAAYxF,GAC7B,GAAIW,EAAWpB,EAAeS,EAAc4E,GAAW,CACrD,MAAM2E,EAAS9I,EAAWlB,EAAeS,EAAc4E,GACvDqJ,EAAW1E,GACXD,GAAYC,EAAQvJ,GAEtB,OAAOoG,EAAU1E,EAAIrD,EAAgB,aAAc2K,IACjDA,EAActI,IAAIkE,GAAUrC,UAAYyC,IACtC,MAAMuE,EAASvE,EAAEC,OAAOzC,OACxByL,EAAW1E,GACXiC,GAAUxC,EAAeO,OAKxB5F,eAAeuK,GAAoBlO,EAAc4E,EAAUuJ,GAChE,OAAOH,GAAahO,EAAc4E,GAAU2E,IAC1C,MAAM6E,GAASD,EAAY,EAAI,IAAM5E,EAAO8E,WAAa,EAAI,GAC7D9E,EAAO8E,WAAaF,EACpB5E,EAAO+E,kBAAoB/E,EAAO+E,kBAAoB,GAAKF,KAIxDzK,eAAe4K,GAAoBvO,EAAc4E,EAAU4J,GAChE,OAAOR,GAAahO,EAAc4E,GAAU2E,IAC1C,MAAM6E,GAASI,EAAY,EAAI,IAAMjF,EAAOiF,UAAY,EAAI,GAC5DjF,EAAOiF,UAAYA,EACnBjF,EAAOkF,eAAiBlF,EAAOkF,eAAiB,GAAKL,KAIlDzK,eAAe+K,GAAiB1O,EAAc4E,EAAU+J,GAC7D,OAAOX,GAAahO,EAAc4E,GAAU2E,IAC1CA,EAAOoF,OAASA,KAIbhL,eAAeiL,GAAgB5O,EAAc4E,EAAUiK,GAC5D,OAAOb,GAAahO,EAAc4E,GAAU2E,IAC1CA,EAAOsF,MAAQA,KAIZlL,eAAemL,GAAqB9O,EAAc4E,EAAUmK,GACjE,OAAOf,GAAahO,EAAc4E,GAAU2E,IAC1CA,EAAOwF,WAAaA,KCvCjBpL,eAAeqL,GAAgChP,EAAcmJ,EAAW8F,GAC7E,IAAK,MAAMrK,KAAYuE,EACrBtI,EAAgBtB,EAAeS,EAAc4E,GAE/C,IAAK,MAAMC,KAAkBoK,EAC3BpO,EAAgBhB,EAAoBG,EAAc6E,GAEpD,MAAMnD,QAAW8D,EAAYxF,GACvBiK,EAAa,CACjB5L,EACAC,EACAI,EACAC,EACAC,EACAC,SAEIuH,EAAU1E,EAAIuI,EAAY,aAAcnF,IAC5C,MACEkE,EACAkB,EACAd,EACAe,EACAG,EACAD,GACEvF,EAEJ,SAASoK,EAActK,GACrBoE,EAAclI,OAAO8D,GACrB+E,GACEW,EACAA,EAAoB1B,MAAM,YAC1BhB,YAAYqB,KAAKrE,IAEnB+E,GACEO,EACAA,EAAqBtB,MAAM,YAC3BhB,YAAYqB,KAAKrE,IAEnB+E,GACEU,EACAA,EAAazB,MAAM,YACnBhB,YAAYqB,KAAKrE,IAEnB+E,GACEU,EACAA,EACArC,GAAqBpD,IAIzB,SAASuK,EAAoBtK,GAC3BuE,EAAmBtI,OAAO+D,GAC1B8E,GACEQ,EACAA,EAA2BvB,MAAM,kBACjChB,YAAYqB,KAAKpE,IAIrB,IAAK,MAAMD,KAAYuE,EACrB+F,EAAatK,GAEf,IAAK,MAAMC,KAAkBoK,EAC3BE,EAAmBtK,MC5EzBlB,eAAeyL,GAAiBpP,EAAcM,GAC5C,GAAIK,EAAWf,EAAWI,EAAcM,GACtC,OAAOG,EAAWb,EAAWI,EAAcM,GAE7C,MAAMoB,QAAW8D,EAAYxF,GACvBwC,QAAe4D,EAAU1E,EAAInD,EAAY,YAAY,CAACsE,EAAOtB,KACjEsB,EAAMnC,IAAIJ,GAAKiC,UAAayC,IAC1BzD,EAASyD,EAAEC,OAAOzC,YAItB,OADAnC,EAAWT,EAAWI,EAAcM,EAAKkC,GAClCA,EAGTmB,eAAe0L,GAAiBrP,EAAcM,EAAKC,GACjDF,EAAWT,EAAWI,EAAcM,EAAKC,GAEzC,OAAO6F,QADUZ,EAAYxF,GACRzB,EAAY,aAAcsE,IAC7CA,EAAMI,IAAI1C,EAAOD,MAIdqD,eAAe2L,GAA8BtP,GAClD,OAAOoP,GAAgBpP,EAAc,qBAGhC2D,eAAe4L,GAA8BvP,EAAcO,GAChE,OAAO8O,GAAgBrP,EAAc,oBAAqBO,GAGrDoD,eAAe6L,GAAiBxP,GACrC,OAAOoP,GAAgBpP,EAAc,YAGhC2D,eAAe8L,GAAiBzP,EAAcO,GACnD,OAAO8O,GAAgBrP,EAAc,WAAYO,GAG5CoD,eAAe+L,GAAU1P,GAC9B,OAAOoP,GAAgBpP,EAAc,SAGhC2D,eAAegM,GAAU3P,EAAcO,GAC5C,OAAO8O,GAAgBrP,EAAc,QAASO,GAGzCoD,eAAeiM,GAAgB5P,GACpC,OAAOoP,GAAgBpP,EAAc,eAGhC2D,eAAekM,GAAgB7P,EAAcO,GAClD,OAAO8O,GAAgBrP,EAAc,cAAeO,GAG/CoD,eAAemM,GAAuB9P,GAC3C,OAAOoP,GAAgBpP,EAAc,sBAGhC2D,eAAeoM,GAAuB/P,EAAcO,GACzD,OAAO8O,GAAgBrP,EAAc,qBAAsBO,GAGtDoD,eAAeqM,GAAYhQ,GAChC,OAAOoP,GAAgBpP,EAAc,WAGhC2D,eAAesM,GAAYjQ,EAAcO,GAC9C,OAAO8O,GAAgBrP,EAAc,UAAWO,GCnE3CoD,eAAeuM,GAAiBlQ,EAAckI,GACnD,OAAOtB,EAAuBnI,EAAqBkB,EAAoBK,EAAckI,GAGhFvE,eAAewM,GAAiBnQ,EAAcoQ,GACnD,OAAOtJ,EAAuBrI,EAAqBkB,EAAoBK,EAAcgH,EAAgBoJ,ICThG,MAAMC,GAAgC,iBCGtC,SAASC,KACd,OAAOpN,EAAImN,IAGN,SAASE,GAAiBC,GAC/B,OAAOhQ,EAAI6P,GAA+BG,GAGrC,SAASC,KACd,OAAO/P,EAAI2P,IAGN,SAASK,KACd,OAAO,ICVT,MAAM,GAAS,eACTC,GAAY,UAELC,GAAe,OAE5B,IAAIC,GAAcD,GAElB,SAASE,GAAWxQ,GAElB,MAAMsI,GADNtI,EAAMA,EAAI+K,UAAU,GAAOhG,SACT0L,QAAQJ,IAE1B,MAAO,CAACrQ,EAAI+K,UAAU,EAAGzC,GAAQtI,EAAI+K,UAAUzC,EAAQ+H,GAAUtL,SAOnE1B,eAAe0F,KACb,aAAclG,KAAQ2C,QAAOxF,GAAOA,EAAI8K,WAAW,MAAS4F,OAGvDrN,eAAesN,GAAoBpK,GACxC,MAAMqK,QAAgB7H,KAEtB,IAAK,MAAM/I,KAAO4Q,EAAS,CAEzB,GAAIrK,IADYiK,GAAUxQ,GAAK,GAE7B,OAAOI,EAAIJ,IAKVqD,eAAewN,GAAoBtK,EAAIuK,GAC5C,MAAMF,QAAgB7H,KAEtB,GAAI6H,EAAQ3K,IAAIuK,IAAWvK,KAAI4E,GAAKA,EAAE,KAAIkG,SAASxK,GACjD,OAGF,KAAOqK,EAAQ7L,QAtCH,SAwCJnC,EAAIgO,EAAQjL,SAIpB,IAAK,MAAM3F,KAAO4Q,EAAS,CACzB,MAAMI,EAAYR,GAAUxQ,GAAK,GAC7BjB,KAAKC,MAAQD,KAAKkS,MAAMD,IAAcT,UAClC3N,EAAI5C,GAId,MAAMA,EAvCR,SAAoBgR,EAAWzK,GAC7B,MAAO,eAAYyK,WAAwBzK,IAsC/B2K,EAAU,IAAInS,MAAOoS,cAAe5K,SAE1CrG,EAAIF,EAAK8Q,GAGVzN,eAAe+N,GAAuB7K,GAC3C,MAAMqK,QAAgB7H,KAEtB,IAAK,MAAM/I,KAAO4Q,EAAS,CACTJ,GAAUxQ,GAAK,KACfuG,SACR3D,EAAI5C,IAOTqD,eAAegO,KACpB,aAActI,MAAc9C,IAAIuK,IAAWvK,KAAI4E,GAAKA,EAAE,KAGjD,SAASyG,GAAgCC,GAC9ChB,GAAcgB,I,qDClFT,MAAMC,EAAmB,MACnBC,EAAgB,K,qDCDtB,MAAMC,EAAsB,GAEtBC,EAAY,CACvBC,KAAM,CAAE9N,KAAM,OAAQ+N,MAAO,QAC7BC,MAAO,CAAEhO,KAAM,QAAS+N,MAAO,SAC/BE,UAAW,CAAEjO,KAAM,YAAa+N,MAAO,e,2DCAlC,MAAMG,UAAiB,EAAAC,aAC5B,YAAaC,EAAU,IAErB,GADAC,UACMD,EAAQhT,SAAWgT,EAAQhT,QAAU,GACzC,MAAM,IAAIkT,UAAU,6CAGtBxR,KAAK1B,QAAUgT,EAAQhT,QACvB0B,KAAKnB,MAAQ,IAAI4S,IACjBzR,KAAK0R,SAAW,IAAID,IACpBzR,KAAK2R,MAAQ,EAGf,KAAMvS,EAAKC,GAIT,GAHAW,KAAKnB,MAAMS,IAAIF,EAAKC,GACpBW,KAAK2R,QAED3R,KAAK2R,OAAS3R,KAAK1B,QAAS,CAE9B,GADA0B,KAAK2R,MAAQ,EACT3R,KAAK4R,cAAc,SACrB,IAAK,MAAMxS,KAAOY,KAAK0R,SAASzP,OACzBjC,KAAKnB,MAAMa,IAAIN,IAClBY,KAAK6R,KAAK,QAAS7R,KAAK0R,SAASlS,IAAIJ,GAAMA,GAIjDY,KAAK0R,SAAW1R,KAAKnB,MACrBmB,KAAKnB,MAAQ,IAAI4S,KAIrB,IAAKrS,GACH,GAAIY,KAAKnB,MAAMa,IAAIN,GACjB,OAAOY,KAAKnB,MAAMW,IAAIJ,GAGxB,GAAIY,KAAK0R,SAAShS,IAAIN,GAAM,CAC1B,MAAMC,EAAQW,KAAK0R,SAASlS,IAAIJ,GAGhC,OAFAY,KAAK0R,SAAS9R,OAAOR,GACrBY,KAAK8R,KAAK1S,EAAKC,GACRA,GAIX,IAAKD,EAAKC,GAOR,OANIW,KAAKnB,MAAMa,IAAIN,GACjBY,KAAKnB,MAAMS,IAAIF,EAAKC,GAEpBW,KAAK8R,KAAK1S,EAAKC,GAGVW,KAGT,IAAKZ,GACH,OAAOY,KAAKnB,MAAMa,IAAIN,IAAQY,KAAK0R,SAAShS,IAAIN,GAclD,OAAQA,GACN,MAAM2S,EAAU/R,KAAKnB,MAAMe,OAAOR,GAKlC,OAJI2S,GACF/R,KAAK2R,QAGA3R,KAAK0R,SAAS9R,OAAOR,IAAQ2S,EAGtC,QACE/R,KAAKnB,MAAMmT,QACXhS,KAAK0R,SAASM,QACdhS,KAAK2R,MAAQ,EAGf,aACE,MAAMrS,EAAM,IAAI2S,IAChB,IAAK,MAAM7S,KAAOY,KAAKnB,MAAMoD,OAC3B3C,EAAI4E,IAAI9E,GAEV,IAAK,MAAMA,KAAOY,KAAK0R,SAASzP,OAC9B3C,EAAI4E,IAAI9E,GAEV,OAAOE,K,6ECrFJ,SAAS4S,EAASC,EAAKC,GAC5B,OAAO,QAASD,EAAKC,EAAQ,KAGxB,SAASC,EAAgB1M,GAC9B,OAAOuM,EAAQvM,EAPK,IAUf,SAAS2M,EAAuB3M,GACrC,MAAM4M,EAASF,EAAe1M,GAC9B,IAAI6M,EAAW,GACf,IAAK,IAAI3L,EAAI,EAAGA,EAAI0L,EAAOpO,OAAQ0C,IAAK,CACtC,MACM4L,EAAkBC,IADPH,EAAOI,WAAW9L,GAEnC2L,GAAYI,OAAOC,aAAaJ,GAElC,OAAOD,EAGF,SAASM,EAA8BC,EAAMC,GAClD,MAAMC,EAAaZ,EAAeU,EAAKpN,IACjCuN,EAAcb,EAAeW,EAAMrN,IACzC,OAAOsN,EAAaC,GAAe,EAAID,IAAeC,EAAc,EAAI","file":"166.8812d8059a483fc4ddd1.166.js","sourcesContent":["export const STATUSES_STORE = 'statuses-v4'\nexport const STATUS_TIMELINES_STORE = 'status_timelines-v4'\nexport const META_STORE = 'meta-v4'\nexport const ACCOUNTS_STORE = 'accounts-v4'\nexport const RELATIONSHIPS_STORE = 'relationships-v4'\nexport const NOTIFICATIONS_STORE = 'notifications-v4'\nexport const NOTIFICATION_TIMELINES_STORE = 'notification_timelines-v4'\nexport const PINNED_STATUSES_STORE = 'pinned_statuses-v4'\nexport const THREADS_STORE = 'threads-v4'\n\nexport const TIMESTAMP = '__pinafore_ts'\nexport const ACCOUNT_ID = '__pinafore_acct_id'\nexport const STATUS_ID = '__pinafore_status_id'\nexport const REBLOG_ID = '__pinafore_reblog_id'\nexport const USERNAME_LOWERCASE = '__pinafore_acct_lc'\n\nexport const DB_VERSION_INITIAL = 9\nexport const DB_VERSION_SEARCH_ACCOUNTS = 10\nexport const DB_VERSION_SNOWFLAKE_IDS = 12 // 11 skipped because of mistake deployed to dev.pinafore.social\n\n// Using an object for these so that unit tests can change them\nexport const DB_VERSION_CURRENT = { version: 12 }\nexport const CURRENT_TIME = { now: () => Date.now() }\n","import { QuickLRU } from '../_thirdparty/quick-lru/quick-lru'\n\nexport const statusesCache = {\n  maxSize: 100,\n  caches: {}\n}\nexport const accountsCache = {\n  maxSize: 50,\n  caches: {}\n}\nexport const relationshipsCache = {\n  maxSize: 20,\n  caches: {}\n}\nexport const metaCache = {\n  maxSize: 20,\n  caches: {}\n}\nexport const notificationsCache = {\n  maxSize: 50,\n  caches: {}\n}\n\nif (process.browser && process.env.NODE_ENV !== 'production') {\n  (typeof self !== 'undefined' ? self : window).cacheStats = {\n    statuses: statusesCache,\n    accounts: accountsCache,\n    relationships: relationshipsCache,\n    meta: metaCache,\n    notifications: notificationsCache\n  }\n}\n\nfunction getOrCreateInstanceCache (cache, instanceName) {\n  let cached = cache.caches[instanceName]\n  if (!cached) {\n    cached = cache.caches[instanceName] = new QuickLRU({ maxSize: cache.maxSize })\n  }\n  return cached\n}\n\nexport function clearCache (cache, instanceName) {\n  delete cache.caches[instanceName]\n}\nexport function clearAllCaches (instanceName) {\n  const allCaches = [statusesCache, accountsCache, relationshipsCache, metaCache, notificationsCache]\n  for (const cache of allCaches) {\n    clearCache(cache, instanceName)\n  }\n}\nexport function setInCache (cache, instanceName, key, value) {\n  const instanceCache = getOrCreateInstanceCache(cache, instanceName)\n  return instanceCache.set(key, value)\n}\n\nexport function getInCache (cache, instanceName, key) {\n  const instanceCache = getOrCreateInstanceCache(cache, instanceName)\n  return instanceCache.get(key)\n}\n\nexport function hasInCache (cache, instanceName, key) {\n  const instanceCache = getOrCreateInstanceCache(cache, instanceName)\n  const res = instanceCache.has(key)\n  if (process.env.NODE_ENV !== 'production') {\n    if (res) {\n      cache.hits = (cache.hits || 0) + 1\n    } else {\n      cache.misses = (cache.misses || 0) + 1\n    }\n  }\n  return res\n}\n\nexport function deleteFromCache (cache, instanceName, key) {\n  const instanceCache = getOrCreateInstanceCache(cache, instanceName)\n  instanceCache.delete(key)\n}\n","// Forked from https://github.com/jakearchibald/idb-keyval/commit/ea7d507\n// Adds a function for closing the database, ala https://github.com/jakearchibald/idb-keyval/pull/65\n// Also hooks it into the lifecycle frozen event\nimport { lifecycle } from '../../_utils/lifecycle'\n\nclass Store {\n  constructor (dbName = 'keyval-store', storeName = 'keyval') {\n    this.storeName = storeName\n    this._dbName = dbName\n    this._storeName = storeName\n    this._init()\n  }\n\n  _withIDBStore (type, callback) {\n    this._init()\n    return this._dbp.then(db => new Promise((resolve, reject) => {\n      const transaction = db.transaction(this.storeName, type)\n      transaction.oncomplete = () => resolve()\n      transaction.onabort = transaction.onerror = () => reject(transaction.error)\n      callback(transaction.objectStore(this.storeName))\n    }))\n  }\n\n  _init () {\n    if (this._dbp) {\n      return\n    }\n    this._dbp = new Promise((resolve, reject) => {\n      const openreq = indexedDB.open(this._dbName, 1)\n      openreq.onerror = () => reject(openreq.error)\n      openreq.onsuccess = () => resolve(openreq.result)\n      // First time setup: create an empty object store\n      openreq.onupgradeneeded = () => {\n        openreq.result.createObjectStore(this._storeName)\n      }\n    })\n  }\n\n  _close () {\n    this._init()\n    return this._dbp.then(db => {\n      db.close()\n      this._dbp = undefined\n    })\n  }\n}\n\nlet store\n\nfunction getDefaultStore () {\n  if (!store) {\n    store = new Store()\n  }\n  return store\n}\n\nfunction get (key) {\n  const store = getDefaultStore()\n  let req\n  return store._withIDBStore('readonly', store => {\n    req = store.get(key)\n  }).then(() => req.result)\n}\n\nfunction set (key, value) {\n  const store = getDefaultStore()\n  return store._withIDBStore('readwrite', store => {\n    store.put(value, key)\n  })\n}\n\nfunction del (key) {\n  const store = getDefaultStore()\n  return store._withIDBStore('readwrite', store => {\n    store.delete(key)\n  })\n}\n\nfunction clear () {\n  const store = getDefaultStore()\n  return store._withIDBStore('readwrite', store => {\n    store.clear()\n  })\n}\n\nfunction keys () {\n  const store = getDefaultStore()\n  const keys = []\n  return store._withIDBStore('readonly', store => {\n    // This would be store.getAllKeys(), but it isn't supported by Edge or Safari.\n    // And openKeyCursor isn't supported by Safari.\n    (store.openKeyCursor || store.openCursor).call(store).onsuccess = function () {\n      if (!this.result) {\n        return\n      }\n      keys.push(this.result.key)\n      this.result.continue()\n    }\n  }).then(() => keys)\n}\n\nfunction close () {\n  const store = getDefaultStore()\n  return store._close()\n}\n\nif (process.browser) {\n  lifecycle.addEventListener('statechange', async event => {\n    if (event.newState === 'frozen') { // page is frozen, close IDB connections\n      await close()\n      console.log('closed keyval DB')\n    }\n  })\n}\n\nexport { Store, get, set, del, clear, keys, close }\n","import { set, keys, del } from '../_thirdparty/idb-keyval/idb-keyval'\n\nconst PREFIX = 'known-instance-'\n\nexport async function getKnownInstances () {\n  return (await keys())\n    .filter(_ => _.startsWith(PREFIX))\n    .map(_ => _.substring(PREFIX.length))\n}\n\nexport async function addKnownInstance (instanceName) {\n  return set(PREFIX + instanceName, true)\n}\n\nexport async function deleteKnownInstance (instanceName) {\n  return del(PREFIX + instanceName)\n}\n","import {\n  ACCOUNTS_STORE, DB_VERSION_SNOWFLAKE_IDS, DB_VERSION_INITIAL,\n  DB_VERSION_SEARCH_ACCOUNTS, META_STORE,\n  NOTIFICATION_TIMELINES_STORE,\n  NOTIFICATIONS_STORE, PINNED_STATUSES_STORE,\n  REBLOG_ID, RELATIONSHIPS_STORE,\n  STATUS_ID,\n  STATUS_TIMELINES_STORE,\n  STATUSES_STORE, THREADS_STORE,\n  TIMESTAMP, USERNAME_LOWERCASE\n} from './constants'\nimport { toReversePaddedBigInt } from '../_utils/statusIdSorting'\n\nfunction initialMigration (db, tx, done) {\n  function createObjectStore (name, init, indexes) {\n    const store = init\n      ? db.createObjectStore(name, init)\n      : db.createObjectStore(name)\n    if (indexes) {\n      Object.keys(indexes).forEach(indexKey => {\n        store.createIndex(indexKey, indexes[indexKey])\n      })\n    }\n  }\n\n  createObjectStore(STATUSES_STORE, { keyPath: 'id' }, {\n    [TIMESTAMP]: TIMESTAMP,\n    [REBLOG_ID]: REBLOG_ID\n  })\n  createObjectStore(STATUS_TIMELINES_STORE, null, {\n    statusId: ''\n  })\n  createObjectStore(NOTIFICATIONS_STORE, { keyPath: 'id' }, {\n    [TIMESTAMP]: TIMESTAMP,\n    [STATUS_ID]: STATUS_ID\n  })\n  createObjectStore(NOTIFICATION_TIMELINES_STORE, null, {\n    notificationId: ''\n  })\n  createObjectStore(ACCOUNTS_STORE, { keyPath: 'id' }, {\n    [TIMESTAMP]: TIMESTAMP\n  })\n  createObjectStore(RELATIONSHIPS_STORE, { keyPath: 'id' }, {\n    [TIMESTAMP]: TIMESTAMP\n  })\n  createObjectStore(THREADS_STORE, null, {\n    statusId: ''\n  })\n  createObjectStore(PINNED_STATUSES_STORE, null, {\n    statusId: ''\n  })\n  createObjectStore(META_STORE)\n  done()\n}\n\nfunction addSearchAccountsMigration (db, tx, done) {\n  tx.objectStore(ACCOUNTS_STORE)\n    .createIndex(USERNAME_LOWERCASE, USERNAME_LOWERCASE)\n  done()\n}\n\nfunction snowflakeIdsMigration (db, tx, done) {\n  const stores = [STATUS_TIMELINES_STORE, NOTIFICATION_TIMELINES_STORE]\n  let storeDoneCount = 0\n\n  // Here we have to convert the old \"reversePaddedBigInt\" format to the new\n  // one which is compatible with Pleroma-style snowflake IDs.\n  stores.forEach(store => {\n    const objectStore = tx.objectStore(store)\n    const cursor = objectStore.openCursor()\n    cursor.onsuccess = e => {\n      const { result } = e.target\n      if (result) {\n        const { key, value } = result\n        // key is timeline name plus delimiter plus reverse padded big int\n        const newKey = key.split('\\u0000')[0] + '\\u0000' + toReversePaddedBigInt(value)\n\n        objectStore.delete(key).onsuccess = () => {\n          objectStore.add(value, newKey).onsuccess = () => {\n            result.continue()\n          }\n        }\n      } else {\n        if (++storeDoneCount === stores.length) {\n          done()\n        }\n      }\n    }\n  })\n}\n\nexport const migrations = [\n  {\n    version: DB_VERSION_INITIAL,\n    migration: initialMigration\n  },\n  {\n    version: DB_VERSION_SEARCH_ACCOUNTS,\n    migration: addSearchAccountsMigration\n  },\n  {\n    version: DB_VERSION_SNOWFLAKE_IDS,\n    migration: snowflakeIdsMigration\n  }\n]\n","import { DB_VERSION_CURRENT } from './constants'\nimport { addKnownInstance, deleteKnownInstance } from './knownInstances'\nimport { migrations } from './migrations'\nimport { clearAllCaches } from './cache'\nimport { lifecycle } from '../_utils/lifecycle'\nimport { scheduleIdleTask } from '../_utils/scheduleIdleTask'\nimport { del } from '../_thirdparty/idb-keyval/idb-keyval'\n\nconst openReqs = {}\nconst databaseCache = {}\n\nfunction createDatabase (instanceName) {\n  return new Promise((resolve, reject) => {\n    const req = indexedDB.open(instanceName, DB_VERSION_CURRENT.version)\n    openReqs[instanceName] = req\n    req.onerror = reject\n    req.onblocked = () => {\n      console.error('idb blocked')\n    }\n    req.onupgradeneeded = (e) => {\n      const db = req.result\n      const tx = e.currentTarget.transaction\n\n      const migrationsToDo = migrations.filter(({ version }) => e.oldVersion < version)\n\n      function doNextMigration () {\n        if (!migrationsToDo.length) {\n          return\n        }\n        const { migration } = migrationsToDo.shift()\n        migration(db, tx, doNextMigration)\n      }\n      doNextMigration()\n    }\n    req.onsuccess = () => resolve(req.result)\n  })\n}\n\nexport async function getDatabase (instanceName) {\n  if (!instanceName) {\n    throw new Error('instanceName is undefined in getDatabase()')\n  }\n  if (!databaseCache[instanceName]) {\n    databaseCache[instanceName] = await createDatabase(instanceName)\n    await addKnownInstance(instanceName)\n  }\n  return databaseCache[instanceName]\n}\n\nexport async function dbPromise (db, storeName, readOnlyOrReadWrite, cb) {\n  return new Promise((resolve, reject) => {\n    const tx = db.transaction(storeName, readOnlyOrReadWrite)\n    const store = typeof storeName === 'string'\n      ? tx.objectStore(storeName)\n      : storeName.map(name => tx.objectStore(name))\n    let res\n    cb(store, (result) => {\n      res = result\n    })\n\n    tx.oncomplete = () => resolve(res)\n    tx.onerror = () => reject(tx.error)\n  })\n}\n\nexport function deleteDatabase (instanceName) {\n  return new Promise((resolve, reject) => {\n    // close any open requests\n    const openReq = openReqs[instanceName]\n    if (openReq && openReq.result) {\n      openReq.result.close()\n    }\n    delete openReqs[instanceName]\n    delete databaseCache[instanceName]\n    const req = indexedDB.deleteDatabase(instanceName)\n    req.onsuccess = () => resolve()\n    req.onerror = () => reject(req.error)\n    req.onblocked = () => console.error(`database ${instanceName} blocked`)\n  }).then(() => deleteKnownInstance(instanceName))\n    .then(() => clearAllCaches(instanceName))\n}\n\nexport function closeDatabase (instanceName) {\n  // close any open requests\n  const openReq = openReqs[instanceName]\n  if (openReq && openReq.result) {\n    openReq.result.close()\n  }\n  delete openReqs[instanceName]\n  delete databaseCache[instanceName]\n  clearAllCaches(instanceName)\n}\n\nif (process.browser) {\n  lifecycle.addEventListener('statechange', event => {\n    if (event.newState === 'frozen') { // page is frozen, close IDB connections\n      Object.keys(openReqs).forEach(instanceName => {\n        closeDatabase(instanceName)\n        console.log('closed instance DBs')\n      })\n    }\n  })\n\n  // Clean up files that Tesseract.js may have stored. Originally we allowed it to store\n  // stuff in IDB, but now we don't.\n  // TODO: we can remove this after it's been deployed for a while\n  scheduleIdleTask(() => del('./eng.traineddata'))\n}\n","import { dbPromise, getDatabase } from './databaseLifecycle'\nimport { getInCache, hasInCache, setInCache } from './cache'\nimport {\n  ACCOUNT_ID, REBLOG_ID, STATUS_ID, TIMESTAMP, USERNAME_LOWERCASE, CURRENT_TIME\n} from './constants'\n\nexport async function getGenericEntityWithId (store, cache, instanceName, id) {\n  if (hasInCache(cache, instanceName, id)) {\n    return getInCache(cache, instanceName, id)\n  }\n  const db = await getDatabase(instanceName)\n  const result = await dbPromise(db, store, 'readonly', (store, callback) => {\n    store.get(id).onsuccess = (e) => callback(e.target.result)\n  })\n  setInCache(cache, instanceName, id, result)\n  return result\n}\n\nexport async function setGenericEntityWithId (store, cache, instanceName, entity) {\n  setInCache(cache, instanceName, entity.id, entity)\n  const db = await getDatabase(instanceName)\n  return dbPromise(db, store, 'readwrite', (store) => {\n    store.put(entity)\n  })\n}\n\nexport function cloneForStorage (obj) {\n  const res = {}\n  const keys = Object.keys(obj)\n  for (const key of keys) {\n    const value = obj[key]\n    // save storage space by skipping nulls, 0s, falses, empty strings, and empty arrays\n    if (!value || (Array.isArray(value) && value.length === 0)) {\n      continue\n    }\n    switch (key) {\n      case 'account':\n        res[ACCOUNT_ID] = value.id\n        break\n      case 'status':\n        res[STATUS_ID] = value.id\n        break\n      case 'reblog':\n        res[REBLOG_ID] = value.id\n        break\n      case 'acct':\n        res[key] = value\n        res[USERNAME_LOWERCASE] = value.toLowerCase()\n        break\n      default:\n        res[key] = value\n        break\n    }\n  }\n  res[TIMESTAMP] = CURRENT_TIME.now()\n  return res\n}\n","import { toReversePaddedBigInt, zeroPad } from '../_utils/statusIdSorting'\n\n//\n// timelines\n//\n\nexport function createTimelineId (timeline, id) {\n  // reverse chronological order, prefixed by timeline\n  return timeline + '\\u0000' + toReversePaddedBigInt(id)\n}\n\nexport function createTimelineKeyRange (timeline, maxId) {\n  const negBigInt = maxId && toReversePaddedBigInt(maxId)\n  const start = negBigInt ? (timeline + '\\u0000' + negBigInt) : (timeline + '\\u0000')\n  const end = timeline + '\\u0000\\uffff'\n  return IDBKeyRange.bound(start, end, true, true)\n}\n\n//\n// threads\n//\n\nexport function createThreadId (statusId, i) {\n  return statusId + '\\u0000' + zeroPad(i, 5)\n}\n\nexport function createThreadKeyRange (statusId) {\n  return IDBKeyRange.bound(\n    statusId + '\\u0000',\n    statusId + '\\u0000\\uffff'\n  )\n}\n\n//\n// pinned statues\n//\n\nexport function createPinnedStatusId (accountId, i) {\n  return accountId + '\\u0000' + zeroPad(i, 3)\n}\n\nexport function createPinnedStatusKeyRange (accountId) {\n  return IDBKeyRange.bound(\n    accountId + '\\u0000',\n    accountId + '\\u0000\\uffff'\n  )\n}\n\n//\n// accounts\n//\n\nexport function createAccountUsernamePrefixKeyRange (accountUsernamePrefix) {\n  return IDBKeyRange.bound(\n    accountUsernamePrefix,\n    accountUsernamePrefix + '\\uffff'\n  )\n}\n","import { ACCOUNTS_STORE, USERNAME_LOWERCASE } from './constants'\nimport { accountsCache } from './cache'\nimport { cloneForStorage, getGenericEntityWithId, setGenericEntityWithId } from './helpers'\nimport { dbPromise, getDatabase } from './databaseLifecycle'\nimport { createAccountUsernamePrefixKeyRange } from './keys'\n\nexport async function getAccount (instanceName, accountId) {\n  return getGenericEntityWithId(ACCOUNTS_STORE, accountsCache, instanceName, accountId)\n}\n\nexport async function setAccount (instanceName, account) {\n  return setGenericEntityWithId(ACCOUNTS_STORE, accountsCache, instanceName, cloneForStorage(account))\n}\n\nexport async function searchAccountsByUsername (instanceName, usernamePrefix, limit) {\n  limit = limit || 20\n  const db = await getDatabase(instanceName)\n  return dbPromise(db, ACCOUNTS_STORE, 'readonly', (accountsStore, callback) => {\n    const keyRange = createAccountUsernamePrefixKeyRange(usernamePrefix.toLowerCase())\n    accountsStore.index(USERNAME_LOWERCASE).getAll(keyRange, limit).onsuccess = e => {\n      callback(e.target.result)\n    }\n  })\n}\n","import { accountsCache, clearCache, metaCache, statusesCache } from './cache'\nimport { deleteDatabase } from './databaseLifecycle'\n\nexport async function clearDatabaseForInstance (instanceName) {\n  clearCache(statusesCache, instanceName)\n  clearCache(accountsCache, instanceName)\n  clearCache(metaCache, instanceName)\n  await deleteDatabase(instanceName)\n}\n","import { dbPromise, getDatabase } from '../databaseLifecycle'\nimport { STATUSES_STORE, STATUS_ID, REBLOG_ID, NOTIFICATIONS_STORE } from '../constants'\n\nexport async function getReblogsForStatus (instanceName, id) {\n  const db = await getDatabase(instanceName)\n  await dbPromise(db, STATUSES_STORE, 'readonly', (statusesStore, callback) => {\n    statusesStore.index(REBLOG_ID).getAll(IDBKeyRange.only(id)).onsuccess = e => {\n      callback(e.target.result)\n    }\n  })\n}\n\nexport async function getNotificationIdsForStatuses (instanceName, statusIds) {\n  const db = await getDatabase(instanceName)\n  return dbPromise(db, NOTIFICATIONS_STORE, 'readonly', (notificationsStore, callback) => {\n    const res = []\n    callback(res)\n    statusIds.forEach(statusId => {\n      const req = notificationsStore.index(STATUS_ID).getAllKeys(IDBKeyRange.only(statusId))\n      req.onsuccess = e => {\n        for (const id of e.target.result) {\n          res.push(id)\n        }\n      }\n    })\n  })\n}\n","import {\n  accountsCache, setInCache, statusesCache\n} from '../cache'\n\nexport function cacheStatus (status, instanceName) {\n  setInCache(statusesCache, instanceName, status.id, status)\n  setInCache(accountsCache, instanceName, status.account.id, status.account)\n  if (status.reblog) {\n    setInCache(accountsCache, instanceName, status.reblog.account.id, status.reblog.account)\n  }\n}\n","export function deleteAll (store, index, keyRange) {\n  index.getAllKeys(keyRange).onsuccess = e => {\n    for (const result of e.target.result) {\n      store.delete(result)\n    }\n  }\n}\n","import { dbPromise, getDatabase } from './databaseLifecycle'\nimport {\n  ACCOUNTS_STORE,\n  NOTIFICATION_TIMELINES_STORE,\n  NOTIFICATIONS_STORE,\n  PINNED_STATUSES_STORE,\n  RELATIONSHIPS_STORE,\n  STATUS_TIMELINES_STORE,\n  STATUSES_STORE,\n  THREADS_STORE,\n  TIMESTAMP\n} from './constants'\nimport debounce from 'lodash-es/debounce'\nimport { mark, stop } from '../_utils/marks'\nimport { deleteAll } from './utils'\nimport { createPinnedStatusKeyRange, createThreadKeyRange } from './keys'\nimport { getKnownInstances } from './knownInstances'\nimport noop from 'lodash-es/noop'\nimport { CLEANUP_DELAY, CLEANUP_TIME_AGO } from '../_static/database'\nimport { scheduleIdleTask } from '../_utils/scheduleIdleTask'\n\nconst BATCH_SIZE = 20\n\nfunction batchedGetAll (callGetAll, callback) {\n  function nextBatch () {\n    callGetAll().onsuccess = function (e) {\n      const results = e.target.result\n      callback(results)\n      if (results.length) {\n        nextBatch()\n      }\n    }\n  }\n  nextBatch()\n}\n\nfunction cleanupStatuses (statusesStore, statusTimelinesStore, threadsStore, cutoff) {\n  batchedGetAll(\n    () => statusesStore.index(TIMESTAMP).getAllKeys(IDBKeyRange.upperBound(cutoff), BATCH_SIZE),\n    results => {\n      results.forEach(statusId => {\n        statusesStore.delete(statusId)\n        deleteAll(\n          statusTimelinesStore,\n          statusTimelinesStore.index('statusId'),\n          IDBKeyRange.only(statusId)\n        )\n        deleteAll(\n          threadsStore,\n          threadsStore,\n          createThreadKeyRange(statusId)\n        )\n      })\n    }\n  )\n}\n\nfunction cleanupNotifications (notificationsStore, notificationTimelinesStore, cutoff) {\n  batchedGetAll(\n    () => notificationsStore.index(TIMESTAMP).getAllKeys(IDBKeyRange.upperBound(cutoff), BATCH_SIZE),\n    results => {\n      results.forEach(notificationId => {\n        notificationsStore.delete(notificationId)\n        deleteAll(\n          notificationTimelinesStore,\n          notificationTimelinesStore.index('notificationId'),\n          IDBKeyRange.only(notificationId)\n        )\n      })\n    }\n  )\n}\n\nfunction cleanupAccounts (accountsStore, pinnedStatusesStore, cutoff) {\n  batchedGetAll(\n    () => accountsStore.index(TIMESTAMP).getAllKeys(IDBKeyRange.upperBound(cutoff), BATCH_SIZE),\n    results => {\n      results.forEach(accountId => {\n        accountsStore.delete(accountId)\n        deleteAll(\n          pinnedStatusesStore,\n          pinnedStatusesStore,\n          createPinnedStatusKeyRange(accountId)\n        )\n      })\n    }\n  )\n}\n\nfunction cleanupRelationships (relationshipsStore, cutoff) {\n  batchedGetAll(\n    () => relationshipsStore.index(TIMESTAMP).getAllKeys(IDBKeyRange.upperBound(cutoff), BATCH_SIZE),\n    results => {\n      results.forEach(relationshipId => {\n        relationshipsStore.delete(relationshipId)\n      })\n    }\n  )\n}\n\nexport async function cleanup (instanceName) {\n  console.log('cleanup', instanceName)\n  mark(`cleanup:${instanceName}`)\n  const db = await getDatabase(instanceName)\n  const storeNames = [\n    STATUSES_STORE,\n    STATUS_TIMELINES_STORE,\n    NOTIFICATIONS_STORE,\n    NOTIFICATION_TIMELINES_STORE,\n    ACCOUNTS_STORE,\n    RELATIONSHIPS_STORE,\n    THREADS_STORE,\n    PINNED_STATUSES_STORE\n  ]\n  await dbPromise(db, storeNames, 'readwrite', (stores) => {\n    const [\n      statusesStore,\n      statusTimelinesStore,\n      notificationsStore,\n      notificationTimelinesStore,\n      accountsStore,\n      relationshipsStore,\n      threadsStore,\n      pinnedStatusesStore\n    ] = stores\n\n    const cutoff = Date.now() - CLEANUP_TIME_AGO\n\n    cleanupStatuses(statusesStore, statusTimelinesStore, threadsStore, cutoff)\n    cleanupNotifications(notificationsStore, notificationTimelinesStore, cutoff)\n    cleanupAccounts(accountsStore, pinnedStatusesStore, cutoff)\n    cleanupRelationships(relationshipsStore, cutoff)\n  })\n  stop(`cleanup:${instanceName}`)\n}\n\nfunction doCleanup (instanceName) {\n  scheduleIdleTask(() => cleanup(instanceName))\n}\n\nasync function scheduledCleanup () {\n  console.log('scheduledCleanup')\n  const knownInstances = await getKnownInstances()\n  for (const instance of knownInstances) {\n    doCleanup(instance)\n  }\n}\n\n// we have unit tests that test indexedDB; we don't want this thing to run forever\nexport const scheduleCleanup = process.browser ? debounce(scheduledCleanup, CLEANUP_DELAY) : noop\n","import difference from 'lodash-es/difference'\nimport times from 'lodash-es/times'\nimport { cloneForStorage } from '../helpers'\nimport { dbPromise, getDatabase } from '../databaseLifecycle'\nimport { accountsCache, notificationsCache, setInCache, statusesCache } from '../cache'\nimport { scheduleCleanup } from '../cleanup'\nimport {\n  ACCOUNTS_STORE,\n  NOTIFICATION_TIMELINES_STORE,\n  NOTIFICATIONS_STORE,\n  STATUS_TIMELINES_STORE,\n  STATUSES_STORE,\n  THREADS_STORE\n} from '../constants'\nimport {\n  createThreadId,\n  createThreadKeyRange,\n  createTimelineId\n} from '../keys'\nimport { cacheStatus } from './cacheStatus'\n\nexport function putStatus (statusesStore, status) {\n  statusesStore.put(cloneForStorage(status))\n}\n\nexport function putAccount (accountsStore, account) {\n  accountsStore.put(cloneForStorage(account))\n}\n\nexport function putNotification (notificationsStore, notification) {\n  notificationsStore.put(cloneForStorage(notification))\n}\n\nexport function storeAccount (accountsStore, account) {\n  putAccount(accountsStore, account)\n}\n\nexport function storeStatus (statusesStore, accountsStore, status) {\n  putStatus(statusesStore, status)\n  putAccount(accountsStore, status.account)\n  if (status.reblog) {\n    putStatus(statusesStore, status.reblog)\n    putAccount(accountsStore, status.reblog.account)\n  }\n}\n\nexport function storeNotification (notificationsStore, statusesStore, accountsStore, notification) {\n  if (notification.status) {\n    storeStatus(statusesStore, accountsStore, notification.status)\n  }\n  storeAccount(accountsStore, notification.account)\n  putNotification(notificationsStore, notification)\n}\n\nasync function insertTimelineNotifications (instanceName, timeline, notifications) {\n  for (const notification of notifications) {\n    setInCache(notificationsCache, instanceName, notification.id, notification)\n    setInCache(accountsCache, instanceName, notification.account.id, notification.account)\n    if (notification.status) {\n      setInCache(statusesCache, instanceName, notification.status.id, notification.status)\n    }\n  }\n  const db = await getDatabase(instanceName)\n  const storeNames = [NOTIFICATION_TIMELINES_STORE, NOTIFICATIONS_STORE, ACCOUNTS_STORE, STATUSES_STORE]\n  await dbPromise(db, storeNames, 'readwrite', (stores) => {\n    const [timelineStore, notificationsStore, accountsStore, statusesStore] = stores\n    for (const notification of notifications) {\n      storeNotification(notificationsStore, statusesStore, accountsStore, notification)\n      timelineStore.put(notification.id, createTimelineId(timeline, notification.id))\n    }\n  })\n}\n\nasync function insertTimelineStatuses (instanceName, timeline, statuses) {\n  for (const status of statuses) {\n    cacheStatus(status, instanceName)\n  }\n  const db = await getDatabase(instanceName)\n  const storeNames = [STATUS_TIMELINES_STORE, STATUSES_STORE, ACCOUNTS_STORE]\n  await dbPromise(db, storeNames, 'readwrite', (stores) => {\n    const [timelineStore, statusesStore, accountsStore] = stores\n    for (const status of statuses) {\n      storeStatus(statusesStore, accountsStore, status)\n      timelineStore.put(status.id, createTimelineId(timeline, status.id))\n    }\n  })\n}\n\nasync function insertStatusThread (instanceName, statusId, statuses) {\n  for (const status of statuses) {\n    cacheStatus(status, instanceName)\n  }\n  const db = await getDatabase(instanceName)\n  const storeNames = [THREADS_STORE, STATUSES_STORE, ACCOUNTS_STORE]\n  await dbPromise(db, storeNames, 'readwrite', (stores) => {\n    const [threadsStore, statusesStore, accountsStore] = stores\n    threadsStore.getAllKeys(createThreadKeyRange(statusId)).onsuccess = e => {\n      const existingKeys = e.target.result\n      const newKeys = times(statuses.length, i => createThreadId(statusId, i))\n      const keysToDelete = difference(existingKeys, newKeys)\n      for (const key of keysToDelete) {\n        threadsStore.delete(key)\n      }\n    }\n    statuses.forEach((otherStatus, i) => {\n      storeStatus(statusesStore, accountsStore, otherStatus)\n      threadsStore.put(otherStatus.id, createThreadId(statusId, i))\n    })\n  })\n}\n\nexport async function insertTimelineItems (instanceName, timeline, timelineItems) {\n  console.log('insertTimelineItems', instanceName, timeline, timelineItems)\n  /* no await */ scheduleCleanup()\n  if (timeline === 'notifications' || timeline === 'notifications/mentions') {\n    return insertTimelineNotifications(instanceName, timeline, timelineItems)\n  } else if (timeline.startsWith('status/')) {\n    const statusId = timeline.split('/').slice(-1)[0]\n    return insertStatusThread(instanceName, statusId, timelineItems)\n  } else {\n    return insertTimelineStatuses(instanceName, timeline, timelineItems)\n  }\n}\n\nexport async function insertStatus (instanceName, status) {\n  cacheStatus(status, instanceName)\n  const db = await getDatabase(instanceName)\n  await dbPromise(db, [STATUSES_STORE, ACCOUNTS_STORE], 'readwrite', ([statusesStore, accountsStore]) => {\n    storeStatus(statusesStore, accountsStore, status)\n  })\n}\n","export function fetchAccount (accountsStore, id, callback) {\n  accountsStore.get(id).onsuccess = e => {\n    callback(e.target.result)\n  }\n}\n","import { fetchAccount } from './fetchAccount'\nimport { ACCOUNT_ID, REBLOG_ID } from '../constants'\n\nexport function fetchStatus (statusesStore, accountsStore, id, callback) {\n  statusesStore.get(id).onsuccess = e => {\n    const status = e.target.result\n    callback(status)\n    if (!status) {\n      return\n    }\n    fetchAccount(accountsStore, status[ACCOUNT_ID], account => {\n      status.account = account\n    })\n    if (status[REBLOG_ID]) {\n      fetchStatus(statusesStore, accountsStore, status[REBLOG_ID], reblog => {\n        status.reblog = reblog\n      })\n    }\n  }\n}\n","import { cacheStatus } from './cacheStatus'\nimport { getDatabase, dbPromise } from '../databaseLifecycle'\nimport { PINNED_STATUSES_STORE, STATUSES_STORE, ACCOUNTS_STORE } from '../constants'\nimport { createPinnedStatusId, createPinnedStatusKeyRange } from '../keys'\nimport { storeStatus } from './insertion'\nimport { fetchStatus } from './fetchStatus'\n\nexport async function insertPinnedStatuses (instanceName, accountId, statuses) {\n  for (const status of statuses) {\n    cacheStatus(status, instanceName)\n  }\n  const db = await getDatabase(instanceName)\n  const storeNames = [PINNED_STATUSES_STORE, STATUSES_STORE, ACCOUNTS_STORE]\n  await dbPromise(db, storeNames, 'readwrite', (stores) => {\n    const [pinnedStatusesStore, statusesStore, accountsStore] = stores\n\n    const keyRange = createPinnedStatusKeyRange(accountId)\n    pinnedStatusesStore.getAll(keyRange).onsuccess = e => {\n      // if there was e.g. 1 pinned status before and 2 now, then we need to delete the old one\n      const existingPinnedStatuses = e.target.result\n      for (let i = statuses.length; i < existingPinnedStatuses.length; i++) {\n        pinnedStatusesStore.delete(createPinnedStatusKeyRange(accountId, i))\n      }\n      statuses.forEach((status, i) => {\n        storeStatus(statusesStore, accountsStore, status)\n        pinnedStatusesStore.put(status.id, createPinnedStatusId(accountId, i))\n      })\n    }\n  })\n}\n\nexport async function getPinnedStatuses (instanceName, accountId) {\n  const storeNames = [PINNED_STATUSES_STORE, STATUSES_STORE, ACCOUNTS_STORE]\n  const db = await getDatabase(instanceName)\n  return dbPromise(db, storeNames, 'readonly', (stores, callback) => {\n    const [pinnedStatusesStore, statusesStore, accountsStore] = stores\n    const keyRange = createPinnedStatusKeyRange(accountId)\n    pinnedStatusesStore.getAll(keyRange).onsuccess = e => {\n      const pinnedResults = e.target.result\n      const res = new Array(pinnedResults.length)\n      pinnedResults.forEach((statusId, i) => {\n        fetchStatus(statusesStore, accountsStore, statusId, status => {\n          res[i] = status\n        })\n      })\n      callback(res)\n    }\n  })\n}\n","import { fetchAccount } from './fetchAccount'\nimport { ACCOUNT_ID, STATUS_ID } from '../constants'\nimport { fetchStatus } from './fetchStatus'\n\nexport function fetchNotification (notificationsStore, statusesStore, accountsStore, id, callback) {\n  notificationsStore.get(id).onsuccess = e => {\n    const notification = e.target.result\n    callback(notification)\n    fetchAccount(accountsStore, notification[ACCOUNT_ID], account => {\n      notification.account = account\n    })\n    if (notification[STATUS_ID]) {\n      fetchStatus(statusesStore, accountsStore, notification[STATUS_ID], status => {\n        notification.status = status\n      })\n    }\n  }\n}\n","import { dbPromise, getDatabase } from '../databaseLifecycle'\nimport {\n  ACCOUNTS_STORE,\n  NOTIFICATION_TIMELINES_STORE,\n  NOTIFICATIONS_STORE,\n  STATUS_TIMELINES_STORE,\n  STATUSES_STORE,\n  THREADS_STORE\n} from '../constants'\nimport {\n  createThreadKeyRange,\n  createTimelineKeyRange\n} from '../keys'\nimport { fetchStatus } from './fetchStatus'\nimport { fetchNotification } from './fetchNotification'\nimport { TIMELINE_BATCH_SIZE } from '../../_static/timelines'\n\nasync function getNotificationTimeline (instanceName, timeline, maxId, limit) {\n  const storeNames = [NOTIFICATION_TIMELINES_STORE, NOTIFICATIONS_STORE, STATUSES_STORE, ACCOUNTS_STORE]\n  const db = await getDatabase(instanceName)\n  return dbPromise(db, storeNames, 'readonly', (stores, callback) => {\n    const [timelineStore, notificationsStore, statusesStore, accountsStore] = stores\n    const keyRange = createTimelineKeyRange(timeline, maxId)\n\n    timelineStore.getAll(keyRange, limit).onsuccess = e => {\n      const timelineResults = e.target.result\n      const res = new Array(timelineResults.length)\n      timelineResults.forEach((notificationId, i) => {\n        fetchNotification(notificationsStore, statusesStore, accountsStore, notificationId, notification => {\n          res[i] = notification\n        })\n      })\n      callback(res)\n    }\n  })\n}\n\nasync function getStatusTimeline (instanceName, timeline, maxId, limit) {\n  const storeNames = [STATUS_TIMELINES_STORE, STATUSES_STORE, ACCOUNTS_STORE]\n  const db = await getDatabase(instanceName)\n  return dbPromise(db, storeNames, 'readonly', (stores, callback) => {\n    const [timelineStore, statusesStore, accountsStore] = stores\n    const getReq = timelineStore.getAll(createTimelineKeyRange(timeline, maxId), limit)\n    getReq.onsuccess = e => {\n      const timelineResults = e.target.result\n      const res = new Array(timelineResults.length)\n      timelineResults.forEach((statusId, i) => {\n        fetchStatus(statusesStore, accountsStore, statusId, status => {\n          res[i] = status\n        })\n      })\n      callback(res)\n    }\n  })\n}\n\nasync function getStatusThread (instanceName, statusId) {\n  const storeNames = [THREADS_STORE, STATUSES_STORE, ACCOUNTS_STORE]\n  const db = await getDatabase(instanceName)\n  return dbPromise(db, storeNames, 'readonly', (stores, callback) => {\n    const [threadsStore, statusesStore, accountsStore] = stores\n    const keyRange = createThreadKeyRange(statusId)\n    threadsStore.getAll(keyRange).onsuccess = e => {\n      const thread = e.target.result\n      if (thread.length) {\n        const res = new Array(thread.length)\n        callback(res)\n        thread.forEach((otherStatusId, i) => {\n          fetchStatus(statusesStore, accountsStore, otherStatusId, status => {\n            res[i] = status\n          })\n        })\n      } else {\n        // thread not cached; just make a \"fake\" thread with only one status in it\n        fetchStatus(statusesStore, accountsStore, statusId, status => {\n          const res = [status]\n          callback(res)\n        })\n      }\n    }\n  })\n}\n\nexport async function getTimeline (instanceName, timeline, maxId, limit) {\n  maxId = maxId || null\n  limit = limit || TIMELINE_BATCH_SIZE\n  if (timeline === 'notifications' || timeline === 'notifications/mentions') {\n    return getNotificationTimeline(instanceName, timeline, maxId, limit)\n  } else if (timeline.startsWith('status/')) {\n    const statusId = timeline.split('/').slice(-1)[0]\n    return getStatusThread(instanceName, statusId)\n  } else {\n    return getStatusTimeline(instanceName, timeline, maxId, limit)\n  }\n}\n","import { dbPromise, getDatabase } from '../databaseLifecycle'\nimport { getInCache, hasInCache, notificationsCache, setInCache, statusesCache } from '../cache'\nimport {\n  ACCOUNTS_STORE,\n  NOTIFICATIONS_STORE,\n  STATUSES_STORE\n} from '../constants'\nimport { fetchStatus } from './fetchStatus'\nimport { fetchNotification } from './fetchNotification'\n\nexport async function getStatus (instanceName, id) {\n  if (hasInCache(statusesCache, instanceName, id)) {\n    return getInCache(statusesCache, instanceName, id)\n  }\n  const db = await getDatabase(instanceName)\n  const storeNames = [STATUSES_STORE, ACCOUNTS_STORE]\n  const result = await dbPromise(db, storeNames, 'readonly', (stores, callback) => {\n    const [statusesStore, accountsStore] = stores\n    fetchStatus(statusesStore, accountsStore, id, callback)\n  })\n  setInCache(statusesCache, instanceName, id, result)\n  return result\n}\n\nexport async function getNotification (instanceName, id) {\n  if (hasInCache(notificationsCache, instanceName, id)) {\n    return getInCache(notificationsCache, instanceName, id)\n  }\n  const db = await getDatabase(instanceName)\n  const storeNames = [NOTIFICATIONS_STORE, STATUSES_STORE, ACCOUNTS_STORE]\n  const result = await dbPromise(db, storeNames, 'readonly', (stores, callback) => {\n    const [notificationsStore, statusesStore, accountsStore] = stores\n    fetchNotification(notificationsStore, statusesStore, accountsStore, id, callback)\n  })\n  setInCache(notificationsCache, instanceName, id, result)\n  return result\n}\n","import { dbPromise, getDatabase } from '../databaseLifecycle'\nimport { getInCache, hasInCache, statusesCache } from '../cache'\nimport { STATUSES_STORE } from '../constants'\nimport { cacheStatus } from './cacheStatus'\nimport { putStatus } from './insertion'\n\n//\n// update statuses\n//\n\nasync function updateStatus (instanceName, statusId, updateFunc) {\n  const db = await getDatabase(instanceName)\n  if (hasInCache(statusesCache, instanceName, statusId)) {\n    const status = getInCache(statusesCache, instanceName, statusId)\n    updateFunc(status)\n    cacheStatus(status, instanceName)\n  }\n  return dbPromise(db, STATUSES_STORE, 'readwrite', (statusesStore) => {\n    statusesStore.get(statusId).onsuccess = e => {\n      const status = e.target.result\n      updateFunc(status)\n      putStatus(statusesStore, status)\n    }\n  })\n}\n\nexport async function setStatusFavorited (instanceName, statusId, favorited) {\n  return updateStatus(instanceName, statusId, status => {\n    const delta = (favorited ? 1 : 0) - (status.favourited ? 1 : 0)\n    status.favourited = favorited\n    status.favourites_count = (status.favourites_count || 0) + delta\n  })\n}\n\nexport async function setStatusReblogged (instanceName, statusId, reblogged) {\n  return updateStatus(instanceName, statusId, status => {\n    const delta = (reblogged ? 1 : 0) - (status.reblogged ? 1 : 0)\n    status.reblogged = reblogged\n    status.reblogs_count = (status.reblogs_count || 0) + delta\n  })\n}\n\nexport async function setStatusPinned (instanceName, statusId, pinned) {\n  return updateStatus(instanceName, statusId, status => {\n    status.pinned = pinned\n  })\n}\n\nexport async function setStatusMuted (instanceName, statusId, muted) {\n  return updateStatus(instanceName, statusId, status => {\n    status.muted = muted\n  })\n}\n\nexport async function setStatusBookmarked (instanceName, statusId, bookmarked) {\n  return updateStatus(instanceName, statusId, status => {\n    status.bookmarked = bookmarked\n  })\n}\n","import { dbPromise, getDatabase } from '../databaseLifecycle'\nimport {\n  deleteFromCache, notificationsCache,\n  statusesCache\n} from '../cache'\nimport {\n  NOTIFICATION_TIMELINES_STORE,\n  NOTIFICATIONS_STORE, PINNED_STATUSES_STORE,\n  STATUS_TIMELINES_STORE,\n  STATUSES_STORE,\n  THREADS_STORE\n} from '../constants'\nimport {\n  createThreadKeyRange\n} from '../keys'\nimport { deleteAll } from '../utils'\n\nexport async function deleteStatusesAndNotifications (instanceName, statusIds, notificationIds) {\n  for (const statusId of statusIds) {\n    deleteFromCache(statusesCache, instanceName, statusId)\n  }\n  for (const notificationId of notificationIds) {\n    deleteFromCache(notificationsCache, instanceName, notificationId)\n  }\n  const db = await getDatabase(instanceName)\n  const storeNames = [\n    STATUSES_STORE,\n    STATUS_TIMELINES_STORE,\n    NOTIFICATIONS_STORE,\n    NOTIFICATION_TIMELINES_STORE,\n    PINNED_STATUSES_STORE,\n    THREADS_STORE\n  ]\n  await dbPromise(db, storeNames, 'readwrite', (stores) => {\n    const [\n      statusesStore,\n      statusTimelinesStore,\n      notificationsStore,\n      notificationTimelinesStore,\n      pinnedStatusesStore,\n      threadsStore\n    ] = stores\n\n    function deleteStatus (statusId) {\n      statusesStore.delete(statusId)\n      deleteAll(\n        pinnedStatusesStore,\n        pinnedStatusesStore.index('statusId'),\n        IDBKeyRange.only(statusId)\n      )\n      deleteAll(\n        statusTimelinesStore,\n        statusTimelinesStore.index('statusId'),\n        IDBKeyRange.only(statusId)\n      )\n      deleteAll(\n        threadsStore,\n        threadsStore.index('statusId'),\n        IDBKeyRange.only(statusId)\n      )\n      deleteAll(\n        threadsStore,\n        threadsStore,\n        createThreadKeyRange(statusId)\n      )\n    }\n\n    function deleteNotification (notificationId) {\n      notificationsStore.delete(notificationId)\n      deleteAll(\n        notificationTimelinesStore,\n        notificationTimelinesStore.index('notificationId'),\n        IDBKeyRange.only(notificationId)\n      )\n    }\n\n    for (const statusId of statusIds) {\n      deleteStatus(statusId)\n    }\n    for (const notificationId of notificationIds) {\n      deleteNotification(notificationId)\n    }\n  })\n}\n","import { dbPromise, getDatabase } from './databaseLifecycle'\nimport { META_STORE } from './constants'\nimport { metaCache, hasInCache, getInCache, setInCache } from './cache'\n\nasync function getMetaProperty (instanceName, key) {\n  if (hasInCache(metaCache, instanceName, key)) {\n    return getInCache(metaCache, instanceName, key)\n  }\n  const db = await getDatabase(instanceName)\n  const result = await dbPromise(db, META_STORE, 'readonly', (store, callback) => {\n    store.get(key).onsuccess = (e) => {\n      callback(e.target.result)\n    }\n  })\n  setInCache(metaCache, instanceName, key, result)\n  return result\n}\n\nasync function setMetaProperty (instanceName, key, value) {\n  setInCache(metaCache, instanceName, key, value)\n  const db = await getDatabase(instanceName)\n  return dbPromise(db, META_STORE, 'readwrite', (store) => {\n    store.put(value, key)\n  })\n}\n\nexport async function getInstanceVerifyCredentials (instanceName) {\n  return getMetaProperty(instanceName, 'verifyCredentials')\n}\n\nexport async function setInstanceVerifyCredentials (instanceName, value) {\n  return setMetaProperty(instanceName, 'verifyCredentials', value)\n}\n\nexport async function getInstanceInfo (instanceName) {\n  return getMetaProperty(instanceName, 'instance')\n}\n\nexport async function setInstanceInfo (instanceName, value) {\n  return setMetaProperty(instanceName, 'instance', value)\n}\n\nexport async function getLists (instanceName) {\n  return getMetaProperty(instanceName, 'lists')\n}\n\nexport async function setLists (instanceName, value) {\n  return setMetaProperty(instanceName, 'lists', value)\n}\n\nexport async function getCustomEmoji (instanceName) {\n  return getMetaProperty(instanceName, 'customEmoji')\n}\n\nexport async function setCustomEmoji (instanceName, value) {\n  return setMetaProperty(instanceName, 'customEmoji', value)\n}\n\nexport async function getFollowRequestCount (instanceName) {\n  return getMetaProperty(instanceName, 'followRequestCount')\n}\n\nexport async function setFollowRequestCount (instanceName, value) {\n  return setMetaProperty(instanceName, 'followRequestCount', value)\n}\n\nexport async function getFilters (instanceName) {\n  return getMetaProperty(instanceName, 'filters')\n}\n\nexport async function setFilters (instanceName, value) {\n  return setMetaProperty(instanceName, 'filters', value)\n}\n","import { cloneForStorage, getGenericEntityWithId, setGenericEntityWithId } from './helpers'\nimport { RELATIONSHIPS_STORE } from './constants'\nimport { relationshipsCache } from './cache'\n\nexport async function getRelationship (instanceName, accountId) {\n  return getGenericEntityWithId(RELATIONSHIPS_STORE, relationshipsCache, instanceName, accountId)\n}\n\nexport async function setRelationship (instanceName, relationship) {\n  return setGenericEntityWithId(RELATIONSHIPS_STORE, relationshipsCache, instanceName, cloneForStorage(relationship))\n}\n","export const WEB_SHARE_TARGET_DATA_IDB_KEY = 'web-share-data'\n","import { get, set, close, del } from '../_thirdparty/idb-keyval/idb-keyval'\nimport { WEB_SHARE_TARGET_DATA_IDB_KEY } from '../_static/share'\n\nexport function deleteWebShareData () {\n  return del(WEB_SHARE_TARGET_DATA_IDB_KEY)\n}\n\nexport function setWebShareData (data) {\n  return set(WEB_SHARE_TARGET_DATA_IDB_KEY, data)\n}\n\nexport function getWebShareData () {\n  return get(WEB_SHARE_TARGET_DATA_IDB_KEY)\n}\n\nexport function closeKeyValIDBConnection () {\n  return close()\n}\n","// Keep an LRU cache of recently-uploaded files for OCR.\n// We keep them in IDB to avoid tainted canvas errors after a refresh.\n// https://github.com/nolanlawson/pinafore/issues/1901\n\nimport { get, set, keys, del } from '../_thirdparty/idb-keyval/idb-keyval'\n\nconst PREFIX = 'media-cache-'\nconst DELIMITER = '-cache-'\nconst LIMIT = 4 // you can upload 4 images per post, this seems reasonable despite cross-instance usage\nexport const DELETE_AFTER = 604800000 // 7 days\n\nlet deleteAfter = DELETE_AFTER\n\nfunction keyToData (key) {\n  key = key.substring(PREFIX.length)\n  const index = key.indexOf(DELIMITER)\n  // avoiding str.split() to not have to worry about ids containing the delimiter string somehow\n  return [key.substring(0, index), key.substring(index + DELIMITER.length)]\n}\n\nfunction dataToKey (timestamp, id) {\n  return `${PREFIX}${timestamp}${DELIMITER}${id}`\n}\n\nasync function getAllKeys () {\n  return (await keys()).filter(key => key.startsWith(PREFIX)).sort()\n}\n\nexport async function getCachedMediaFile (id) {\n  const allKeys = await getAllKeys()\n\n  for (const key of allKeys) {\n    const otherId = keyToData(key)[1]\n    if (id === otherId) {\n      return get(key)\n    }\n  }\n}\n\nexport async function setCachedMediaFile (id, file) {\n  const allKeys = await getAllKeys()\n\n  if (allKeys.map(keyToData).map(_ => _[1]).includes(id)) {\n    return // do nothing, it's already in there\n  }\n\n  while (allKeys.length >= LIMIT) {\n    // already sorted in chronological order, so delete the oldest\n    await del(allKeys.shift())\n  }\n\n  // delete anything that's too old, while we're at it\n  for (const key of allKeys) {\n    const timestamp = keyToData(key)[0]\n    if (Date.now() - Date.parse(timestamp) >= deleteAfter) {\n      await del(key)\n    }\n  }\n\n  const key = dataToKey(new Date().toISOString(), id)\n\n  await set(key, file)\n}\n\nexport async function deleteCachedMediaFile (id) {\n  const allKeys = await getAllKeys()\n\n  for (const key of allKeys) {\n    const otherId = keyToData(key)[1]\n    if (otherId === id) {\n      await del(key)\n    }\n  }\n}\n\n// The following are only used in tests\n\nexport async function getAllCachedFileIds () {\n  return (await getAllKeys()).map(keyToData).map(_ => _[1])\n}\n\nexport function setDeleteCachedMediaFilesAfter (newDeleteAfter) {\n  deleteAfter = newDeleteAfter\n}\n","export const CLEANUP_TIME_AGO = 5 * 24 * 60 * 60 * 1000 // five days ago\nexport const CLEANUP_DELAY = 5 * 60 * 1000 // five minutes\n","export const TIMELINE_BATCH_SIZE = 20\n\nexport const timelines = {\n  home: { name: 'home', label: \"Home\" },\n  local: { name: 'local', label: \"Local\" },\n  federated: { name: 'federated', label: \"Federated\" }\n}\n","// Forked from https://github.com/sindresorhus/quick-lru/blob/16d15d470a8eb87c2a7dd5b80892d9b74f1acd3c/index.js\n// Adds the ability to listen for 'evict' events using an EventEmitter, also removes some unused code\n\nimport { EventEmitter } from 'events-light'\n\nexport class QuickLRU extends EventEmitter {\n  constructor (options = {}) {\n    super()\n    if (!(options.maxSize && options.maxSize > 0)) {\n      throw new TypeError('`maxSize` must be a number greater than 0')\n    }\n\n    this.maxSize = options.maxSize\n    this.cache = new Map()\n    this.oldCache = new Map()\n    this._size = 0\n  }\n\n  _set (key, value) {\n    this.cache.set(key, value)\n    this._size++\n\n    if (this._size >= this.maxSize) {\n      this._size = 0\n      if (this.listenerCount('evict')) {\n        for (const key of this.oldCache.keys()) {\n          if (!this.cache.has(key)) {\n            this.emit('evict', this.oldCache.get(key), key)\n          }\n        }\n      }\n      this.oldCache = this.cache\n      this.cache = new Map()\n    }\n  }\n\n  get (key) {\n    if (this.cache.has(key)) {\n      return this.cache.get(key)\n    }\n\n    if (this.oldCache.has(key)) {\n      const value = this.oldCache.get(key)\n      this.oldCache.delete(key)\n      this._set(key, value)\n      return value\n    }\n  }\n\n  set (key, value) {\n    if (this.cache.has(key)) {\n      this.cache.set(key, value)\n    } else {\n      this._set(key, value)\n    }\n\n    return this\n  }\n\n  has (key) {\n    return this.cache.has(key) || this.oldCache.has(key)\n  }\n\n  // unused\n  // peek (key) {\n  //   if (this.cache.has(key)) {\n  //     return this.cache.get(key)\n  //   }\n  //\n  //   if (this.oldCache.has(key)) {\n  //     return this.oldCache.get(key)\n  //   }\n  // }\n\n  delete (key) {\n    const deleted = this.cache.delete(key)\n    if (deleted) {\n      this._size--\n    }\n\n    return this.oldCache.delete(key) || deleted\n  }\n\n  clear () {\n    this.cache.clear()\n    this.oldCache.clear()\n    this._size = 0\n  }\n\n  getAllKeys () {\n    const set = new Set()\n    for (const key of this.cache.keys()) {\n      set.add(key)\n    }\n    for (const key of this.oldCache.keys()) {\n      set.add(key)\n    }\n    return set\n  }\n\n  // unused\n  // * keys() {\n  //   for (const [key] of this) {\n  //     yield key;\n  //   }\n  // }\n  //\n  // * values() {\n  //   for (const [, value] of this) {\n  //     yield value;\n  //   }\n  // }\n  //\n  // * [Symbol.iterator]() {\n  //   for (const item of this.cache) {\n  //     yield item;\n  //   }\n  //\n  //   for (const item of this.oldCache) {\n  //     const [key] = item;\n  //     if (!this.cache.has(key)) {\n  //       yield item;\n  //     }\n  //   }\n  // }\n  //\n  // get size () {\n  //   let oldCacheSize = 0\n  //   for (const key of this.oldCache.keys()) {\n  //     if (!this.cache.has(key)) {\n  //       oldCacheSize++\n  //     }\n  //   }\n  //\n  //   return this._size + oldCacheSize\n  // }\n}\n","// Pleroma uses base62 IDs, Mastodon uses 0-9 big ints encoded as strings.\n// Using base62 for both works, since the first 10 characters of base62\n// are 0-9.\n\nimport { padStart } from './lodash-lite'\n\n// Pleroma uses the 0-9A-Za-z alphabet for base62, which is the same as ASCII, which\n// is the same as JavaScript sort order and IndexedDB order.\nconst MIN_CHAR_CODE = 48 // '0'.charCodeAt(0)\nconst MAX_CHAR_CODE = 122 // 'z'.charCodeAt(0)\nconst MAX_ID_LENGTH = 30 // assume that Mastodon/Pleroma IDs won't get any bigger than this\n\nexport function zeroPad (str, toSize) {\n  return padStart(str, toSize, '0')\n}\n\nexport function toPaddedBigInt (id) {\n  return zeroPad(id, MAX_ID_LENGTH)\n}\n\nexport function toReversePaddedBigInt (id) {\n  const padded = toPaddedBigInt(id)\n  let reversed = ''\n  for (let i = 0; i < padded.length; i++) {\n    const charCode = padded.charCodeAt(i)\n    const inverseCharCode = MIN_CHAR_CODE + MAX_CHAR_CODE - charCode\n    reversed += String.fromCharCode(inverseCharCode)\n  }\n  return reversed\n}\n\nexport function compareTimelineItemSummaries (left, right) {\n  const leftPadded = toPaddedBigInt(left.id)\n  const rightPadded = toPaddedBigInt(right.id)\n  return leftPadded < rightPadded ? -1 : leftPadded === rightPadded ? 0 : 1\n}\n"],"sourceRoot":""}