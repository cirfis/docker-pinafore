{"version":3,"sources":["webpack://pinafore/./node_modules/lodash-es/throttle.js","webpack://pinafore/./src/routes/_components/LoadingPage.html","webpack://pinafore/./src/routes/_components/search/StatusSearchResult.html","webpack://pinafore/./src/routes/_components/search/HashtagSearchResult.html","webpack://pinafore/./src/routes/_components/search/SearchResults.html","webpack://pinafore/./src/routes/_components/search/Search.html","webpack://pinafore/./src/routes/_actions/search.js","webpack://pinafore/./src/routes/_pages/search.html","webpack://pinafore/./src/routes/search.html","webpack://pinafore/./src/routes/_api/search.js","webpack://pinafore/./src/routes/_utils/tryToFocusElement.js"],"names":["func","wait","options","leading","trailing","TypeError","setTimeout","this","set","shown","index","length","status","id","hashtag","name","toLowerCase","account","$searchResults","statuses","store","hashtags","accounts","e","preventDefault","stopPropagation","async","currentInstance","accessToken","queryInSearch","searchLoading","results","search","newQueryInSearch","searchResultsForQuery","searchResults","toast","formatIntl","error","message","console","doSearch","tryToFocusElement","on","focusSearchInput","get","onSubmit","event","$searchLoading","$searchResultsForQuery","$queryInSearch","$isUserLoggedIn","pageComponent","params","version","instanceName","query","resolve","limit","excludeUnreviewed","signal","url","q","exclude_unreviewed","timeout","doSearchV2","err","resp","map","tag","history","doSearchV1","i","Promise","element","document","getElementById","focus","preventScroll"],"mappings":"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","file":"6464.cb977c5db5767bb3bc8f.search.js","sourcesContent":["import debounce from './debounce.js';\nimport isObject from './isObject.js';\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a throttled function that only invokes `func` at most once per\n * every `wait` milliseconds. The throttled function comes with a `cancel`\n * method to cancel delayed `func` invocations and a `flush` method to\n * immediately invoke them. Provide `options` to indicate whether `func`\n * should be invoked on the leading and/or trailing edge of the `wait`\n * timeout. The `func` is invoked with the last arguments provided to the\n * throttled function. Subsequent calls to the throttled function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the throttled function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.throttle` and `_.debounce`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to throttle.\n * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=true]\n *  Specify invoking on the leading edge of the timeout.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new throttled function.\n * @example\n *\n * // Avoid excessively updating the position while scrolling.\n * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n *\n * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n * jQuery(element).on('click', throttled);\n *\n * // Cancel the trailing throttled invocation.\n * jQuery(window).on('popstate', throttled.cancel);\n */\nfunction throttle(func, wait, options) {\n  var leading = true,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  if (isObject(options)) {\n    leading = 'leading' in options ? !!options.leading : leading;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n  return debounce(func, wait, {\n    'leading': leading,\n    'maxWait': wait,\n    'trailing': trailing\n  });\n}\n\nexport default throttle;\n","<div class=\"loading-page {shown ? '' : 'hidden'}\">\n  <LoadingSpinner />\n</div>\n<style>\n  .loading-page {\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    height: 150px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    z-index: 50;\n    transition: opacity 0.25s linear;\n  }\n</style>\n<script>\n  import LoadingSpinner from './LoadingSpinner.html'\n\n  const SPINNER_DELAY = 700\n\n  export default {\n    oncreate () {\n      setTimeout(() => {\n        this.set({ shown: true })\n      }, SPINNER_DELAY)\n    },\n    data: () => ({\n      shown: false\n    }),\n    components: {\n      LoadingSpinner\n    }\n  }\n</script>","<SearchResult href=\"/statuses/{status.id}\">\n  <Status {index} {length}\n          timelineType=\"search\" timelineValue=\"search\"\n          {status} />\n</SearchResult>\n<style>\n</style>\n<script>\n  import SearchResult from './SearchResult.html'\n  import Status from '../status/Status.html'\n\n  export default {\n    components: {\n      SearchResult,\n      Status\n    }\n  }\n</script>","<SearchResult href=\"/tags/{hashtag.name.toLowerCase()}\">\n  {'#' + hashtag.name}\n</SearchResult>\n<style>\n</style>\n<script>\n  import SearchResult from './SearchResult.html'\n  export default {\n    components: {\n      SearchResult\n    }\n  }\n</script>\n","<ul class=\"search-results\">\n  {#each $searchResults.hashtags as hashtag}\n    <HashtagSearchResult {hashtag} />\n  {/each}\n  {#each $searchResults.accounts as account}\n    <AccountSearchResult {account} />\n  {/each}\n  {#each $searchResults.statuses as status, index}\n  <StatusSearchResult {status} {index} length={$searchResults.statuses.length}/>\n  {/each}\n</ul>\n<style>\n  .search-results {\n    list-style: none;\n    box-sizing: border-box;\n    border: 1px solid var(--main-border);\n    border-radius: 2px;\n  }\n</style>\n<script>\n  import { store } from '../../_store/store'\n  import AccountSearchResult from './AccountSearchResult.html'\n  import HashtagSearchResult from './HashtagSearchResult.html'\n  import StatusSearchResult from './StatusSearchResult.html'\n\n  export default {\n    store: () => store,\n    components: {\n      AccountSearchResult,\n      HashtagSearchResult,\n      StatusSearchResult\n    }\n  }\n</script>","<form class=\"search-input-form\" on:submit=\"onSubmit(event)\">\n  <label class=\"sr-only\" for=\"the-search-input\">Search</label>\n  <div class=\"search-input-wrapper\">\n    <input id=\"the-search-input\"\n           type=\"search\"\n           class=\"search-input\"\n           placeholder=\"Search\"\n           required\n           bind:value=\"$queryInSearch\">\n  </div>\n  <button type=\"submit\" class=\"primary search-button\" aria-label=\"Search\" disabled={$searchLoading}>\n    <SvgIcon className=\"search-button-svg\" href=\"#fa-search\" />\n  </button>\n</form>\n{#if $searchLoading}\n  <div class=\"search-results-container\">\n    <LoadingPage />\n  </div>\n{:elseif $searchResults && $searchResultsForQuery === $queryInSearch}\n  <div class=\"search-results-container\">\n    <SearchResults />\n  </div>\n{/if}\n<style>\n  .search-input-form {\n    display: grid;\n    grid-template-columns: 1fr min-content;\n    grid-gap: 10px;\n  }\n  .search-input-wrapper {\n    position: relative;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n  }\n  .search-input {\n    padding: 10px 15px;\n    border-radius: 10px;\n    flex: 1;\n    width: 0;\n    min-width: 0;\n  }\n  :global(.search-button-svg) {\n    fill: var(--button-primary-text);\n    width: 18px;\n    height: 18px;\n    flex: 1;\n  }\n  .search-results-container {\n    position: relative;\n    margin-top: 20px;\n  }\n  @media (min-width: 768px) {\n    .search-button {\n      min-width: 100px;\n    }\n  }\n</style>\n<script>\n  import { store } from '../../_store/store'\n  import LoadingPage from '../LoadingPage.html'\n  import { doSearch } from '../../_actions/search'\n  import SearchResults from './SearchResults.html'\n  import SvgIcon from '../SvgIcon.html'\n  import { on } from '../../_utils/eventBus'\n  import { tryToFocusElement } from '../../_utils/tryToFocusElement'\n\n  export default {\n    oncreate () {\n      on('focusSearchInput', this, () => this.focusSearchInput()) // user typed hotkey on this page itself\n      if (this.store.get().focusSearchInput) { // we arrived here from a goto via the search hotkey\n        this.store.set({ focusSearchInput: false }) // reset\n        this.focusSearchInput()\n      }\n    },\n    store: () => store,\n    components: {\n      LoadingPage,\n      SearchResults,\n      SvgIcon\n    },\n    methods: {\n      onSubmit (e) {\n        e.preventDefault()\n        e.stopPropagation()\n        /* no await */ doSearch()\n      },\n      focusSearchInput () {\n        tryToFocusElement('the-search-input')\n      }\n    }\n  }\n</script>\n","import { store } from '../_store/store'\nimport { toast } from '../_components/toast/toast'\nimport { search } from '../_api/search'\nimport { formatIntl } from '../_utils/formatIntl'\n\nexport async function doSearch () {\n  const { currentInstance, accessToken, queryInSearch } = store.get()\n  store.set({ searchLoading: true })\n  try {\n    const results = await search(currentInstance, accessToken, queryInSearch)\n    const { queryInSearch: newQueryInSearch } = store.get() // avoid race conditions\n    if (newQueryInSearch === queryInSearch) {\n      store.set({\n        searchResultsForQuery: queryInSearch,\n        searchResults: results\n      })\n    }\n  } catch (e) {\n    /* no await */ toast.say(formatIntl([\"Error during search: \",[\"error\"]], { error: (e.message || '') }))\n    console.error(e)\n  } finally {\n    store.set({ searchLoading: false })\n  }\n}\n","{#if $isUserLoggedIn}\n<div class=\"search-page\">\n  <Search></Search>\n</div>\n{:else}\n<HiddenFromSSR>\n  <FreeTextLayout>\n    <h1>Search</h1>\n\n    <p>You can search once logged in to an instance.</p>\n  </FreeTextLayout>\n</HiddenFromSSR>\n<div style=\"display: none\">\n  <!-- TODO: this is just a hack so that `sapper export` knows to crawl these files -->\n  <!-- Note that these links have to be spread out or else they result in ECONNRESET errors during crawling -->\n  <!-- See also community/index.html -->\n  <a href=\"/local\">Local</a>\n  <a href=\"/federated\">Federated</a>\n  <a href=\"/favorites\">Favorites</a>\n  <a href=\"/direct\">Direct messages</a>\n  <a href=\"/bookmarks\">Bookmarks</a>\n</div>\n{/if}\n<style>\n  .search-page {\n    padding: 20px 20px;\n  }\n\n  @media (max-width: 767px) {\n    .search-page {\n      padding: 20px 10px;\n    }\n  }\n</style>\n<script>\n  import FreeTextLayout from '../_components/FreeTextLayout.html'\n  import { store } from '../_store/store.js'\n  import HiddenFromSSR from '../_components/HiddenFromSSR'\n  import Search from '../_components/search/Search.html'\n\n  export default {\n    store: () => store,\n    components: {\n      Search,\n      FreeTextLayout,\n      HiddenFromSSR\n    }\n  }\n</script>\n","<Title name=\"Search\" />\n\n  <LazyPage {pageComponent} {params} />\n\n<script>\n  import Title from './_components/Title.html'\n  import LazyPage from './_components/LazyPage.html'\n  import pageComponent from './_pages/search.html'\n\n  export default {\n    components: {\n\n      Title,\n      LazyPage\n    },\n    data: () => ({\n      pageComponent\n    })\n  }\n</script>\n","import { get, paramsString, DEFAULT_TIMEOUT } from '../_utils/ajax'\nimport { auth, basename } from './utils'\n\nfunction doSearch (version, instanceName, accessToken, query, resolve, limit, excludeUnreviewed, signal) {\n  const url = `${basename(instanceName)}/api/${version}/search?` + paramsString({\n    q: query,\n    resolve,\n    limit,\n    exclude_unreviewed: !!excludeUnreviewed\n  })\n  return get(url, auth(accessToken), {\n    timeout: DEFAULT_TIMEOUT,\n    signal\n  })\n}\n\nasync function doSearchV1 (instanceName, accessToken, query, resolve, limit, excludeUnreviewed, signal) {\n  const resp = await doSearch('v1', instanceName, accessToken, query, resolve, limit, excludeUnreviewed, signal)\n  resp.hashtags = resp.hashtags && resp.hashtags.map(tag => ({\n    name: tag,\n    url: `${basename(instanceName)}/tags/${tag.toLowerCase()}`,\n    history: []\n  }))\n  return resp\n}\n\nasync function doSearchV2 (instanceName, accessToken, query, resolve, limit, excludeUnreviewed, signal) {\n  return doSearch('v2', instanceName, accessToken, query, resolve, limit, excludeUnreviewed, signal)\n}\n\nexport async function search (instanceName, accessToken, query, resolve = true, limit = 5,\n  excludeUnreviewed = false, signal = null) {\n  try {\n    return (await doSearchV2(instanceName, accessToken, query, resolve, limit, excludeUnreviewed, signal))\n  } catch (err) {\n    if (err && err.status === 404) { // fall back to old search API\n      return doSearchV1(instanceName, accessToken, query, resolve, limit, excludeUnreviewed, signal)\n    } else {\n      throw err\n    }\n  }\n}\n","// try 5 times to wait for the element to be rendered and then focus it\nimport { scheduleIdleTask } from './scheduleIdleTask'\n\nconst RETRIES = 5\nconst TIMEOUT = 50\n\nexport async function tryToFocusElement (id) {\n  for (let i = 0; i < RETRIES; i++) {\n    if (i > 0) {\n      await new Promise(resolve => setTimeout(resolve, TIMEOUT))\n    }\n    await new Promise(resolve => scheduleIdleTask(resolve))\n    const element = document.getElementById(id)\n    if (element) {\n      try {\n        element.focus({ preventScroll: true })\n        console.log('focused element', id)\n        return\n      } catch (e) {\n        console.error(e)\n      }\n    }\n  }\n  console.log('failed to focus element', id)\n}\n"],"sourceRoot":""}