let root,toInteger,toNumber,toString;_3f2‍.x([["default",()=>_3f2‍.o]]);_3f2‍.w("./_root.js",[["default",["root"],function(v){root=v}]]);_3f2‍.w("./toInteger.js",[["default",["toInteger"],function(v){toInteger=v}]]);_3f2‍.w("./toNumber.js",[["default",["toNumber"],function(v){toNumber=v}]]);_3f2‍.w("./toString.js",[["default",["toString"],function(v){toString=v}]]);




/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsFinite = root.isFinite,
    nativeMin = Math.min;

/**
 * Creates a function like `_.round`.
 *
 * @private
 * @param {string} methodName The name of the `Math` method to use when rounding.
 * @returns {Function} Returns the new round function.
 */
function createRound(methodName) {
  var func = Math[methodName];
  return function(number, precision) {
    number = toNumber(number);
    precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
    if (precision && nativeIsFinite(number)) {
      // Shift with exponential notation to avoid floating-point issues.
      // See [MDN](https://mdn.io/round#Examples) for more details.
      var pair = (toString(number) + 'e').split('e'),
          value = func(pair[0] + 'e' + (+pair[1] + precision));

      pair = (toString(value) + 'e').split('e');
      return +(pair[0] + 'e' + (+pair[1] - precision));
    }
    return func(number);
  };
}

_3f2‍.d(createRound);
