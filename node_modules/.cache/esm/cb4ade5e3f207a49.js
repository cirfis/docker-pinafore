let baseIsEqual,get,hasIn,isKey,isStrictComparable,matchesStrictComparable,toKey;_3f2‍.x([["default",()=>_3f2‍.o]]);_3f2‍.w("./_baseIsEqual.js",[["default",["baseIsEqual"],function(v){baseIsEqual=v}]]);_3f2‍.w("./get.js",[["default",["get"],function(v){get=v}]]);_3f2‍.w("./hasIn.js",[["default",["hasIn"],function(v){hasIn=v}]]);_3f2‍.w("./_isKey.js",[["default",["isKey"],function(v){isKey=v}]]);_3f2‍.w("./_isStrictComparable.js",[["default",["isStrictComparable"],function(v){isStrictComparable=v}]]);_3f2‍.w("./_matchesStrictComparable.js",[["default",["matchesStrictComparable"],function(v){matchesStrictComparable=v}]]);_3f2‍.w("./_toKey.js",[["default",["toKey"],function(v){toKey=v}]]);







/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get(object, path);
    return (objValue === undefined && objValue === srcValue)
      ? hasIn(object, path)
      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}

_3f2‍.d(baseMatchesProperty);
