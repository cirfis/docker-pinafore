let apply,createCtor,createHybrid,createRecurry,getHolder,replaceHolders,root;_3f2‍.x([["default",()=>_3f2‍.o]]);_3f2‍.w("./_apply.js",[["default",["apply"],function(v){apply=v}]]);_3f2‍.w("./_createCtor.js",[["default",["createCtor"],function(v){createCtor=v}]]);_3f2‍.w("./_createHybrid.js",[["default",["createHybrid"],function(v){createHybrid=v}]]);_3f2‍.w("./_createRecurry.js",[["default",["createRecurry"],function(v){createRecurry=v}]]);_3f2‍.w("./_getHolder.js",[["default",["getHolder"],function(v){getHolder=v}]]);_3f2‍.w("./_replaceHolders.js",[["default",["replaceHolders"],function(v){replaceHolders=v}]]);_3f2‍.w("./_root.js",[["default",["root"],function(v){root=v}]]);







/**
 * Creates a function that wraps `func` to enable currying.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
 * @param {number} arity The arity of `func`.
 * @returns {Function} Returns the new wrapped function.
 */
function createCurry(func, bitmask, arity) {
  var Ctor = createCtor(func);

  function wrapper() {
    var length = arguments.length,
        args = Array(length),
        index = length,
        placeholder = getHolder(wrapper);

    while (index--) {
      args[index] = arguments[index];
    }
    var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
      ? []
      : replaceHolders(args, placeholder);

    length -= holders.length;
    if (length < arity) {
      return createRecurry(
        func, bitmask, createHybrid, wrapper.placeholder, undefined,
        args, holders, undefined, undefined, arity - length);
    }
    var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
    return apply(fn, this, args);
  }
  return wrapper;
}

_3f2‍.d(createCurry);
